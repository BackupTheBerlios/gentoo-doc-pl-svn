<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Orig revision: 1.33 -->
<!-- Translator: lucass <lucass@gentoo.pl> -->
<!-- Title: Przygotowanie Dysków -->
<!-- Status: Ukończono -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/handbook/Attic/hb-install-disk.xml,v 1.17 2004/01/25 13:45:46 lcs Exp $ -->

<sections>
<section>
<title>Wprowadzenie do Urządzeń Blokowych</title>
<subsection>
<title>Urządzenia Blokowe</title>
<body>

<p>
Rzućmy okiem na aspekty Gentoo Linux, oraz ogólnie Linuksa, związane z dyskami.
Omówimy systemy plików, partycje oraz urządzenia blokowe. Następnie
przeprowadzimy Cię przez proces podziału twardego dysku, aby jak najlepiej
wykorzystać dostępną przestrzeń.
</p>

<p>
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path>, reprezentujący w Linuksie pierwszy 
napęd IDE. Jeśli posiadasz urządzenia SCSI, pierwszym takim
dyskiem jest <path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy
użytkownika mogą z nich korzystać nie martwiąc się czy napędy
są typu IDE, SCSI lub jeszcze inne. Przechowywane dane adresuje się
za jako ciąg 512-bajtowych bloków.
</p>

</body>
</subsection>
<subsection>
<title>Partycje i Plastry</title>
<body>

<p>
Jakkolwiek teoretycznie możliwe jest przeznaczenie na system całego dysku,
zazwyczaj nie jest to rozwiązanie praktyczne. Zamiast tego, dzieli się
napęd na mniejsze, łatwiejsze w zarządzaniu, urządzenia blokowe.
W większości platform nazywane są one <e>partycjami</e>. Część architektur,
korzystająca z podobnych technik nazywa je <e>plastrami</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partycje</title>
<body>

<p>
Wyróżniamy trzy rodzaje partycji: <e>podstawowe</e>,
<e>rozszerzone</e> oraz <e>logiczne</e>.
</p>

<p>
Informacje o partycjach <e>podstawowych</e> przechowywane są w MBR
(master boot record). Jako że jest on bardzo mały (512 bajtów), mieszczą 
się w nim dane najwyżej czterech takich partycji (na przykład,
od <path>/dev/hda1</path> do <path>/dev/hda4</path>).
</p>

<p>
Specjalną odmianą partycji podstawowych są partycje <e>rozszerzone</e>
(oznacza to, że również obowiązuje je powyższy limit). Przechowują
one kolejne partycje. W ten sposób można ominąć niewygodną granicę
i lepiej zagospodarować przestrzeń dyskową bez utraty kompatybilności
wstecz.
</p>

<p>
Partycje umieszczone i opisane wewnątrz rozszerzonych nazywamy <e>logicznymi</e>.
</p>

</body>
</subsection>
<!-- TODO rewrite with LVM2 instructions when appropriate
<subsection>
<title>Woluminy Logiczne</title>
<body>

<p>
Niektórym użytkownikom ograniczenia partycji i plastrów wydadzą się zbyt
surowe. Jeśli jesteś jednym z nich, powinieneś zwrócić uwagę na LVM
- <e>Menadżer Woluminów Logicznych</e>.
</p>

<p>
Dzięki LVM możesz zwyczajnie tworzyć partycje (lub plastry), ale nie używasz
ich do przechowywania systemu. Zamiast tego, dodajesz kolejną warstwę
danych (zwaną warstwą LVM) na której instalujesz Gentoo. Jakie są zalety
przedstawionego rozwiązania?
</p>

<p>
Do głównych plusów możemy zaliczyć łatwą zmianę rozmiarów woluminów.
Bardzo praktyczne wydaje się także pobieranie migawki bez zatrzymywania
systemu, pozwalające na opracowanie mniej uciążliwej dla użytkowników strategii
kopii zapasowych (i znacznie mniej problematycznej). Kolejną
zaletą jest możliwość dodawania do jednego woluminu kilku dysków
(co pozwala na rozszerzanie dostępnej przestrzeni bez żmudnego
przenoszenia danych).
</p>

<p>
Menadżer Woluminów Logicznych składa się z trzech abstrakcyjnych warstw.
Partycje, plastry lub dyski, na których chcesz umieścić warstwę LVM
nazywamy <e>woluminami fizycznymi</e>. Łączymy je w tak zwane
<e>grupy woluminów</e>, zawierające <e>woluminy logiczne</e> - będące
czymś w rodzaju wirtualnych partycji.
</p>

<p>
Woluminów logicznych używamy jak zwyczajnych partycji; jakkolwiek,
jeśli na jednym z nich zabraknie miejsca, możesz go rozszerzyć korzystając z wolnej
przestrzeni znajdującej się w grupie woluminów. Jeżeli grupa woluminów
również okaże się zbyt mała, dodać do niej możesz więcej woluminów
fizycznych. Wszystkie te czynności są całkowicie niewidoczne dla
użytkowników (nie wymagają przenoszenia danych, zatrzymywania systemu itd.).
Jak widać LVM jest niezwykle elastyczne.
</p>

<p>
Jeśli zdecydowałeś się skorzystać z LVM, zmuszony będziesz
przechowywać główny system plików (<path>/</path>) oraz system plików
boot (<path>/boot</path>) poza nim. Na pocieszenie dodam, iż
jeżeli większość danych wolisz trzymać w woluminach logicznych 
(w podręczniku opiszemy to na przykładzie <path>/home</path>, <path>/usr</path>, 
<path>/tmp</path>, <path>/opt</path> oraz <path>/var</path>) to
główny system plików nie musi być duży (zazwyczaj wystarcza 150MB).
</p>

</body>
</subsection>
-->
</section>
<section>
<title>Projektowanie Schematu Podziału</title>
<subsection>
<title>Domyślny Schemat Podziału</title>
<body>

<p>
Jeśli nie masz ochoty samodzielnie rozrysowywać schematu podziału
swojego dysku, możesz skorzystać z domyślnego (nie dotyczy LVM), którego
użyjemy w podręczniku:
</p>

<p>
Dla x86 lub amd64:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Dla ppc:
</p>

<table>
<tr>
  <th>Partycja NewWorld</th>
  <th>Partycja OldWorld</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Nie wymagana)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Dla Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Cały dysk</ti>
  <ti>Sun Disk Label (wymagana)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>
<!-- TODO rewrite with LVM2 instructions when appropriate
<p>
Jeżeli wolisz LVM, powinieneś utworzyć niedużą partycję
root, pominąć swap i resztę dysku przeznaczyć na jedną wielką partycję,
którą dzielił będziesz w przyszłości, podczas definiowania woluminów logicznych. 
Nadaj jej typ "Linux LVM" lub "LVM" (8e).
</p>
-->
<p>
Użytkownicy instalujący Gentoo Linux z zainstalowanej dystrybucji, powinni
najpierw zmniejszyć istniejące partycje (oczywiście o ile nie pozostawili
w zapasie wolnej przestrzeni) aby zdobyć miejsce na nowy system. W tym
celu mogą skorzystać z wygodnego narzędzia <uri 
link="http://www.gnu.org/software/parted">GNU/Parted</uri>.
</p>

<p>
Jeśli interesują Cię nasze rady dotyczące rozmiarów partycji
(lub woluminów logicznych) oraz ich ilości, czytaj dalej.
W przeciwnym wypadku przejdź od razu do podziału dysku:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Partycjonowanie Dysku za pomocą fdisk na x86 lub amd64</uri>
</li>
<li>
  <uri link="#doc_chap4">Partycjonowanie Dysku za pomocą fdisk na Alpha</uri>
</li>
<li>
  <uri link="#doc_chap5">Partycjonowanie Dysku za pomocą fdisk na SPARC</uri>
</li>
<li>
  <uri link="#doc_chap6">Partycjonowanie Dysku za pomocą mac-fdisk na PPC</uri>
</li>
<li>
  <uri link="#doc_chap7">Partycjonowanie Dysku za pomocą fdisk na HPPA</uri>
</li>
<li>
  <uri link="#doc_chap8">Partycjonowanie Dysku za pomocą fdisk na MIPS</uri>
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Jak Dużo Jak Wielkich?</title>
<body>

<p>
Ilość partycji ściśle zależy od danego
środowiska. Na przykład, jeśli administrujesz systemem mającym
wielu użytkowników, prawdopodobnie uznasz za stosowne
oddzielenie <path>/home</path> aby poprawić bezpieczeństwo
i uprościć tworzenie kopii zapasowych. Jeżeli docelowym
zastosowaniem świeżego Gentoo jest serwer poczty, na osobnej 
partycji powinieneś umieścić <path>/var</path>, gdzie przechowywane
są listy. Dobry wybór systemu plików może tu znacznie zwiększyć
wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem
na serwerach gier, gdyż większość używanego oprogramowania zostanie
tam zainstalowana. Powód jest podobny do <path>/home</path>: bezpieczeństwo
i kopie zapasowe.
</p>

<p>
Jak widzisz, wiele zależy od oczekiwanego rezultatu. Wydzielenie partycji
lub woluminów ma wiele zalet:
</p>

<ul>
<li>
  Masz możliwość dostosowania jak najwydajniejszego w danym zastosowaniu
  systemu plików dla poszczególnych partycji lub woluminów
</li>
<li>
  W przypadku zapełnienia partycji przez nieprawidłowo działające
  narzędzie, nie ma to wpływu na całość systemu
</li>
<li>
  Jeśli to konieczne, można skrócić czas kontroli systemów plików, gdyż
  można jednocześnie dokonywać jej na kilku partycjach (ma to znaczenie
  zwłaszcza na sprzęcie z wieloma dyskami)
</li>
<li>
  Montując część partycji lub woluminów z opcjami read-only (tylko do odczytu),
  nosuid (ignorowane są bity setuid), noexec (ignorowane są bity wykonywalności) itd.
  można znacznie poprawić bezpieczeństwo
</li>
</ul>

<p>
Niestety zbyt rozbudowany podział niesie z sobą spore niebezpieczeństwo: 
źle zaplanowany zaowocuje pustkami na zbyt dużych
i ciasnotą na zbyt małych partycjach.
</p>

<p>
W przykładzie pokażemy partycjonowanie dysku 20GB, wykorzystywanego
w pokazowym laptopie z zainstalowanymi serwerami poczty oraz WWW,
GNOME, itd.:
</p>

<pre caption="Przykładowy podział dysku">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Zostało nam 2GB niespartycjonowanej przestrzeni, którą będziemy mogli wykorzystać w przyszłości</comment>
</pre>

<p>
<path>/usr</path> jest niemal w pełni zajęty (wykorzystane 83%),
ale po instalacji wszystkich potrzebnych pakietów nie będzie się
on zbytnio rozrastał. Część czytelników może pomyśleć, iż
zbyt wiele miejsca przeznaczyliśmy na <path>/var</path>. 
Należy zwrócić uwagę, że Gentoo kompiluje wszystkie pakiety
wewnątrz <path>/var/tmp/portage</path>. Powinien mieć
wobec tego przynajmniej 1GB wolnej przestrzeni, jeśli nie zamierzasz
kompilować większych programów, lub nawet 3GB - gdy
jednoczesna instalacja KDE i OpenOffice.org nie stanowi dla Ciebie
problemu.
</p>

<p>
Podziel teraz swój dysk, korzystając z instrukcji dla danej architektury:
</p>
<ul>
<li>
  <uri link="#doc_chap3">Partycjonowanie Dysku za pomocą fdisk na x86 lub amd64</uri>
</li>
<li>
  <uri link="#doc_chap4">Partycjonowanie Dysku za pomocą fdisk na Alpha</uri>
</li>
<li>
  <uri link="#doc_chap5">Partycjonowanie Dysku za pomocą fdisk na SPARC</uri>
</li>
<li>
  <uri link="#doc_chap6">Partycjonowanie Dysku za pomocą mac-fdisk na PPC</uri>
</li>
<li>
  <uri link="#doc_chap7">Partycjonowanie Dysku za pomocą fdisk na HPPA</uri>
</li>
<li>
  <uri link="#doc_chap8">Partycjonowanie Dysku za pomocą fdisk na MIPS</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na x86 lub amd64</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektur <e>x86</e>
i <e>amd64</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>

</body>
</subsection>
<subsection>
<title>Wyświetlanie Aktualnego Podziału Dysku</title>
<body>

<p>
<c>fdisk</c> to znane i funkcjonalne narzędzie do partycjonowania.
Uruchom go dla swojego dysku (pokażemy to na przykładzie <path>/dev/hda</path>):
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Twoim oczom ukaże się podobny znak zachęty:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help): 
</pre>

<p>
Aby wyświetlić obecną konfigurację partycji, wpisz <c>p</c>:
</p>

<pre caption="Przykładowa konfiguracja partycji">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Na prezentowanym dysku znajduje się siedem linuksowych systemów plików
(każdy na odpowiadającej partycji, oznaczonej jako "Linux") oraz partycja
wymiany (oznaczona jako "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Kasowanie wszystkich Partycji</title>
<body>

<p>
Zacznijmy od usunięcia partycji. Służy do tego polecenie <c>d</c> z odpowiednim parametrem.
Na przykład, aby pozbyć się <path>/dev/hda1</path>:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Nasza partycja została oznaczona do usunięcia. Nie będzie więcej pojawiać się
po wydaniu polecenia <c>p</c>, ale dopóki zmiany nie zostaną zapisane
fizycznie, pozostanie nie naruszona. Jeśli popełnisz błąd i zechcesz
anulować wszelkie zmiany, wpisz natychmiast <c>q</c> i wciśnij Enter.
Twoje modyfikacje pójdą w niepamięć.
</p>

<p>
Zakładając, że chcesz pozbyć się wszystkich istniejących partycji,
na przemian wykonuj <c>p</c> aby wyświetlić ich listing i
po kolei kasuj je poleceniem <c>d</c> z odpowiednim numerem. Po ukończeniu,
<c>p</c> powinno dać następujący rezultat:
</p>

<pre caption="Pusta tablica partycji">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Kiedy nasza tymczasowa kopia tablicy partycji będzie pusta, możemy rozpocząć
tworzenie nowego podziału. Pokażemy to na przykładzie domyślnego omawianego
schematu. Oczywiście jeśli Ci on nie odpowiada, musisz poczynić stosowne
modyfikacje prezentowanych poleceń.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Boot</title>
<body>

<p>
Rozpoczniemy od utworzenia niewielkiej partycji boot. Wpisz <c>n</c> aby
ją założyć, następnie <c>p</c> aby nadać jej typ podstawowy i <c>1</c>,
ponieważ będzie to pierwsza taka partycja. Zapytany o pierwszy cylinder
wciśnij Enter, natomiast zapytany o ostatni, wpisz <c>+32M</c>, żeby nadać
jej rozmiar 32MB.
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Wciśnij Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Teraz polecenie <c>p</c> powinno pokazać następujący listing:
</p>

<pre caption="Utworzona partycja boot" >
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Musimy oznaczyć naszą partycję jako uruchamialną. W tym celu skorzystamy
z polecenia <c>a</c>. Na kolejnych wydrukach podziału, w kolumnie
"Boot" pokazywać się będzie <path>*</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Swap</title>
<body>

<p>
Nadszedł czas na utworzenie partycji wymiany. Ponownie skorzystaj z polecenia
<c>n</c>, następnie podaj <c>p</c> gdyż ma to być partycja podstawowa i <c>2</c>,
ponieważ będzie ona drugą tego typu. Zapytany o pierwszy cylinder wciśnij Enter,
natomiast na pytanie o ostatni wpisz <c>+512M</c>, żeby nadać partycji
rozmiar 512MB. Po ukończeniu wykonaj <c>t</c>, aby zmienić jej typ,
<c>2</c>, aby wybrać tę, którą właśnie stworzyłeś i <c>82</c>, żeby oznaczyć
ją jako "Linux Swap". Teraz polecenie <c>p</c> powinno dać następujący
listing:
</p>

<pre caption="Listing podziału po utworzeniu partycji wymiany">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Root</title>
<body>

<p>
Na koniec, utworzymy partycję root. Jeszcze raz posłużymy się w tym celu poleceniem
<c>n</c>. Zapytany o rodzaj wpisz <c>p</c>, ponieważ chcemy by była podstawowa,
następnie <c>3</c>, gdyż będzie już trzecią tego typu, czyli w naszym przypadku
<path>/dev/hda3</path>. Na pytanie o pierwszy i ostatni cylinder wciśnij Enter,
dzięki temu zajmie ona całą pozostałą wolną przestrzeń. Teraz polecenie
<c>p</c> powinno pokazać następujący wydruk:
</p>

<pre caption="Listing podziału po utworzeniu partycji root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Zapisywanie Podziału Partycji</title>
<body>

<p>
Aby zachować ustalony podział i opuścić <c>fdisk</c>, wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoje partycje są już gotowe, 
<!-- jeśli nie zdecydowałeś się skorzystać z LVM to 
--> możesz teraz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
<!-- W przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>. -->
</p>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na Alpha</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektury <e>Alpha</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie (nie dotyczy LVM):
</p>

<table>
<tr>
  <th>Plaster</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Plaster swap</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Plaster root</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Cały dysk (wymagane)</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>


</body>
</subsection>
<subsection>
<title>Sprawdzanie Dostępnych Dysków</title>
<body>

<p>
Aby rozejrzeć się w dostępnych dyskach, skorzystaj z następujących poleceń:
</p>

<pre caption="Sprawdzanie dostępnych dysków">
<comment>(Dla dysków IDE)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Dla dysków SCSI)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Na podstawie rezultatu powinieneś wywnioskować, które dyski zostały
wykryte i jakie urządzenia w <path>/dev</path> je reprezentują. W kolejnych
podsekcjach zakładamy, iż korzystasz z pierwszego dysku SCSI (<path>/dev/sda</path>).
</p>

<p>
Uruchom teraz <c>fdisk</c>:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Usuwanie Wszystkich Plastrów</title>
<body>

<p>
Zaczniemy od pozbycia się wszystkich plastrów, <e>z wyjątkiem</e> plastra 'c'.
Pokażemy jak to zrobić na przykładzie 'a'. Powtórz ten proces aby
usunąć również pozostałe (oczywiście oprócz 'c').
</p>

<p>
Aby wyświetlić aktualny podział skorzystaj z polecenia <c>p</c>. Do usuwania
służy <c>d</c>.
</p>

<pre caption="Usuwanie plastra">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Po powtórzeniu powyższego procesu dla wszystkich plastrów, listing powinien
przedstawiać się następująco:
</p>

<pre caption="Wyświetlanie pustego schematu">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Plastra Swap</title>
<body>

<p>
W komputerach Alpha nie ma konieczności tworzenia partycji boot. Jakkolwiek
pierwszy cylinder zostanie zajęty obrazem <c>aboot</c>.
</p>

<p>
Utworzymy teraz plaster swap, począwszy od trzeciego cylindra o rozmiarze
1GB. W tym celu skorzystaj z polecenia <c>n</c>. Następnie
zmień jego typ na <c>1</c>, czyli <e>swap</e>.
</p>

<pre caption="Zakładanie plastra swap">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Teraz listing podziału powinien wyglądać podobnie:
</p>

<pre caption="Listing podziału po założeniu plastra swap">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Plastra Root</title>
<body>

<p>
Nadszedł czas na utworzenie plastra root. Powinien on zaczynać się
od pierwszego cylindra <e>po</e> plastrze swap. Aby zobaczyć gdzie kończy
się ów plaster skorzystaj z polecenia <c>p</c>. W naszym przykładzie
jest to 1003, a więc początkiem plastra root będzie cylinder 1004.
</p>

<p>
Obecnie w programie <c>fdisk</c> znajduje się błąd, powodujący iż
liczba dostępnych cylindrów jest o jeden większa od faktycznej.
Innymi słowy, zapytany o ostatni cylinder, podaj numer (w naszym przykładzie
5290) zmniejszony o jeden.
</p>

<p>
Po założeniu partycji, zmień jej typ na <c>8</c>, czyli <e>ext2</e>.
</p>

<pre caption="Zakładanie plastra root">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Teraz schemat podziału powinien wyglądać następująco:
</p>

<pre caption="Wyświetlanie listingu podziału">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Zapisywanie Podziału Plastrów i Zamykanie fdisk</title>
<body>

<p>
Aby zapisać zmiany i opuścić <c>fdisk</c> wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoj plastry są już gotowe, 
<!-- jeśli nie zdecydowałeś się skorzystać z LVM to 
--> możesz teraz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
<!-- W przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>. -->
</p>


</body>
</subsection>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na SPARC</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektury <e>SPARC</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie (nie dotyczy LVM):
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (wymagany)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>


</body>
</subsection>
<subsection>
<title>Uruchamianie fdisk</title>
<body>

<p>
Uruchom <c>fdisk</c> dla swojego dysku:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Twoim oczom ukaże się jego znak zachęty:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help):
</pre>

<p>
Aby wyświetlić dostępne partycje, wpisz <c>p</c>:
</p>

<pre caption="Wyświetlanie dostępnych partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Zwróć uwagę na <c>Sun disk label</c>. Jeśli go brakuje, oznacza to że 
dysk korzysta z partycji DOS. W takim razie, aby stworzyć
tablicę partycji Sun, wpisz <c>s</c>.
</p>

</body>
</subsection>
<subsection>
<title>Usuwanie Istniejących Partycji</title>
<body>

<p>
Nadszedł czas na pozbycie się istniejących partycji. Do usuwania
służy polecenie <c>d</c>. Wpisz je i naciśnij Enter. Zostaniesz zapytany
o numer partycji. Jeśli ma to być <path>/dev/hda1</path>, wpisz:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Aby skasować wszystkie istniejące partycje, na przemian wpisuj <c>p</c>
aby zobaczyć jakie są dostępne i <c>d</c>, żeby je kasoawć.
Jeśli popełnisz błąd, natychmiast wpisz <c>q</c> -- <c>fdisk</c>
przeprowadza wszelkie zmiany w pamięci i możesz je w ten sposób anulować.
Do zachowywania zmian służy polecenie <c>w</c>.
</p>

<p>
Po usunięciu wszystkich partycji, listing podziału powinien wyglądać podobnie:
</p>

<pre caption="Pusty listing podziału">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Tworzenie Sun Disk Label</title>
<body>

<p>
Kiedy pozbędziesz się wszystkich partycji, możesz utworzyć Sun Disk Label.
W tym celu wpisz <c>n</c> aby rozpocząć zakładanie, następnie <c>3</c>
aby wybrać trzecią partycję. Zarówno zapytany o pierwszy jak i ostatni
cylinder wciśnij Enter. Następnie wpisz <c>t</c> aby zmodyfikować
typ partycji i <c>5</c> aby ustawić go na "Whole disk".
</p>

<pre caption="Zakładanie Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Wciśnij Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Teraz tablica partycji powinna wyglądać następująco:
</p>

<pre caption="Wyświetlanie podziału partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Partycji Boot</title>
<body>

<p>
Jesteśmy gotowi na założenie partycji boot. W tym celu skorzystaj z polecenia
<c>n</c> aby rozpocząć tworzenie, następnie wpisz <c>1</c> aby wybrać pierwszą
partycję. Zapytany o pierwszy cylinder wciśnij Enter, natomiast na pytanie 
o ostatni wpisz <c>+32M</c>, żeby nadać jej rozmiar <c>32MB</c>. Upewnij się,
że mieści się w całości w pierwszych 2GB dysku. Rezultaty powyższych
czynności prezentujemy w przykładzie:
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Wciśnij Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Po wpisaniu <c>p</c> powinieneś ujrzeć następujący listing podziału:
</p>

<pre caption="Schemat podziału partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Tworzenie Partycji Swap</title>
<body>

<p>
Stwórz teraz partycję wymiany. W tym celu skorzystaj z polecenia <c>n</c> aby
rozpocząć proces zakładania, następnie wpisz <c>2</c> aby wybrać drugą
partycję, w naszym przypadku <path>/dev/hda2</path>. Zapytany o pierwszy
cylinder wciśnij Enter, natomiast na pytanie o ostatni wpisz <c>+512M</c>
aby ustalić jej rozmiar na 512MB. Następnie wpisz <c>t</c> aby zmienić
typ partycji i wpisz <c>82</c> żeby ustawić go na "Linux Swap". Po ukończeniu
listing partycji powinien wyglądać następująco:
</p>

<pre caption="Listing partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Partycji Root</title>
<body>

<p>
W końcu, stwórzmy partycję root. W tym celu ponownie skorzystaj
z polecenia <c>n</c>, aby rozpocząć zakładanie. Następnie wpisz
<c>4</c>, żeby wybrać czwartą partycję - w naszym przypadku
<path>/dev/hda4</path>. Zapytany o pierwszy i ostatni cylinder wciśnij
Enter. Dzięki temu nasza partycja zajmie całą pozostałą przestrzeń.
Po ukończeniu, polecenie <c>p</c> powinno dać następujący rezultat:
</p>

<pre caption="Listing kompletnej tablicy partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Zachowywanie Zmian i Zamykanie fdisk</title>
<body>

<p>
Aby zachować zmiany i opuścić <c>fdisk</c> wpisz <c>w</c>:
</p>

<pre caption="Zapisywanie zmian i wychodzenie z fdisk">
Command (m for help): <i>w</i>
</pre>
<p>
Twoje partycje są już gotowe,
<!--, jeśli nie zdecydowałeś się skorzystać z LVM to  -->
możesz teraz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
<!--W przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>.-->
</p>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą mac-fdisk na PPC</title>
<body>

<p>
Aby stworzyć partycje skorzystamy z <c>mac-fdisk</c>:
</p>

<pre caption="Uruchamianie mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Zacznij od pozbycia się wybranych partycji, żeby zrobić miejsce
na nowy system. Skorzystaj w tym celu z polecenia <c>d</c>.
Zapyta ono o numer kasowanych partycji.
</p>

<p>
Następnie, załóż partycję <e>Apple_bootstrap</e> za pomocą <c>b</c>.
Zostaniez zapytany o początkowy blok. Jeśli poprzednio wybrałeś
na ten cel trzecią partycję, wpisz <c>3p</c>.
</p>

<p>
Teraz stwórz partycję wymiany za pomocą <c>c</c>. <c>mac-fdisk</c> ponownie
zapyta o blok początkowy. Jako, że wcześniej skorzystaliśmy z <c>3</c>,
teraz wpisz <c>4p</c>. Gdy zostaniesz zapytany o rozmiar, wpisz <c>512M</c>
(lub inny na jaki się zdefydowałeś -- 512 jest zalecany). Następnie
na pytanie o nazwę, wpisz <c>swap</c> (koniecznie).
</p>

<p>
Żeby założyć partycję root, wpisz <c>c</c>, następnie <c>5p</c> aby wybrać
blok, od którego ma się zaczynać. Na pytanie o rozmiar ponownie wpisz <c>5p</c>,
<c>mac-fdisk</c> zinterpretuje to jako życzenie zajęcia całej wolnej przestrzeni.
Koniecznie podaj nazwę <c>root</c>.
</p>

<p>
Na zakończenie, zachowaj zmiany i opuść <c>mac-fdisk</c> poleceniami <c>w</c>
oraz <c>q</c>.
i</p>

<p>
Teraz<!--, jeśli nie zdecydowałeś się skorzystać z LVM, -->
możesz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
<!-- przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>. -->
</p>


</body>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na HPPA</title>
<body>

<p>
Do przeprowadzenia podziału użyjemy <c>fdisk</c>:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO wymaga do pracy oddzielnej partycji. Musisz na nią przeznaczyć
przynajmniej 16MB na początku dysku. Powinna być typu <e>f0</e>
(Linux/PA-RISC boot).
</p>

<impo>
Jeśli nie utworzysz tej partycji, system przestanie Cię kochać i się nie uruchomi.
</impo>

<p>
Jeżeli Twój dysk ma ponad 2GB wielkości, upewnij się czy partycja boot znajduje się
w pierwszych 2GB. PALO nie może korzystać z dalszych obszarów.
</p>

<p>
Po utworzeniu partycji <!--jeśli nie zdecydowałeś się skorzystać z LVM, -->
możesz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
<!--W przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>.-->
</p>

</body>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na MIPS</title>
<!-- This entire section is copy/pasted from Kumba's original text. It should
     probably be rewritten, but it seems a bit complicated.
     Someone donate me a MIPS? :) 

       ~SwifT
-->
<subsection>
<title>Tworzenie SGI Disk Label</title>
<body>

<p>
Wszystkie dyski w SGI System wymagają <e>SGI Disk Label</e>, pełniącego
podobną funkcję jak etykiety Suna i MS-DOS -- przechowują informacje
o partycjach. Stworzenie nowego SGI Disk Label zaowocuje powstaniem
dwóch nowych partycji:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (partycja dziewiąta): Partycja ta jest bardzo ważna.
    Będą na niej przechowywane obrazy jądra. Do umieszczenia ich tam służy
    program <c>dvhtool</c>. Dzięki temu, będziesz mógł je uruchamiać za pomocą
    SGI PROM Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (partycja jedenasta): Partycja ta spełnia podobne funkcje
    do zajmującej cały dysk Sun Disklabel. Obejmuje ona całą dostępną przestrzeń
    i nie powinna być modyfikowana. Nie ma żadnego specjalnego zadania,
    poza pomaganiem PROMowi w jakichś nieudokumentowanych operacjach (lub
    używana jest w jakiś sposób przez IRIX).
  </li>
</ul>

<warn>
SGI Volume Header <e>musi</e> rozpoczynać się od cylindra 0. Nie zapewnienie tego
doprowadzi do niemożliwości uruchamiania z dysku.
</warn>

<p>
Następny przykład zaczerpnięto z sesji <c>fdisk</c>. Przeczytaj go
i zmodyfikuj stosownie do swoich potrzeb...
</p>

<pre caption="Zakładanie SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Jeśli na dysku znajduje się już SGI Disklabel, fdisk nie pozwoli na stworzenie
nowej. Są dwa sposoby, żeby to ominąć. Pierwszym jest stworzenie etykiety
SUN lub MS-DOS, zapisanie zmian i ponowne uruchomienie fdisk. Drugim jest
nadpisanie tablicy partycji następującym poleceniem:
<c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Nadawanie właściwego rozmiaru SGI Volume Header</title>
<body>

<p>
Gdy stworzysz SGI Disklabel, możesz przystąpić do definiowania partycji.
W powyższym przykładzie, dwie z nich zostały już przygotowane.
Pełnią one specjalne funkcje i nie mogą być wykorzystane w normalny sposób.
Jakkolwiek, instalując Gentoo musimy załadować obrazy jądra bezpośrednio
do nagłówka woluminu, gdyż nie ma w Portage wspieranego menadżera uruchamiania.
Nagłówek woluminu może przechowywać maksymalnie <e>osiem</e> kerneli o dowolnym
rozmiarze i ośmioznakowej nazwie.
</p>

<p>
Proces powiększania woluminu nagłowka nie jest prosty -- trzeba zrobić
kilka sztuczek. Nie można po prostu usunąć i dodać go ponownie, ze
względu na dziwne zachowanie fdisk. W poniższym przykładzie, utworzymy
50MB nagłówek woluminu oraz 50MB partycję boot. Rzeczywisty
podział twojego dysku może być inny, ale przykład służy tylko
zilustrowaniu czynności:
</p>

<pre caption="Prawidłowa zmiana rozmiaru Nagłówka Woluminu SGI">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Zauważ, że fdisk pozwala na stworzenie pierwszej partycji co najmniej od piątego cylindra</comment>
<comment>(Jeśli próbowałeś już usunąć i stworzyć ponownie Nagłówek Woluminu SGI tą metodą, napewno
spotkałeś się z takim zachowaniem)</comment>
<comment>(W naszym przykładzie chcemy aby /boot miało 50MB, więc zaczniemy od cylindra 51 (pamiętaj,
że Nagłówek Woluminu musi zaczynać się od cylindra 0) i zakończymy na cylindrze 101. Rozmiar tylko
nieznacznie będzie się różnił od oczekiwanego (+/- 1-5MB)</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Usuń partycję 9 (Nagłówek Woluminu SGI))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Ponownie stwórz partycję 9, kończącą się tuż przed partycją 1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Ostateczny Schemat Partycji</title>
<body>

<p>
Możesz teraz stworzyć resztę potrzebnych partycji. Upewnij się, że
ID partycji wymiany ustawiono na <c>82</c>, czyli Linux Swap, gdyż
domyślnie jest to <c>83</c>, Linux Native.
</p>

<p>
Następnie, gdy będą już gotowe, jeśli nie zdecydowałeś się skorzystać z LVM, to
możesz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
W przeciwnym przypadku przeczytaj najpierw <uri link="#lvm">Opcjonalnie: Używanie LVM</uri>.
</p>

</body>
</subsection>
</section>
<!-- TODO rewrite with LVM2 instructions when appropriate
<section id="lvm">
<title>Opcjonalnie: Używanie LVM</title>
<subsection>
<title>Inicjalizacja Partycji</title>
<body>
<p>
Aby skorzystać z LVM, najpierw musisz go aktywować i zainicjalizować stworzone
partycje. Służą do tego programy <c>vgscan</c> (aktywacja LVM) oraz <c>pvcreate</c>
(inicjalizacja partycji). W przykładzie założyliśmy, że
<path>/dev/hda1</path> jest zwykłą partycją boot, <path>/dev/hda2</path>
standardową (choć małą) partycją root a <path>/dev/hda3</path> dużą
partycją przeznaczoną dla LVM.
</p>

<pre caption="Aktywacja i inicjalizacja partycji dla LVM">
# <i>vgscan</i>
# <i>pvcreate /dev/hda3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Konfiguracja Grupy Woluminu</title>
<body>

<p>
Musimy teraz ustawić grupę woluminu. Posłużymy się w tym celu programem <c>vgcreate</c>.
Korzysta on z pełnych ścieżek do plików urządzeń (w stylu DevFS), więc
najpierw musimy sprawdzić gdzie potrzebne pliki są umieszczone:
</p>

<pre caption="Sprawdzanie pełnych ścieżek do urządzeń">
# <i>ls -l /dev/hda3</i>
lr-xr-xr-x    1 root     root           33 Oct 21  2003 /dev/hda3 -&gt; ide/host0/bus0/target0/lun0/part3
</pre>

<p>
Stwórzmy teraz grupę woluminu o nazwie "vg":
</p>

<pre caption="Zakładanie grupy VG">
# <i>vgcreate vg /dev/ide/host0/bus0/target0/lun0/part3</i>
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Woluminów Logicznych</title>
<body>

<p>
Stwórzymy teraz woluminy logiczne. W przykładzie oddzielimy
<path>usr/</path> (10GB), <path>home/</path> (5GB), <path>opt/</path> (2GB),
<path>tmp/</path> (2GB), <path>var/</path> (5GB) oraz swap (512MB).
</p>

<pre caption="Zakładanie woluminów logicznych">
# <i>lvcreate -L10G -nusr vg</i>
# <i>lvcreate -L5G -nhome vg</i>
# <i>lvcreate -L2G -nopt vg</i>
# <i>lvcreate -L2G -ntmp vg</i>
# <i>lvcreate -L5G -nvar vg</i>
# <i>lvcreate -L512M -nswap vg</i>
</pre>

<p>
Nasze woluminy są już używalne jak gdyby były zwyczajnymi partycjami:
</p>

<pre caption="Listing woluminów logicznych">
# <i>ls /dev/vg</i>
home     opt      swap     tmp     usr      var
</pre>

<p>
<e>Te</e> pliki są teraz Twoimi "partycjami" (woluminami logicznymi).
</p>

</body>
</subsection>
</section>
-->
<section id="filesystems">
<title>Tworzenie Systemów Plików</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Po stworzeniu partycji <!--(lub logicznych woluminów)--> nadszedł czas na
założenie na nich systemów plików. Jeśli nie obchodzi Cię
jakie wybierzesz i jesteś zadowolony z domyślnych ustawień w podręczniku,
przejdź do
<uri link="#filesystems-apply">Zakładania na Partycji Systemu Plików</uri>.
W przeciwnym wypadku czytaj dalej aby dowiedzieć się co nieco na ich temat.
</p>

</body>
</subsection>
<subsection>
<title>Systemy Plików?</title>
<body>

<p>
Dostępne są różne systemy plików. Część z nich działa stabilnie
na wszystkich platformach, część tylko na niektórych. Poniższa tabela
prezentuje te, które są dostępne i na jakich architekturach działają.
Jeśli architektura oznaczona jest przez "(...)" to znaczy, iż
system plików powinien działać, ale nie został dostatecznie przetestowany.
</p>

<table>
<tr>
  <th>System Plików</th>
  <th>Dziennik</th>
  <th>Architektury</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>nie</ti>
  <ti>Wszystkie architektury</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>tak</ti>
  <ti>Wszystkie architektury</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>tak</ti>
  <ti>x86, hppa, alpha, (mips), (ppc), (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>tak</ti>
  <ti>x86, alpha, amd64, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>tak</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików, ale nie posiada
księgowania. Powoduje to, iż jego regularne kontrole przy starcie systemu
bywają długotrwałe. Obecnie istnieją nowoczesne systemy plików z księgowaniem,
mogące być szybko sprawdzane i są zasadniczo zalecane. Księgowanie
zapobiega długotrwałym kontrolom podczas uruchamiania i ewentualnym
błędom spójności danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach
full oraz ordered, dzięki czemu w razie awarii dane odzyskiwane są
błyskawicznie. Jest on bardzo dobrym i niezawodnym rozwiązaniem.
Oferuje przyzwoitą wydajność w większości przypadków. Ponieważ
wewnętrznie nie wykorzystuje zbyt często tzw. "drzew" jest mało skalowany.
Oznacza to, iż nie nadaje się na bardzo duże partycje oraz do przechowywania
ogromnych plików lub bardzo wielu plików w jednym katalogu. Mimo to,
w typowych zadaniach jest świetny.
</p>

<p>
<b>ReiserFS</b> to system plików oparty na drzewie B*, oferujący
dużą wydajność. Przy wielu małych plikach (poniżej 4k) może
być szybszy od ext3 nawet piętnastokrotnie. ReiserFS jest
wysoce skalowalny i posiada księgowanie. Począwszy od jąder 2.4.18,
jest super-niezawodny i wysoce zalecany nie tylko na przeciętnych systemach plików,
ale nawet na ogromnych partycjach, w pracy z wieloma bardzo małymi i bardzo dużymi plikami
oraz katalogami zawierającymi ich tysiące.

is a B*-tree based filesystem that has very good overall 
performance and greatly outperforms both ext2 and ext3 when dealing with small 
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales 
extremely well and has metadata journaling. As of kernel 2.4.18+, ReiserFS is 
now rock-solid and highly recommended for use both as a general-purpose 
filesystem and for extreme cases such as the creation of large filesystems, the 
use of many small files, very large files and directories containing tens of 
thousands of files. 
</p>

<p>
<b>XFS</b> to system plików z księgowaniem, w pełni wspierany
w Gentoo Linux przez jądro xfs-sources. Jest bardzo funkcjonalny i zoptymalizowany
do skalowalności. Zalecamy go wyłącznie do systemów z nowoczesnymi dyskami SCSI
i/lub ciągłego zapisu danych z nieprzerwanym dostępem zasilania. Ponieważ
XFS przechowuje dużo danych w pamięci RAM, źle zaprojektowane programy
(te nie zachowujące odpowiednich środków ostrożności podczas zapisywania plików
na dysk, których niestety jest sporo) mogą doprowadzić w razie padu
systemu do utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików z księgowaniem IBMa.
Dopiero niedawno został uznany za stabilny i nie ma na swoim
koncie dostatecznych osiągnięć aby można było mówić
źle lub dobrze o jego stabilności.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie na Partycji Systemu Plików</title>
<body>

<p>
Aby założyć na woluminie lub partycji system plików, możesz skorzystać z dostępnych
dla każdego narzędzi:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Program do zakładania</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć ext2 na partycji boot (w naszym przypadku <path>/dev/hda1</path>)
oraz ext3 na partycji root (w naszym przypadku <path>/dev/hda3</path>), powinieneś
wykonać następujące polecenia:
</p>

<pre caption="Zakładanie na partycji systemu plików">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Stwórz teraz systemy plików na swoich partycjach (lub woluminach logicznych).
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja Partycji Swap</title>
<body>

<p>
Aby zainicjalizować partycje wymiany, skorzystaj z programu <c>mkswap</c>.
</p>

<pre caption="Inicjalizacja partycji wymiany">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Aby je aktywować skorzystaj ze <c>swapon</c>:
</p>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Teraz Twoja kolej na inicjalizację i aktywację.
</p>

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu systemów plików, nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Nie zapomnij utworzyć
odpowiednich katalogów:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Jeżeli chcesz przenieść <path>/tmp</path> na oddzielną partycję,
nie zapomnij po zamontowaniu odpowiedni poprawić praw dostępu: <c>chmod
1777 /mnt/gentoo/tmp</c>. Dotyczy to również <path>/var/tmp</path>.
</note>

<p>
Musimy też zamontować system plików proc (wirtualny interfejs jądra)
w <path>/proc</path>. Zacznijmy od utworzenia odpowiedniego katalogu
(<path>/mnt/gentoo/proc</path>):
</p>

<pre caption="Tworzenie punktu montowania /mnt/gentoo/proc">
# <i>mkdir /mnt/gentoo/proc</i>
</pre>

<p>
Jeśli korzystasz z LiveCD, możesz go po prostu zamontować:
</p>

<pre caption="Montowanie proc">
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Jeżeli nie, skorzystaj z opcji bind:
</p>

<pre caption="Bind-montowanie proc">
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
</pre>

<p>
Przejdź teraz do <uri link="?part=1&amp;chap=5">Instalacji Plików
Instalacyjnych Gentoo</uri>.
</p>

</body>
</section>
</sections>
