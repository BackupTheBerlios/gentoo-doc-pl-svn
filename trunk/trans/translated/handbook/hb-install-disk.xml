<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Orig revision: 1.44 -->
<!-- Translator: lucass <lucass@gentoo.pl> -->
<!-- Title: Przygotowanie Dysków -->
<!-- Status: Ukończono -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->


<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/handbook/Attic/hb-install-disk.xml,v 1.28 2004/12/04 20:24:59 rane Exp $ -->

<sections>
<section>
<title>Wprowadzenie do urządzeń blokowych.</title>
<subsection>
<title>Urządzenia blokowe</title>
<body>

<p>
Rzućmy okiem na aspekty Gentoo Linux, oraz ogólnie Linuksa, związane z dyskami.
Omówimy systemy plików, partycje oraz urządzenia blokowe. Następnie
przeprowadzimy Cię przez proces podziału twardego dysku, aby jak najlepiej
wykorzystać dostępną przestrzeń.
</p>

<p>
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path>, reprezentujący w Linuksie pierwszy 
napęd IDE. Jeśli posiadasz urządzenia SCSI, pierwszym takim
dyskiem jest <path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy
użytkownika mogą z nich korzystać nie martwiąc się czy napędy
są typu IDE, SCSI lub jeszcze inne. Przechowywane dane adresuje się
za jako ciąg 512-bajtowych bloków.
</p>

</body>
</subsection>
<subsection>
<title>Partycje i plastry.</title>
<body>

<p>
Jakkolwiek teoretycznie możliwe jest przeznaczenie na system całego dysku,
zazwyczaj nie jest to rozwiązanie praktyczne. Zamiast tego dzielimy
napęd na mniejsze i łatwiejsze w zarządzaniu urządzenia blokowe.
W większości platform nazywane są one <e>partycjami</e>. Część architektur,
korzystająca z podobnych technik nazywa je <e>plastrami</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partycje.</title>
<body>

<note>
To (teoretyczne) wyjaśnienie dotyczy jedynie architektury x86.
</note>

<p>
Wyróżniamy trzy rodzaje partycji: <e>podstawowe</e>,
<e>rozszerzone</e> oraz <e>logiczne</e>.
</p>

<p>
Informacje o partycjach <e>podstawowych</e> przechowywane są w MBR
(master boot record). Ponieważ jest on bardzo mały (512 bajtów), mieszczą 
się w nim dane najwyżej czterech takich partycji (na przykład,
od <path>/dev/hda1</path> do <path>/dev/hda4</path>).
</p>

<p>
Specjalną odmianą partycji podstawowych są partycje <e>rozszerzone</e>
(oznacza to, że również obowiązuje je powyższy limit). Przechowują
one kolejne partycje. W ten sposób można ominąć niewygodną granicę
i lepiej zagospodarować przestrzeń dyskową bez utraty kompatybilności
wstecz.
</p>

<p>
Partycje umieszczone i opisane wewnątrz rozszerzonych nazywamy <e>logicznymi</e>.
</p>

</body>
</subsection>
<subsection>
<title>Zaawansowane metody przechowywania danych.</title>
<body>

<p>
Niektóre architektury (w tym x86) posiadają wsparcie 
dla EVMS oraz LVM2 o ile korzystasz z Gentoo LiveCD.
Dzięki nim masz możliwość zwiększenia elastyczności swojego
podziału dysku. W dalszej części podręcznika skupimy 
się na tradycyjnych partycjach, jednak dobrze jest 
wiedzieć o obsłudze także nowocześniejszych rozwiązań.
</p>

</body>
</subsection>
</section>
<section>
<title>Projektowanie schematu podziału.</title>
<subsection>
<title>Domyślny schemat podziału.</title>
<body>

<p>
Jeśli nie masz ochoty samodzielnie rozrysowywać schematu podziału
swojego dysku, możesz skorzystać z domyślnego (nie dotyczy LVM), którego
użyjemy w podręczniku:
</p>

<p>
Dla x86 lub amd64:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Dla ppc:
</p>

<table>
<tr>
  <th>Partycja NewWorld</th>
  <th>Partycja OldWorld</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>(Nie wymagana)</ti>
  <ti>(bootstrap)</ti>
  <ti>800k</ti>
  <ti>Apple_Bootstrap</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti><path>/dev/hda1</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti><path>/dev/hda2</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Dla Sparc:
</p>

<table>
<tr>
  <th>Sun Disklabel</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>(none)</ti>
  <ti>Cały dysk</ti>
  <ti>Sun Disk Label (wymagana)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dysku</ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Użytkownicy instalujący Gentoo Linux z innej dystrybucji Linuksa powinni
najpierw zmniejszyć istniejące partycje (oczywiście o ile nie pozostawili
w zapasie wolnej przestrzeni) aby zdobyć miejsce na nowy system. W tym
celu mogą skorzystać z wygodnego narzędzia <uri 
link="http://www.gnu.org/software/parted">GNU/Parted</uri>.
</p>

<p>
Jeśli interesują Cię nasze rady dotyczące rozmiarów partycji
(lub woluminów logicznych) oraz ich ilości, czytaj dalej.
W przeciwnym wypadku przejdź od razu do podziału dysku:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Partycjonowanie dysku za pomocą fdisk na x86 lub amd64</uri>.
</li>
<li>
  <uri link="#doc_chap4">Partycjonowanie dysku za pomocą fdisk na Alpha</uri>.
</li>
<li>
  <uri link="#doc_chap5">Partycjonowanie dysku za pomocą fdisk na SPARC</uri>.
</li>
<li>
  <uri link="#doc_chap6">Partycjonowanie dysku za pomocą mac-fdisk na PPC</uri>
</li>
<li>
  <uri link="#doc_chap7">Partycjonowanie dysku za pomocą fdisk na HPPA</uri>.
</li>
<li>
  <uri link="#doc_chap8">Partycjonowanie dysku za pomocą fdisk na MIPS</uri>.
</li>
</ul>

</body>
</subsection>
<subsection>
<title>Jak dużo jak wielkich?</title>
<body>

<p>
lość partycji ściśle zależy od środowiska. Na przykład, jeśli administrujesz
systemem mającym wielu użytkowników, prawdopodobnie uznasz za stosowne
oddzielenie <path>/home</path> aby poprawić bezpieczeństwo i uprościć tworzenie
kopii zapasowych. Jeżeli docelowym zastosowaniem świeżego Gentoo jest serwer
poczty, na osobnej  partycji powinieneś umieścić <path>/var</path>, gdzie
przechowywane są listy. Dobry wybór systemu plików może tu znacznie zwiększyć
wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem na serwerach
gier, gdyż większość używanego oprogramowania zostanie tam zainstalowana. Powód
jest podobny jak w przypadku <path>/home</path>: bezpieczeństwo i kopie zapasowe.
</p>

<p>
Jak widzisz, wiele zależy od oczekiwanego rezultatu. Wydzielenie partycji
lub woluminów ma wiele zalet:
</p>

<ul>
<li>
  Masz możliwość dostosowania jak najwydajniejszego w danym zastosowaniu
  systemu plików dla poszczególnych partycji lub woluminów.
</li>
<li>
  W przypadku zapełnienia partycji przez nieprawidłowo działające
  narzędzie, nie ma to wpływu na całość systemu.
</li>
<li>
  Jeśli to konieczne, można skrócić czas kontroli systemów plików, gdyż
  można jednocześnie dokonywać jej na kilku partycjach (ma to znaczenie
  zwłaszcza na sprzęcie z wieloma dyskami).
</li>
<li>
  Montując część partycji lub woluminów z opcjami read-only (tylko do odczytu),
  nosuid (ignorowane są bity setuid), noexec (ignorowane są bity wykonywalności) itd.
  można znacznie poprawić bezpieczeństwo.
</li>
</ul>

<p>
Niestety zbyt rozbudowany podział niesie ze sobą spore niebezpieczeństwo: źle
zaplanowany zaowocuje pustkami na zbyt dużych i ciasnotą na zbyt małych
partycjach.
</p>

<p>
W przykładzie pokażemy partycjonowanie dysku 20GB, wykorzystywanego
w pokazowym laptopie z zainstalowanymi serwerami poczty oraz WWW,
GNOME, itd.:
</p>

<pre caption="Przykładowy podział dysku">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Zostało nam 2GB niespartycjonowanej przestrzeni, którą będziemy mogli wykorzystać w przyszłości</comment>
</pre>

<p>
<path>/usr</path> jest niemal w pełni zajęty (wykorzystane 83%),
ale po instalacji wszystkich potrzebnych pakietów nie będzie się
on zbytnio rozrastał. Część czytelników może pomyśleć, iż
zbyt wiele miejsca przeznaczyliśmy na <path>/var</path>. 
Należy zwrócić uwagę, że Gentoo kompiluje wszystkie pakiety
wewnątrz <path>/var/tmp/portage</path>. Powinien mieć
wobec tego przynajmniej 1GB wolnej przestrzeni, jeśli nie zamierzasz
kompilować większych programów, lub nawet 3GB - gdy chcesz móc jednocześnie
kompilować KDE i OpenOffice.org..
</p>

<p>
Podziel teraz swój dysk, korzystając z instrukcji dla danej architektury:
</p>

<ul>
<li>
  <uri link="#doc_chap3">Partycjonowanie dysku za pomocą fdisk na x86 lub
  amd64.</uri>
</li>
<li>
  <uri link="#doc_chap4">Partycjonowanie dysku za pomocą fdisk na Alpha.</uri>
</li>
<li>
  <uri link="#doc_chap5">Partycjonowanie dysku za pomocą fdisk na SPARC.</uri>
</li>
<li>
  <uri link="#doc_chap6">Partycjonowanie dysku za pomocą mac-fdisk na PPC.</uri>
</li>
<li>
  <uri link="#doc_chap7">Partycjonowanie dysku za pomocą fdisk na HPPA.</uri>
</li>
<li>
  <uri link="#doc_chap8">Partycjonowanie dysku za pomocą fdisk na MIPS.</uri>
</li>
</ul>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie dysku za pomocą fdisk na x86 lub amd64.</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektur <e>x86</e>
i <e>amd64</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>

</body>
</subsection>
<subsection>
<title>Wyświetlanie aktualnego podziału dysku.</title>
<body>

<p>
<c>fdisk</c> to popularne i wygodne narzędzie służące do partycjonowania.
Uruchom go dla swojego dysku (pokażemy to na przykładzie <path>/dev/hda</path>):
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Twoim oczom ukaże się mniej więcej taki znak zachęty:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help): 
</pre>

<p>
Aby wyświetlić obecną konfigurację partycji, wpisz <c>p</c>:
</p>

<pre caption="Przykładowa konfiguracja partycji">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Na prezentowanym w przykładzie dysku znajduje się siedem linuksowych systemów plików
(każdy na odpowiedniej partycji, oznaczonej jako "Linux") oraz partycja
wymiany (oznaczona jako "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Kasowanie wszystkich partycji</title>
<body>

<p>
Zacznijmy od usunięcia partycji. Służy do tego polecenie <c>d</c> z odpowiednim parametrem.
Na przykład, aby pozbyć się <path>/dev/hda1</path>:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Nasza partycja została zaznaczona do usunięcia. Nie będzie więcej pojawiać się
po wydaniu polecenia <c>p</c>, ale dopóki zmiany nie zostaną zapisane
fizycznie, pozostanie nienaruszona. Jeśli popełnisz błąd i zechcesz
anulować wprowadzone zmiany, naciśnij <c>q</c> i wciśnij Enter.
Twoje modyfikacje pójdą w niepamięć.
</p>

<p>
Zakładając, że chcesz pozbyć się wszystkich istniejących partycji,
na przemian wykonuj <c>p</c>, aby wyświetlić ich listing i
po kolei kasuj je poleceniem <c>d</c> z odpowiednim numerem. Po ukończeniu,
<c>p</c> powinno dać następujący rezultat:
</p>

<pre caption="Pusta tablica partycji">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Kiedy nasza tymczasowa tablica partycji będzie pusta, możemy rozpocząć
tworzenie nowego podziału. Pokażemy to na przykładzie domyślnego omawianego
schematu. Oczywiście jeśli Ci on nie odpowiada, i chcesz zastosować inny
schemat powinieneś poczynić stosowne modyfikacje prezentowanych poleceń.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji boot.</title>
<body>

<p>
Rozpoczniemy od utworzenia niewielkiej partycji boot. Wpisz <c>n</c>, aby
ją założyć, następnie <c>p</c>, aby nadać jej typ podstawowy i <c>1</c>,
ponieważ będzie to pierwsza taka partycja. Zapytany o pierwszy cylinder
wciśnij Enter, natomiast zapytany o ostatni, wpisz <c>+32M</c>, żeby nadać
jej rozmiar 32MB.
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Wciśnij Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Teraz polecenie <c>p</c> powinno pokazać następujący listing:
</p>

<pre caption="Utworzona partycja boot" >
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Musimy oznaczyć naszą partycję jako uruchamialną. W tym celu skorzystamy
z polecenia <c>a</c>. Na kolejnych wydrukach podziału, w kolumnie
"Boot" pokazywać się będzie <path>*</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji wymiany.</title>
<body>

<p>
Pora na utworzenie partycji wymiany. Ponownie skorzystaj z polecenia
<c>n</c>, następnie podaj <c>p</c>, bo powinna to być partycja podstawowa i <c>2</c>,
ponieważ będzie ona drugą tego typu. Zapytany o pierwszy cylinder wciśnij Enter,
natomiast na pytanie o ostatni wpisz <c>+512M</c>, co nada partycji
rozmiar 512MB. Następnie wpisz <c>t</c>, aby zmienić typ partycji,
<c>2</c>, aby wybrać tę, którą właśnie stworzyłeś i <c>82</c>, żeby oznaczyć
ją jako "Linux Swap". Teraz polecenie <c>p</c> powinno dać następujący
listing:
</p>

<pre caption="Listing podziału po utworzeniu partycji wymiany">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Zakładanie partycji root.</title>
<body>

<p>
Na koniec utworzymy partycję root. Jeszcze raz posłużymy się w tym celu poleceniem
<c>n</c>. Zapytani o rodzaj wpiszemy <c>p</c>, ponieważ chcemy by była podstawowa,
następnie <c>3</c>, gdyż będzie już trzecią tego typu, czyli w naszym przypadku
<path>/dev/hda3</path>. Na pytanie o pierwszy i ostatni cylinder wciskamy
Enter, bo dzięki temu zajmie ona całą pozostałą wolną przestrzeń. Teraz polecenie
<c>p</c> powinno pokazać następujący wydruk:
</p>

<pre caption="Listing podziału po utworzeniu partycji root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Zapisywanie podziału partycji.</title>
<body>

<p>
Aby zachować ustalony podział i opuścić <c>fdisk</c>, wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoje partycje są już gotowe, możesz teraz przejść do paragrafu <uri 
link="#filesystems">Zakładanie systemów plików</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie dysku za pomocą fdisk na Alpha.</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektury <e>Alpha</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie (nie dotyczy LVM):
</p>

<table>
<tr>
  <th>Plaster</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/sdaa</path></ti>
  <ti>Plaster swap</ti>
</tr>
<tr>
  <ti><path>/dev/sdab</path></ti>
  <ti>Plaster root</ti>
</tr>
<tr>
  <ti><path>/dev/sdac</path></ti>
  <ti>Cały dysk (wymagane)</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>


</body>
</subsection>
<subsection>
<title>Sprawdzanie dostępnych dysków.</title>
<body>

<p>
Aby rozejrzeć się w dostępnych dyskach, skorzystaj z następujących poleceń:
</p>

<pre caption="Sprawdzanie dostępnych dysków">
<comment>(Dla dysków IDE)</comment>      # <i>dmesg | grep 'drive$'</i>
<comment>(Dla dysków SCSI)</comment>     # <i>dmesg | grep 'scsi'</i>
</pre>

<p>
Na podstawie rezultatu powinieneś wywnioskować, które dyski zostały
wykryte i jakie urządzenia w <path>/dev</path> je reprezentują. W kolejnych
podsekcjach zakładamy, iż korzystasz z pierwszego dysku SCSI (<path>/dev/sda</path>).
</p>

<p>
Uruchom teraz <c>fdisk</c>:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Usuwanie wszystkich plastrów.</title>
<body>

<p>
Zaczniemy od pozbycia się wszystkich plastrów, <e>z wyjątkiem</e> plastra 'c'.
Pokażemy jak to zrobić na przykładzie 'a'. Powtórz ten proces aby
usunąć również pozostałe plastry (oczywiście oprócz 'c').
</p>

<p>
Aby wyświetlić aktualny podział skorzystaj z polecenia <c>p</c>. Do usuwania
służy <c>d</c>.
</p>

<pre caption="Usuwanie plastra">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Po powtórzeniu powyższego procesu dla wszystkich plastrów, listing powinien
przedstawiać się następująco:
</p>

<pre caption="Wyświetlanie pustego schematu">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie plastra wymiany.</title>
<body>

<p>
W komputerach Alpha nie ma konieczności tworzenia partycji boot. 
Za to pierwszy cylinder zostanie zajęty obrazem <c>aboot</c>.
</p>

<p>
Utworzymy teraz plaster swap zaczynający się od trzeciego cylindra i mający rozmiar
1GB. W tym celu skorzystamy z polecenia <c>n</c>. Następnie
zmienimy typ plastra na <c>1</c>, czyli <e>swap</e>.
</p>

<pre caption="Zakładanie plastra swap">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Teraz listing podziału powinien wyglądać podobnie:
</p>

<pre caption="Listing podziału po założeniu plastra swap">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie plastra root.</title>
<body>

<p>
Nadszedł czas na utworzenie plastra root. Powinien on zaczynać się
od pierwszego cylindra <e>po</e> plastrze swap. Aby zobaczyć gdzie kończy
się ów plaster skorzystaj z polecenia <c>p</c>. W naszym przykładzie
jest to 1003, a więc początkiem plastra root będzie cylinder 1004.
</p>

<p>
Obecnie w programie <c>fdisk</c> znajduje się błąd, powodujący, że
liczba dostępnych cylindrów jest o jeden większa od faktycznej.
Innymi słowy, zapytany o ostatni cylinder, podaj numer (w naszym przykładzie
5290) zmniejszony o jeden.
</p>

<p>
Po założeniu partycji, zmień jej typ na <c>8</c>, czyli <e>ext2</e>.
</p>

<pre caption="Zakładanie plastra root">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Teraz schemat podziału powinien wyglądać następująco:
</p>

<pre caption="Wyświetlanie listingu podziału">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Zapisanie podziału plastrów i zamknięcie fdisk.</title>
<body>

<p>
Aby zapisać zmiany i opuścić <c>fdisk</c> wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoje plastry są już gotowe, możesz teraz przejść do paragrafu <uri 
link="#filesystems">Zakładanie systemów plików</uri>.
</p>


</body>
</subsection>
</section>
<section>
<title>Partycjonowanie dysku za pomocą fdisk na SPARC.</title>
<subsection>
<body>

<impo>
Sekcja ta przeznaczona jest wyłącznie dla użytkowników architektury <e>SPARC</e>.
</impo>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie (nie dotyczy LVM):
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Sun Disk Label (wymagany)</ti>
</tr>
<tr>
  <ti><path>/dev/hda4</path></ti>
  <ti>Partycja root</ti>
</tr>
</table>

<p>
Zmodyfikuj go stosownie do swoich potrzeb.
</p>


</body>
</subsection>
<subsection>
<title>Uruchamianie fdisk.</title>
<body>

<p>
Uruchom <c>fdisk</c> dla swojego dysku:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Twoim oczom ukaże się jego znak zachęty:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help):
</pre>

<p>
Aby wyświetlić dostępne partycje, wpisz <c>p</c>:
</p>

<pre caption="Wyświetlanie dostępnych partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole Disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

<p>
Zwróć uwagę na <c>Sun Disk Label</c>. Jeśli go brakuje, oznacza to że 
dysk korzysta z partycji DOS. W takim razie, aby stworzyć
tablicę partycji Sun, wpisz <c>s</c>.
</p>

</body>
</subsection>
<subsection>
<title>Usuwanie istniejących partycji</title>
<body>

<p>
Nadszedł czas na pozbycie się istniejących partycji. Do usuwania
służy polecenie <c>d</c>. Wpisz je i naciśnij Enter. Zostaniesz zapytany
o numer partycji. Jeśli ma to być <path>/dev/hda1</path>, wpisz:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Aby skasować wszystkie istniejące partycje, na przemian wpisuj <c>p</c>
aby zobaczyć jakie są dostępne i <c>d</c>, żeby je kasoawć.
Jeśli popełnisz błąd wpisz <c>q</c> - <c>fdisk</c>, zmiany nie zostaną zapisane
i możesz je w ten sposób anulować. Do zachowywania zmian służy polecenie <c>w</c>.
</p>

<p>
Po usunięciu wszystkich partycji, listing podziału powinien wyglądać podobnie:
</p>

<pre caption="Pusty listing podziału">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
</pre>


</body>
</subsection>
<subsection>
<title>Tworzenie Sun Disk Label.</title>
<body>

<p>
Kiedy pozbędziesz się wszystkich partycji, możesz utworzyć Sun Disk Label.
W tym celu wpisz <c>n</c> aby rozpocząć zakładanie, następnie <c>3</c>
aby wybrać trzecią partycję. Zarówno zapytany o pierwszy jak i ostatni
cylinder wciśnij Enter. Następnie wpisz <c>t</c> aby zmodyfikować
typ partycji i <c>5</c> aby ustawić go na "Whole disk".
</p>

<pre caption="Zakładanie Sun Disk Label">
Command (m for help): <i>n</i>
Partition number (1-4): <i>3</i>
First cylinder (1-3876, default 0): <i>0</i>
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <comment>(Wciśnij Enter)</comment>
Using default value 3876

Command (m for help): <i>t</i>
Partition number (1-8): <i>3</i>
Hex code (type L to list codes): <i>5</i>
</pre>

<p>
Teraz tablica partycji powinna wyglądać następująco:
</p>

<pre caption="Wyświetlanie podziału partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk lable): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie partycji boot.</title>
<body>

<p>
Teraz jesteś już gotów do założenia partycji boot. W tym celu skorzystaj z polecenia
<c>n</c> aby rozpocząć tworzenie, następnie wpisz <c>1</c> aby wybrać pierwszą
partycję. Zapytany o pierwszy cylinder wciśnij Enter, natomiast na pytanie 
o ostatni wpisz <c>+32M</c>, żeby nadać jej rozmiar <c>32MB</c>. Upewnij się,
że mieści się w całości w pierwszych 2GB dysku. Rezultaty powyższych
czynności prezentujemy w przykładzie:
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Wciśnij Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Po wpisaniu <c>p</c> powinieneś ujrzeć następujący listing podziału:
</p>

<pre caption="Schemat podziału partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>
</body>
</subsection>
<subsection>
<title>Tworzenie partycji wymiany.</title>
<body>

<p>
Stwórz teraz partycję wymiany. W tym celu skorzystaj z polecenia <c>n</c> aby
rozpocząć proces zakładania, następnie wpisz <c>2</c> aby wybrać drugą
partycję, w naszym przypadku <path>/dev/hda2</path>. Zapytany o pierwszy
cylinder wciśnij Enter, natomiast na pytanie o ostatni wpisz <c>+512M</c>
aby ustalić jej rozmiar na 512MB. Następnie wpisz <c>t</c> aby zmienić
typ partycji i wpisz <c>82</c> żeby ustawić go na "Linux Swap". Po ukończeniu
listing partycji powinien wyglądać następująco:
</p>

<pre caption="Listing partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Partycji root.</title>
<body>

<p>
W końcu stwórzmy partycję root. W tym celu ponownie skorzystaj
z polecenia <c>n</c>. Następnie wpisz <c>4</c>, żeby wybrać czwartą
partycję - w naszym przypadku <path>/dev/hda4</path>. Zapytany o 
pierwszy i ostatni cylinder wciśnij Enter. Dzięki temu nasza 
partycja zajmie całą pozostałą przestrzeń. Po ukończeniu, 
polecenie <c>p</c> powinno dać następujący rezultat:
</p>

<pre caption="Listing kompletnej tablicy partycji">
Command (m for help): <i>p</i>

Disk /dev/hda (Sun disk label): 240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 bytes

Device Flag    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3             0      3876  29302528    5  Whole disk
/dev/hda4            82      3876  28690200   83  Linux
</pre>

</body>
</subsection>
<subsection>
<title>Zachowanie zmian i zamknięcie fdisk.</title>
<body>

<p>
Aby zachować zmiany i opuścić <c>fdisk</c> wpisz <c>w</c>:
</p>

<pre caption="Zapisywanie zmian i wychodzenie z fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoje partycje są już gotowe,
możesz teraz przejść do <uri link="#filesystems">Zakładania Systemów Plików</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Partycjonowanie dysku za pomocą mac-fdisk na PPC</title>
<body>

<p>
Aby stworzyć partycje skorzystamy z <c>mac-fdisk</c>:
</p>

<pre caption="Uruchamianie mac-fdisk">
# <i>mac-fdisk /dev/hda</i>
</pre>

<p>
Zacznij od pozbycia się wybranych partycji, żeby zrobić miejsce
na nowy system. Skorzystaj w tym celu z polecenia <c>d</c>.
Zapyta ono o numer kasowanych partycji.
</p>

<p>
Następnie, załóż partycję <e>Apple_bootstrap</e> za pomocą <c>b</c>.
Zostaniesz zapytany o początkowy blok. Jeśli poprzednio wybrałeś
na ten cel trzecią partycję, wpisz <c>3p</c>.
</p>

<note>
To <e>nie</e> jest partycja "boot". Nie jest nawet używana
przez Linuksa; nie potrzebujesz na niej miejsca do założenia
systemu plików, nie powinieneś jej nawet montować. Użytkownicy
PPC nie potrzebują partycji boot.
</note>

<p>
Teraz stwórz partycję wymiany za pomocą <c>c</c>. <c>mac-fdisk</c> ponownie
zapyta o blok początkowy. Jako, że wcześniej skorzystaliśmy z <c>3</c>,
teraz wpiszemy <c>4p</c>. Gdy zostaniesz zapytany o rozmiar, wpisz <c>512M</c>
(lub inny na jaki się zdecydowałeś - 512 to zalecane minimum). Następnie
na pytanie o nazwę, wpisz <c>swap</c> (koniecznie).
</p>

<p>
Żeby założyć partycję root, wpisz <c>c</c>, a następnie <c>5p</c>, aby wybrać
blok, od którego ma się zaczynać. Na pytanie o rozmiar ponownie wpisz <c>5p</c>,
<c>mac-fdisk</c> zinterpretuje to jako życzenie zajęcia całej wolnej przestrzeni.
Koniecznie podaj nazwę <c>root</c>.
</p>

<p>
Na zakończenie, zachowaj zmiany i opuść <c>mac-fdisk</c> poleceniami <c>w</c> oraz <c>q</c>.
i</p>

<p>
Teraz możesz przejść do paragrafu<uri link="#filesystems">Zakładanie systemów plików</uri>.
</p>


</body>
</section>
<section>
<title>Partycjonowanie dysku za pomocą fdisk na HPPA</title>
<body>

<p>
Do przeprowadzenia podziału użyjemy <c>fdisk</c>:
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/sda</i>
</pre>

<p>
PALO wymaga do pracy oddzielnej partycji. Musisz na nią przeznaczyć
przynajmniej 16MB na początku dysku. Powinna być typu <e>f0</e>
(Linux/PA-RISC boot).
</p>

<impo>
Jeśli nie utworzysz tej partycji, system przestanie Cię kochać i się nie uruchomi.
</impo>

<p>
Jeżeli Twój dysk ma ponad 2GB wielkości, upewnij się, że partycja boot znajduje się
w jego pierwszych 2GB. PALO nie może korzystać z dalszych obszarów.
</p>

<p>
Po utworzeniu partycji możesz przejść do paragrafu<uri 
link="#filesystems">Zakładanie systemów plików</uri>.
</p>

</body>
</section>
<section>
<title>Partycjonowanie Dysku za pomocą fdisk na MIPS.</title>
<subsection>
<title>Tworzenie SGI Disk Label.</title>
<body>

<p>
Wszystkie dyski w SGI System wymagają <e>SGI Disk Label</e>, pełniącego
podobną funkcję jak etykiety Suna i MS-DOS -- przechowują informacje
o partycjach. Stworzenie nowego SGI Disk Label zaowocuje powstaniem
dwóch nowych partycji:
</p>

<ul>
  <li>
    <e>SGI Volume Header</e> (partycja dziewiąta): Partycja ta jest bardzo ważna.
    Będą na niej przechowywane obrazy jądra. Do umieszczenia ich tam służy
    program <c>dvhtool</c>. Dzięki temu, będziesz mógł je uruchamiać za pomocą
    SGI PROM Monitor.
  </li>
  <li>
    <e>SGI Volume</e> (partycja jedenasta): Partycja ta spełnia podobne funkcje
    do zajmującej cały dysk Sun Disklabel. Obejmuje ona całą dostępną przestrzeń
    i nie powinna być modyfikowana. Nie ma żadnego specjalnego zadania,
    poza pomaganiem PROMowi w jakichś nieudokumentowanych operacjach (lub
    używana jest w jakiś sposób przez IRIX).
  </li>
</ul>

<warn>
SGI Volume Header <e>musi</e> rozpoczynać się od cylindra 0. Jeśli zrobisz
inaczej system nie uruchomi się z tego dysku.
</warn>

<p>
Następny przykład zaczerpnięto z sesji <c>fdisk</c>. Przeczytaj go
i zmodyfikuj stosownie do swoich potrzeb...
</p>

<pre caption="Zakładanie SGI Disklabel">
# <i>fdisk /dev/sda</i>

Command (m for help): <i>x</i>

Expert command (m for help): <i>m</i>
Command action
   b   move beginning of data in a partition
   c   change number of cylinders
   d   print the raw data in the partition table
   e   list extended partitions
   f   fix partition order
   g   create an IRIX (SGI) partition table
   h   change number of heads
   m   print this menu
   p   print the partition table
   q   quit without saving changes
   r   return to main menu
   s   change number of sectors/track
   v   verify the partition table
   w   write table to disk and exit

Expert command (m for help): <i>g</i>
Building a new SGI disklabel. Changes will remain in memory only,
until you decide to write them. After that, of course, the previous
content will be unrecoverably lost.

Expert command (m for help): <i>r</i>

Command (m for help): <i>p</i>

Disk /dev/sda (SGI disk label): 64 heads, 32 sectors, 17482 cylinders
Units = cylinders of 2048 * 512 bytes

----- partitions -----
Pt#     Device  Info     Start       End   Sectors  Id  System
 9:  /dev/sda1               0         4     10240   0  SGI volhdr
11:  /dev/sda2               0     17481  35803136   6  SGI volume
----- Bootinfo -----
Bootfile: /unix
----- Directory Entries -----

Command (m for help):
</pre>

<note>
Jeśli na dysku znajduje się już SGI Disklabel, fdisk nie pozwoli na stworzenie
nowej. Są dwa sposoby, żeby to ominąć. Pierwszym jest stworzenie etykiety
SUN lub MS-DOS, zapisanie zmian i ponowne uruchomienie fdisk. Drugim jest
nadpisanie tablicy partycji następującym poleceniem:
<c>dd if=/dev/zero of=/dev/sda bs=512 count=1</c>.
</note>

</body>
</subsection>
<subsection>
<title>Nadawanie właściwego rozmiaru SGI Volume Header.</title>
<body>

<p>

Gdy stworzysz SGI Disklabel, możesz przystąpić do definiowania partycji.
W powyższym przykładzie, dwie z nich zostały już przygotowane.
Pełnią one specjalne funkcje i nie mogą być wykorzystane w normalny sposób.
Jakkolwiek, instalując Gentoo musimy załadować obrazy jądra bezpośrednio
do nagłówka woluminu, gdyż nie ma w Portage wspieranego menadżera uruchamiania.
Nagłówek woluminu może przechowywać maksymalnie <e>osiem</e> kerneli o dowolnym
rozmiarze i ośmioznakowej nazwie.
</p>

<p>
Proces powiększania woluminu nagłówka nie jest prosty - trzeba zastosować
kilka sztuczek. Nie można po prostu usunąć i dodać go ponownie, ze
względu na dziwne zachowanie fdisk. W poniższym przykładzie, utworzymy
50MB nagłówek woluminu oraz 50MB partycję boot. Rzeczywisty
podział Twojego dysku może być inny, przykład służy tylko
zilustrowaniu czynności:
</p>

<pre caption="Prawidłowa zmiana rozmiaru Nagłówka Woluminu SGI">
Command (m for help): <i>n</i>
Partition number (1-16): <i>1</i>
First cylinder (5-8682, default 5): <i>51</i>
 Last cylinder (51-8682, default 8682): <i>101</i>
<comment>(Zauważ, że fdisk pozwala na stworzenie pierwszej partycji co najmniej od piątego cylindra</comment>
<comment>(Jeśli próbowałeś już usunąć i stworzyć ponownie Nagłówek Woluminu SGI tą metodą, napewno
spotkałeś się z takim zachowaniem)</comment>
<comment>(W naszym przykładzie chcemy aby /boot miało 50MB, więc zaczniemy od cylindra 51 (pamiętaj,
że Nagłówek Woluminu musi zaczynać się od cylindra 0) i zakończymy na cylindrze 101. Rozmiar tylko
nieznacznie będzie się różnił od oczekiwanego (+/- 1-5MB)</comment>

Command (m for help): <i>d</i>
Partition number (1-16): <i>9</i>
<comment>(Usuń partycję 9 (Nagłówek Woluminu SGI))</comment>

Command (m for help): <i>n</i>
Partition number (1-16): <i>9</i>
First cylinder (0-50, default 0): <i>0</i>
 Last cylinder (0-50, default 50): <i>50</i>
<comment>(Ponownie stwórz partycję 9, kończącą się tuż przed partycją 1)</comment>
</pre>

</body>
</subsection>
<subsection>
<title>Ostateczny schemat partycji.</title>
<body>

<p>
Możesz teraz stworzyć resztę potrzebnych partycji. Upewnij się, że
ID partycji wymiany ustawiono na <c>82</c>, czyli Linux Swap, gdyż
domyślnie jest to <c>83</c>, Linux Native.
</p>

<p>
Następnie, gdy będą już gotowe, przejdź do paragrafu <uri 
link="#filesystems">Zakładanie systemów plików</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Tworzenie systemów plików.</title>
<subsection>
<title>Wprowadzenie.</title>
<body>

<p>
Po utworzeniu partycji nadszedł czas na założenie na nich systemów plików.
Jeśli nie obchodzi Cię jakie wybierzesz i jesteś zadowolony z domyślnych
ustawień w podręczniku, przejdź do <uri link="#filesystems-apply">Zakładania na
Partycji Systemu Plików</uri>. W przeciwnym wypadku czytaj dalej aby dowiedzieć
się co nieco na ich temat.
</p>

</body>
</subsection>
<subsection>
<title>Systemy plików?</title>
<body>

<p>
Dostępne są różne systemy plików. Część z nich działa stabilnie
na wszystkich platformach, część tylko na niektórych. Poniższa tabela
prezentuje te, które są dostępne i na jakich architekturach działają.
Jeśli architektura oznaczona jest przez "(...)" to znaczy, iż
system plików powinien działać, ale nie został dostatecznie przetestowany.
</p>

<table>
<tr>
  <th>System Plików</th>
  <th>Dziennik</th>
  <th>Architektury</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti>nie</ti>
  <ti>Wszystkie architektury</ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti>tak</ti>
  <ti>Wszystkie architektury</ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti>tak</ti>
  <ti>x86, hppa, alpha, (mips), (ppc), (amd64)</ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti>tak</ti>
  <ti>x86, alpha, (ppc)</ti> <!-- TODO when xfs is in mips-sources, add "(mips)" -->
</tr>
<tr>
  <ti>jfs</ti>
  <ti>tak</ti>
  <ti>x86, alpha, (mips), (amd64)</ti>
</tr>
</table>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików, którego główną
wadą jest to, że nie posiada księgowania. Powoduje to, iż jego regularne 
kontrole przy starcie systemu bywają długotrwałe. Obecnie istnieją nowoczesne 
systemy plików z księgowaniem, które można szybko sprawdzić i to właśnie te 
polecamy naszym użytkownikom. Księgowanie zapobiega długotrwałym kontrolom 
podczas uruchamiania systemu oraz ewentualnym błędom spójności danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach
full oraz ordered, dzięki czemu w razie awarii dane odzyskiwane są
błyskawicznie. Jest on bardzo dobrym i niezawodnym rozwiązaniem.
Posiada ukrytą opcję korzystania z drzewa b, co znacznie poprawia
wydajność niemal we wszystkich sytuacjach. Krótko mówiąc, ext3
jest świetny.
</p>

<p>
<b>ReiserFS</b> to system plików oparty na drzewie B*, oferujący
dużą wydajność. Przy wielu małych plikach (poniżej 4k) może
być szybszy od ext3 nawet piętnastokrotnie. ReiserFS jest
wysoce skalowalny i posiada księgowanie, a począwszy od jądra 2.4.18,
charakteryzuje go niezawodność i użyteczność zarówno na partycjach ogólnego
przeznaczenia jak i w ekstremalnych przypadkach, takich jak ogromne
partycje, operacje na wielu bardzo małych, lub bardzo dużych plikach czy też
operacje na katalogach zawierających dziesiątki tysięcy plików.
</p>

<p>
<b>XFS</b> to system plików z księgowaniem, w pełni wspierany
w Gentoo Linux przez jądro xfs-sources. Jest bardzo funkcjonalny i zoptymalizowany
do skalowalności. Zalecamy go wyłącznie do systemów z nowoczesnymi dyskami SCSI
i/lub ciągłego zapisu danych z nieprzerwanym dostępem zasilania. Ponieważ
XFS przechowuje dużo danych w pamięci RAM, źle zaprojektowane programy
(te nie zachowujące odpowiednich środków ostrożności podczas zapisywania plików
na dysk, których niestety jest sporo) mogą doprowadzić w razie padu
systemu do utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików IBM, posiadający księgowanie.
Dopiero niedawno został uznany za stabilny i jest jeszcze za wcześnie, 
aby można było mówić źle lub dobrze o jego stabilności.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie systemu plików na partycji.</title>
<body>

<p>
Aby założyć na woluminie lub partycji system plików, możesz skorzystać z 
odpowiedniego dla każdego z nich narzędzia:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Program do zakładania</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć ext2 na partycji boot (w naszym przypadku <path>/dev/hda1</path>)
oraz ext3 na partycji root (w naszym przypadku <path>/dev/hda3</path>), powinieneś
wykonać następujące polecenia:
</p>

<pre caption="Zakładanie na partycji systemu plików">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Stwórz teraz systemy plików na swoich partycjach (lub woluminach logicznych).
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja partycji wymiany.</title>
<body>

<p>
Aby zainicjować partycję wymiany, skorzystaj z programu <c>mkswap</c>.
</p>

<pre caption="Inicjalizacja partycji wymiany">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Aby aktywować partycję wymiany użyj programu <c>swapon</c>:
</p>

<note>
Jako że Knoppix automatycznie aktywuje wszystkie istniejące partycje wymiany,
jego użytkownicy mogą pominąć ten krok.
</note>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Teraz sam utwórz i aktuwuj partycję wymiany.
</p>

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu systemów plików, nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Nie zapomnij utworzyć
odpowiednich katalogów dla każdego z nich. Pokażemy to na przykładzie
partycji boot oraz root:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Jeżeli chcesz przenieść <path>/tmp</path> na oddzielną partycję,
nie zapomnij po zamontowaniu odpowiedni poprawić praw dostępu: <c>chmod
1777 /mnt/gentoo/tmp</c>. Dotyczy to również <path>/var/tmp</path>.
</note>

<p>
Musimy też zamontować system plików proc (wirtualny interfejs jądra)
w <path>/proc</path>. Zacznijmy od utworzenia odpowiedniego katalogu
(<path>/mnt/gentoo/proc</path>):
</p>

<pre caption="Tworzenie punktu montowania /mnt/gentoo/proc">
# <i>mkdir /mnt/gentoo/proc</i>
# <i>mount -t proc none /mnt/gentoo/proc</i>
</pre>

<p>
Kiedy skończysz przejdź do rozdziału <uri link="?part=1&amp;chap=5">Wgrywanie
plików instajacyjnych Gentoo</uri>.
</p>

</body>
</section>
</sections>
