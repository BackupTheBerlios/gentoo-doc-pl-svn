<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Orig revision: 1.12 -->
<!-- Translator: sekretarz <sekretarz@dukato.net> -->
<!-- Title: Przygotowanie Dysków na AMD64 -->
<!-- Status: Ukończono -->


<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/handbook/hb-install-amd64-disk.xml,v 1.2 2004/11/29 16:28:46 rane Exp $ -->

<sections>

<version>1.9</version>
<date>2004-09-25</date>

<section>
<title>Wprowadzenie do Urządzeń Blokowych</title>
<subsection>
<title>Urządzenia Blokowe</title>
<body>

<p>
Rzućmy okiem na aspekty Gentoo Linux, oraz ogólnie Linuksa, związane z dyskami.
Omówimy systemy plików, partycje oraz urządzenia blokowe. Następnie
przeprowadzimy Cię przez proces podziału twardego dysku, aby jak najlepiej
wykorzystać dostępną przestrzeń.
</p>

<p>
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path>, reprezentujący w Linuksie pierwszy
napęd IDE. Jeśli posiadasz urządzenia SCSI, pierwszym takim
dyskiem jest <path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy
użytkownika mogą z nich korzystać nie martwiąc się czy napędy
są typu IDE, SCSI lub jeszcze inne. Przechowywane dane adresuje się
za jako ciąg 512-bajtowych bloków.
</p>

</body>
</subsection>
<subsection>
<title>Partycje i Plastry</title>
<body>

<p>
Jakkolwiek teoretycznie możliwe jest przeznaczenie na system całego dysku,
zazwyczaj nie jest to rozwiązanie praktyczne. Zamiast tego, dzieli się
napęd na mniejsze, łatwiejsze w zarządzaniu, urządzenia blokowe.
Na systemach amd64 nazywane są one <e>partycjami</e>.
</p>

</body>
</subsection>
<subsection>
<title>Partycje</title>
<body>

<p>
Wyróżniamy trzy rodzaje partycji: <e>podstawowe</e>,
<e>rozszerzone</e> oraz <e>logiczne</e>.
</p>

<p>
Informacje o partycjach <e>podstawowych</e> przechowywane są w MBR
(master boot record). Jako że jest on bardzo mały (512 bajtów), mieszczą
się w nim dane najwyżej czterech takich partycji (na przykład,
od <path>/dev/hda1</path> do <path>/dev/hda4</path>).
</p>

<p>
Specjalną odmianą partycji podstawowych są partycje <e>rozszerzone</e>
(oznacza to, że również obowiązuje je powyższy limit). Przechowują
one kolejne partycje. W ten sposób można ominąć niewygodną granicę
i lepiej zagospodarować przestrzeń dyskową bez utraty kompatybilności
wstecz.
</p>

<p>
Partycjami <e>logicznymi</e> nazywamy partycje znajdującymi się wewnatrz partycji rozszrzonej.
Ich definicja nie jest przechowywana w MBR, są one zdeklarowane wewnatrz partycji rozszerzonej.
</p>

</body>
</subsection>
</section>
<section>
<title>Projektowanie Schematu Podziału</title>
<subsection>
<title>Domyślny Schemat Podziału</title>
<body>

<p>
Jeśli nie masz ochoty samodzielnie rozrysowywać schematu podziału
swojego dysku, możesz skorzystać z domyślnego, którego
użyjemy w podręczniku:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>System plików</th>
  <th>Rozmiar</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>ext2</ti>
  <ti>32M</ti>
  <ti>Partycja Boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>(swap)</ti>
  <ti>512M</ti>
  <ti>Partycja Swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>ext3</ti>
  <ti>Reszta dyskiRest of the disk</ti>
  <ti>Partycja Root</ti>
</tr>
</table>

<p>
Jeśli interesują Cię nasze rady dotyczące rozmiarów partycji
(lub woluminów logicznych) oraz ich ilości, czytaj dalej.
W przeciwnym wypadku przejdź od razu do <uri link="#fdisk">podziału dysku używając fdisk</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Jak Dużo Jak Wielkich?</title>
<body>

<p>
Ilość partycji ściśle zależy od danego
środowiska. Na przykład, jeśli administrujesz systemem mającym
wielu użytkowników, prawdopodobnie uznasz za stosowne
oddzielenie <path>/home</path> aby poprawić bezpieczeństwo
i uprościć tworzenie kopii zapasowych. Jeżeli docelowym
zastosowaniem świeżego Gentoo jest serwer poczty, na osobnej
partycji powinieneś umieścić <path>/var</path>, gdzie przechowywane
są listy. Dobry wybór systemu plików może tu znacznie zwiększyć
wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem
na serwerach gier, gdyż większość używanego oprogramowania zostanie
tam zainstalowana. Powód jest podobny do <path>/home</path>: bezpieczeństwo
i kopie zapasowe.
</p>

<p>
Jak widzisz, wiele zależy od oczekiwanego rezultatu. Wydzielenie partycji
lub woluminów ma wiele zalet:
</p>

<ul>
<li>
  Masz możliwość dostosowania jak najwydajniejszego w danym zastosowaniu
  systemu plików dla poszczególnych partycji lub woluminów
</li>
<li>
  W przypadku zapełnienia partycji przez nieprawidłowo działające
  narzędzie, nie ma to wpływu na całość systemu
</li>
<li>
  Jeśli to konieczne, można skrócić czas kontroli systemów plików, gdyż
  można jednocześnie dokonywać jej na kilku partycjach (ma to znaczenie
  zwłaszcza na sprzęcie z wieloma dyskami)
</li>
<li>
  Montując część partycji lub woluminów z opcjami read-only (tylko do odczytu),
  nosuid (ignorowane są bity setuid), noexec (ignorowane są bity wykonywalności) itd.
  można znacznie poprawić bezpieczeństwo
</li>
</ul>
		

<p>
Niestety zbyt rozbudowany podział niesie z sobą spore niebezpieczeństwo:
źle zaplanowany zaowocuje pustkami na zbyt dużychi ciasnotą na zbyt małych partycjach. 
Istnieje także limit 15 partycji dla SCSI i SATA.
</p>

<p>
W przykładzie pokażemy partycjonowanie dysku 20GB, wykorzystywanego
w pokazowym laptopie z zainstalowanymi serwerami poczty oraz WWW,
GNOME, itd.:
</p>

<pre caption="Przykładowy podział dysku">
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/hda5     ext3    509M  132M  351M  28% /
/dev/hda2     ext3    5.0G  3.0G  1.8G  63% /home
/dev/hda7     ext3    7.9G  6.2G  1.3G  83% /usr
/dev/hda8     ext3   1011M  483M  477M  51% /opt
/dev/hda9     ext3    2.0G  607M  1.3G  32% /var
/dev/hda1     ext2     51M   17M   31M  36% /boot
/dev/hda6     swap    516M   12M  504M   2% &lt;not mounted&gt;
<comment>(Zostało nam 2GB niespartycjonowanej przestrzeni, którą będziemy mogli wykorzystać w przyszłości)</comment>
</pre>

<p>
<path>/usr</path> jest niemal w pełni zajęty (wykorzystane 83%),
ale po instalacji wszystkich potrzebnych pakietów nie będzie się
on zbytnio rozrastał. Część czytelników może pomyśleć, iż
zbyt wiele miejsca przeznaczyliśmy na <path>/var</path>.
Należy zwrócić uwagę, że Gentoo kompiluje wszystkie pakiety
wewnątrz <path>/var/tmp/portage</path>. Powinien mieć
wobec tego przynajmniej 1GB wolnej przestrzeni, jeśli nie zamierzasz
kompilować większych programów, lub nawet 3GB - gdy
jednoczesna instalacja KDE i OpenOffice.org nie stanowi dla Ciebie
problemu.
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Partycjonowanie Dysku za pomocą fdisk</title>
<subsection>
<body>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie:
</p>

<table>
<tr>
  <th>Partycja</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/hda1</path></ti>
  <ti>Partycja Boot</ti>
</tr>
<tr>
  <ti><path>/dev/hda2</path></ti>
  <ti>Partycja Swap</ti>
</tr>
<tr>
  <ti><path>/dev/hda3</path></ti>
  <ti>Partycja Root</ti>
</tr>
</table>

<p>
Zmodyfikuj go wedle swoich potrzeb.
</p>

</body>
</subsection>
<subsection>
<title>Wyświetlanie Aktualnego Podziału Dysku</title>
<body>

<p>
<c>fdisk</c> to znane i funkcjonalne narzędzie do partycjonowania.
Uruchom go dla swojego dysku (pokażemy to na przykładzie <path>/dev/hda</path>):
</p>

<pre caption="Uruchamianie fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
Twoim oczom ukaże się podobny znak zachęty:
</p>

<pre caption="Znak zachęty fdisk">
Command (m for help): 
</pre>

<p>
Aby wyświetlić obecną konfigurację partycji, wpisz <c>p</c>:
</p>

<pre caption="Przykładowa konfiguracja partycji">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
Na prezentowanym dysku znajduje się siedem linuksowych systemów plików
(każdy na odpowiadającej partycji, oznaczonej jako "Linux") oraz partycja
wymiany (oznaczona jako "Linux swap").
</p>

</body>
</subsection>
<subsection>
<title>Kasowanie wszystkich Partycji</title>
<body>

<p>
Zacznijmy od usunięcia partycji. Służy do tego polecenie <c>d</c> z odpowiednim parametrem.
Na przykład, aby pozbyć się <path>/dev/hda1</path>:
</p>

<pre caption="Usuwanie partycji">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
Nasza partycja została oznaczona do usunięcia. Nie będzie więcej pojawiać się
po wydaniu polecenia <c>p</c>, ale dopóki zmiany nie zostaną zapisane
fizycznie, pozostanie nie naruszona. Jeśli popełnisz błąd i zechcesz
anulować wszelkie zmiany, wpisz natychmiast <c>q</c> i wciśnij Enter.
Twoje modyfikacje pójdą w niepamięć.
</p>

<p>
Zakładając, że chcesz pozbyć się wszystkich istniejących partycji,
na przemian wykonuj <c>p</c> aby wyświetlić ich listing i
po kolei kasuj je poleceniem <c>d</c> z odpowiednim numerem. Po ukończeniu,
<c>p</c> powinno dać następujący rezultat:
</p>

<pre caption="Pusta tablica partycji">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
Kiedy nasza tymczasowa kopia tablicy partycji będzie pusta, możemy rozpocząć
tworzenie nowego podziału. Pokażemy to na przykładzie domyślnego omawianego
schematu. Oczywiście jeśli Ci on nie odpowiada, musisz poczynić stosowne
modyfikacje prezentowanych poleceń.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Boot</title>
<body>

<p>
Rozpoczniemy od utworzenia niewielkiej partycji boot. Wpisz <c>n</c> aby
ją założyć, następnie <c>p</c> aby nadać jej typ podstawowy i <c>1</c>,
ponieważ będzie to pierwsza taka partycja. Zapytany o pierwszy cylinder
wciśnij Enter, natomiast zapytany o ostatni, wpisz <c>+32M</c>, żeby nadać
jej rozmiar 32MB.
</p>

<pre caption="Zakładanie partycji boot">
Command (m for help): <i>n</i>
Command action
  e   extended
  p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Naciśnij Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
Teraz polecenie <c>p</c> powinno pokazać następujący listing:
</p>

<pre caption="Utworzona partycja boot">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
Musimy oznaczyć naszą partycję jako uruchamialną. W tym celu skorzystamy
z polecenia <c>a</c>. Na kolejnych wydrukach podziału, w kolumnie
"Boot" pokazywać się będzie <path>*</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Swap</title>
<body>

<p>
Nadszedł czas na utworzenie partycji wymiany. Ponownie skorzystaj z polecenia
<c>n</c>, następnie podaj <c>p</c> gdyż ma to być partycja podstawowa i <c>2</c>,
ponieważ będzie ona drugą tego typu. Zapytany o pierwszy cylinder wciśnij Enter,
natomiast na pytanie o ostatni wpisz <c>+512M</c>, żeby nadać partycji
rozmiar 512MB. Po ukończeniu wykonaj <c>t</c>, aby zmienić jej typ,
<c>2</c>, aby wybrać tę, którą właśnie stworzyłeś i <c>82</c>, żeby oznaczyć
ją jako "Linux Swap". Teraz polecenie <c>p</c> powinno dać następujący
listing:
</p>

<pre caption="Listing podziału po utworzeniu partycji wymiany">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

</body>
</subsection>
<subsection>
<title>Zakładanie Partycji Root</title>
<body>

<p>
Na koniec, utworzymy partycję root. Jeszcze raz posłużymy się w tym celu poleceniem
<c>n</c>. Zapytany o rodzaj wpisz <c>p</c>, ponieważ chcemy by była podstawowa,
następnie <c>3</c>, gdyż będzie już trzecią tego typu, czyli w naszym przypadku
<path>/dev/hda3</path>. Na pytanie o pierwszy i ostatni cylinder wciśnij Enter,
dzięki temu zajmie ona całą pozostałą wolną przestrzeń. Teraz polecenie
<c>p</c> powinno pokazać następujący wydruk:
</p>

<pre caption="Listing podziału po utworzeniu partycji root">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1 *        1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>


</body>
</subsection>
<subsection>
<title>Zapisywanie Podziału Partycji</title>
<body>

<p>
Aby zachować ustalony podział i opuścić <c>fdisk</c>, wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoje partycje są już gotowe, możesz teraz przejść do <uri 
link="#filesystems">Zakładania Systemów Plików</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Tworzenie Systemów Plików</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Po stworzeniu partycji nadszedł czas na
założenie na nich systemów plików. Jeśli nie obchodzi Cię
jakie wybierzesz i jesteś zadowolony z domyślnych ustawień w podręczniku,
przejdź do
<uri link="#filesystems-apply">Zakładania na Partycji Systemu Plików</uri>.
W przeciwnym wypadku czytaj dalej aby dowiedzieć się co nieco na ich temat.
</p>

</body>
</subsection>
<subsection>
<title>Systemy plików?</title>
<body>

<p>
Pare systemów plików jest dostępnych. Niektóre z nich uznawane są za stabline na 
architekturze amd64, inne nie. Za stablilne uznawane są:
ext2 i ext3. jfs i reiserfs pewnie działają dobrze, ale potrzebują wiecej testów. Jeżeli jesteś
prawdziwym ryzykantem możesz spróbować niewspieranych systemów plików.
</p>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików, ale nie posiada
księgowania. Powoduje to, iż jego regularne kontrole przy starcie systemu
bywają długotrwałe. Obecnie istnieją nowoczesne systemy plików z księgowaniem,
mogące być szybko sprawdzane i są zasadniczo zalecane. Księgowanie
zapobiega długotrwałym kontrolom podczas uruchamiania i ewentualnym
błędom spójności danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach
full oraz ordered, dzięki czemu w razie awarii dane odzyskiwane są
błyskawicznie. Jest on bardzo dobrym i niezawodnym rozwiązaniem.
Posiada ukrytą opcję korzystania z drzewa b, co znacznie poprawia
wydajność niemal we wszystkich sytuacjach. Krótko mówiąc, ext3
jest świetny.
</p>

<p>
<b>ReiserFS</b> is a B*-tree based filesystem that has very good overall 
performance and greatly outperforms both ext2 and ext3 when dealing with small 
files (files less than 4k), often by a factor of 10x-15x. ReiserFS also scales 
extremely well and has metadata journaling. As of kernel 2.4.18+, ReiserFS is 
solid and usable as both general-purpose filesystem and for extreme cases such 
as the creation of large filesystems, the use of many small files, very large 
files and directories containing tens of thousands of files. 
</p>

<p>
<b>ReiserFS</b> to system plików oparty na drzewie B*, oferujący
dużą wydajność. Przy wielu małych plikach (poniżej 4k) może
być szybszy od ext3 nawet piętnastokrotnie. ReiserFS jest
wysoce skalowalny i posiada księgowanie, a począwszy od jądra 2.4.18,
charakteryzuje go niezawodność i użyteczność zarówno na partycjach ogólnego
przeznaczenia jak i w ekstremalnych przypadkach, takich jak ogromne
partycje, operacje na wielu bardzo małych, lub bardzo dużych plikach czy też
operacje na katalogach zawierających dziesiątki tysięcy plików.
</p>

<p>
<b>XFS</b> to system plików z księgowaniem, w pełni wspierany
w Gentoo Linux przez jądro xfs-sources. Jest bardzo funkcjonalny i zoptymalizowany
do skalowalności. Zalecamy go wyłącznie do systemów z nowoczesnymi dyskami SCSI
i/lub ciągłego zapisu danych z nieprzerwanym dostępem zasilania. Ponieważ
XFS przechowuje dużo danych w pamięci RAM, źle zaprojektowane programy
(te nie zachowujące odpowiednich środków ostrożności podczas zapisywania plików
na dysk, których niestety jest sporo) mogą doprowadzić w razie padu
systemu do utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików z księgowaniem IBMa.
Dopiero niedawno został uznany za stabilny i nie ma na swoim
koncie dostatecznych osiągnięć aby można było mówić
źle lub dobrze o jego stabilności.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie na Partycji Systemu Plików</title>
<body>

<p>
Aby założyć na woluminie lub partycji system plików, możesz skorzystać z dostępnych
dla każdego narzędzi:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Komenda do zakładania</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć ext2 na partycji boot (w naszym przypadku <path>/dev/hda1</path>)
oraz ext3 na partycji root (w naszym przypadku <path>/dev/hda3</path>), powinieneś
wykonać następujące polecenia:
</p>

<pre caption="Zakładanie na partycji systemu plików">
# <i>mke2fs /dev/hda1</i>
# <i>mke2fs -j /dev/hda3</i>
</pre>

<p>
Stwórz teraz systemy plików na swoich partycjach.
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja Partycji Swap</title>
<body>

<p>
Aby zainicjalizować partycje wymiany, skorzystaj z programu <c>mkswap</c>.
</p>

<pre caption="Inicjalizacja partycji wymiany">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
Aby je aktywować skorzystaj ze <c>swapon</c>:
</p>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/hda2</i>
</pre>

<p>
Teraz Twoja kolej na inicjalizację i aktywację.
</p>

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu systemów plików, nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Nie zapomnij utworzyć
odpowiednich katalogów dla każdego z nich. Pokażemy to na przykładzie
partycji boot oraz root:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<note>
Jeżeli chcesz przenieść <path>/tmp</path> na oddzielną partycję,
nie zapomnij po zamontowaniu odpowiedni poprawić praw dostępu: <c>chmod
1777 /mnt/gentoo/tmp</c>. Dotyczy to również <path>/var/tmp</path>.
</note>

<p>
Musimy też zamontować system plików proc (wirtualny interfejs jądra)
w <path>/proc</path>. Zacznijmy od utworzenia odpowiedniego katalogu
(<path>/mnt/gentoo/proc</path>):
</p>

<p>
Przejdź teraz do <uri link="?part=1&amp;chap=5">Instalacji Plików
Instalacyjnych Gentoo</uri>.
</p>

</body>
</section>
</sections>
