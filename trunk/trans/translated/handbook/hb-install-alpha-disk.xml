<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- Orig revision: 1.12 -->
<!-- Translator: sekretarz <sekretarz@gentoo.org> -->
<!-- Title: Przygotowanie Dysków -->
<!-- Status: Ukończono -->

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/handbook/hb-install-alpha-disk.xml,v 1.2 2004/12/05 22:12:12 rane Exp $ -->

<sections>

<version>1.9</version>
<date>2004-08-30</date>

<section>
<title>Wprowadzenie do urządzeń blokowych.</title>
<subsection>
<title>Urządzenia blokowe.</title>
<body>

<p>
Rzućmy okiem na aspekty Gentoo Linux, oraz ogólnie Linuksa związane z dyskami.
Omówimy systemy plików, partycje oraz urządzenia blokowe. Następnie
przeprowadzimy Cię przez proces podziału twardego dysku, tak abyś mógł jak najlepiej
wykorzystać dostępne miejsce.
</p>

<p>
Zaczniemy od omówienia <e>urządzeń blokowych</e>. Najpopularniejszym z nich
prawdopodobnie jest <path>/dev/hda</path>, reprezentujący w Linuksie pierwszy
napęd IDE. Jeśli posiadasz urządzenia SCSI, pierwszym takim
dyskiem jest <path>/dev/sda</path>.
</p>

<p>
Urządzenia blokowe stanowią abstrakcyjny interfejs dysków. Programy
użytkownika mogą z nich korzystać nie martwiąc się czy napędy
są typu IDE, SCSI lub jeszcze inne. Przechowywane dane adresuje się
za jako ciąg 512-bajtowych bloków.
</p>

</body>
</subsection>
<subsection>
<title>Plastry</title>
<body>

<p>
Jakkolwiek teoretycznie możliwe jest przeznaczenie na system całego dysku,
zazwyczaj nie jest to rozwiązanie praktyczne. Zamiast tego, dzieli się
napęd na mniejsze, łatwiejsze w zarządzaniu, urządzenia blokowe.
Na systemach Alpha, są to tak zwane <e>plastry</e>.
</p>

</body>
</subsection>
</section>
<section>
<title>Projektowanie Schematu Podziału</title>
<subsection>
<title>Domyślny Schemat Podziału</title>
<body>

<p>
Jako przykład użyjemy następującego schematu plastrów:
</p>

<table>
<tr>
  <th>Plaster</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/sda1</path></ti>
  <ti>Plaster Swap</ti>
</tr>
<tr>
  <ti><path>/dev/sda2</path></ti>
  <ti>Plaster Root</ti>
</tr>
<tr>
  <ti><path>/dev/sda3</path></ti>
  <ti>Caly dysk (wymagane)</ti>
</tr>
</table>


<p>
Jeśli interesują Cię nasze rady dotyczące rozmiarów partycji
(lub woluminów logicznych) oraz ich ilości, czytaj dalej.
W przeciwnym wypadku przejdź od razu do <uri link="#fdisk">podziału dysku za pomocą fdisk</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Jak dużo jak wielkich?</title>
<body>

<p>
Ilość partycji ściśle zależy od danego
środowiska. Na przykład, jeśli administrujesz systemem mającym
wielu użytkowników, prawdopodobnie uznasz za stosowne
oddzielenie <path>/home</path> aby poprawić bezpieczeństwo
i uprościć tworzenie kopii zapasowych. Jeżeli docelowym
zastosowaniem świeżego Gentoo jest serwer poczty, na osobnej
partycji powinieneś umieścić <path>/var</path>, gdzie przechowywane
są listy. Dobry wybór systemu plików może tu znacznie zwiększyć
wydajność. Oddzielenie <path>/opt</path> jest dobrym rozwiązaniem
na serwerach gier, gdyż większość używanego oprogramowania zostanie
tam zainstalowana. Powód jest podobny do <path>/home</path>: bezpieczeństwo
i kopie zapasowe.
</p>

<p>
Jak widzisz, wiele zależy od oczekiwanego rezultatu. Wydzielenie partycji
lub woluminów ma wiele zalet:
</p>

<ul>
<li>
  Masz możliwość dostosowania jak najwydajniejszego w danym zastosowaniu
  systemu plików dla poszczególnych partycji lub woluminów
</li>
<li>
  W przypadku zapełnienia partycji przez nieprawidłowo działające
  narzędzie, nie ma to wpływu na całość systemu
</li>
<li>
  Jeśli to konieczne, można skrócić czas kontroli systemów plików, gdyż
  można jednocześnie dokonywać jej na kilku partycjach (ma to znaczenie
  zwłaszcza na sprzęcie z wieloma dyskami)
</li>
<li>
  Montując część partycji lub woluminów z opcjami read-only (tylko do odczytu),
  nosuid (ignorowane są bity setuid), noexec (ignorowane są bity wykonywalności) itd.
  można znacznie poprawić bezpieczeństwo
</li>
</ul>

<p>
Niestety zbyt rozbudowany podział niesie z sobą spore niebezpieczeństwo:
źle zaplanowany zaowocuje pustkami na zbyt dużych
i ciasnotą na zbyt małych partycjach.
</p>

</body>
</subsection>
</section>
<section id="fdisk">
<title>Partycjonowanie Dysku za pomocą fdisk</title>
<subsection>
<body>

<p>
W kolejnych podsekcjach pokażemy jak utworzyć partycje takie
jak w zaprezentowanym wcześniej schemacie:
</p>

<table>
<tr>
  <th>Plaster</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><path>/dev/sda1</path></ti>
  <ti>Plaster Swap</ti>
</tr>
<tr>
  <ti><path>/dev/sda2</path></ti>
  <ti>Plaster Root</ti>
</tr>
<tr>
  <ti><path>/dev/sda3</path></ti>
  <ti>Caly dysk (wymagane)</ti>
</tr>
</table>

<p>
Zmodyfikuj go wedle swoich potrzeb.
</p>


</body>
</subsection>
<subsection>
<title>Sprawdzanie Dostępnych Dysków</title>
<body>

<p>
Aby rozejrzeć się w dostępnych dyskach, skorzystaj z następujących poleceń:
</p>

<pre caption="Sprawdzanie dostępnych dysków">
# <i>dmesg | grep 'drive$'</i>        <comment>(dla dysków IDE)</comment>
# <i>dmesg | grep 'scsi'</i>          <comment>(dla dysków SCSI)</comment>
</pre>

<p>
Na podstawie rezultatu powinieneś wywnioskować, które dyski zostały
wykryte i jakie urządzenia w <path>/dev</path> je reprezentują. W kolejnych
podsekcjach zakładamy, iż korzystasz z pierwszego dysku SCSI (<path>/dev/sda</path>).
</p>

<p>
Odpal <c>fdisk</c>:
</p>

<pre caption="Odpalanie fdisk">
# <i>fdisk /dev/sda</i>
</pre>

</body>
</subsection>
<subsection>
<title>Usuwanie Wszystkich Plastrów</title>
<body>

<p>
Jeżeli Twój dysk twardy jest kompletnie pusty, będziesz musiał najpierw stworzyć
etykiete dysku BSD.
</p>

<pre caption="Utworzenie etykiety BSD dysku">
Command (m for help): <i>b</i>
/dev/sda contains no disklabel.
Do you want to create a disklabel? (y/n) <i>y</i>
<comment>Teraz zobaczysz pare informacji specyficznych dla każdego dysku</comment>
3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

<p>
Zaczniemy od pozbycia się wszystkich plastrów, <e>z wyjątkiem</e> plastra 'c'.
Pokażemy jak to zrobić na przykładzie 'a'. Powtórz ten proces aby
usunąć również pozostałe (oczywiście oprócz 'c').
</p>

<p>
Użyj <c>p</c> alby ujrzeć wszystkie plastry. Do usuwania służy <c>d</c>.
</p>

<pre caption="Usuwanie plastra">
BSD disklabel command (m for help): <i>p</i>

8 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        1       235*      234*    4.2BSD     1024  8192    16
  b:      235*      469*      234*      swap
  c:        1      5290*     5289*    unused        0     0
  d:      469*     2076*     1607*    unused        0     0
  e:     2076*     3683*     1607*    unused        0     0
  f:     3683*     5290*     1607*    unused        0     0
  g:      469*     1749*     1280     4.2BSD     1024  8192    16
  h:     1749*     5290*     3541*    unused        0     0

BSD disklabel command (m for help): <i>d</i>
Partition (a-h): <i>a</i>
</pre>

<p>
Po powtórzeniu powyższego procesu dla wszystkich plastrów, listing powinien
przedstawiać się następująco:
</p>

<pre caption="Viewing an empty scheme">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Plastra Swap</title>
<body>

<p>
W komputerach Alpha nie ma konieczności tworzenia partycji boot. Jakkolwiek
pierwszy cylinder zostanie zajęty obrazem <c>aboot</c>.
</p>

<p>
Utworzymy teraz plaster swap, począwszy od trzeciego cylindra o rozmiarze
1GB. W tym celu skorzystaj z polecenia <c>n</c>. Następnie
zmień jego typ na <c>1</c>, czyli <e>swap</e>.
</p>

<pre caption="Zakładanie plastra swap">
BSD disklabel command (m for help): <i>n</i>
Partition (a-p): <i>a</i>
First cylinder (1-5290, default 1): <i>3</i>
Last cylinder or +size or +sizeM or +sizeK (3-5290, default 5290): <i>+1024M</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>a</i>
Hex code (type L to list codes): <i>1</i>
</pre>

<p>
Teraz listing podziału powinien wyglądać podobnie:
</p>

<pre caption="Listing podziału po założeniu plastra swap">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Tworzenie Plastra Root</title>
<body>

<p>
Nadszedł czas na utworzenie plastra root. Powinien on zaczynać się
od pierwszego cylindra <e>po</e> plastrze swap. Aby zobaczyć gdzie kończy
się ów plaster skorzystaj z polecenia <c>p</c>. W naszym przykładzie
jest to 1003, a więc początkiem plastra root będzie cylinder 1004.
</p>

<p>
Obecnie w programie <c>fdisk</c> znajduje się błąd, powodujący iż
liczba dostępnych cylindrów jest o jeden większa od faktycznej.
Innymi słowy, zapytany o ostatni cylinder, podaj numer (w naszym przykładzie
5290) zmniejszony o jeden.
</p>

<p>
Po założeniu partycji, zmień jej typ na <c>8</c>, czyli <e>ext2</e>.
</p>

<pre caption="Zakładanie plastra root">
D disklabel command (m for help): <i>n</i>
Partition (a-p): <i>b</i>
First cylinder (1-5290, default 1): <i>1004</i>
Last cylinder or +size or +sizeM or +sizeK (1004-5290, default 5290): <i>5289</i>

BSD disklabel command (m for help): <i>t</i>
Partition (a-c): <i>b</i>
Hex code (type L to list codes): <i>8</i>
</pre>

<p>
Teraz schemat podziału powinien wyglądać następująco:
</p>

<pre caption="Wyświetlanie listingu podziału">
BSD disklabel command (m for help): <i>p</i>

3 partitions:
#       start       end      size     fstype   [fsize bsize   cpg]                                    
  a:        3      1003      1001       swap
  b:     1004      5289      4286       ext2
  c:        1      5290*     5289*    unused        0     0
</pre>

</body>
</subsection>
<subsection>
<title>Zapisywanie Podziału Plastrów i Zamykanie fdisk</title>
<body>

<p>
Aby zapisać zmiany i opuścić <c>fdisk</c> wpisz <c>w</c>.
</p>

<pre caption="Zachowywanie zmian i zamykanie fdisk">
Command (m for help): <i>w</i>
</pre>

<p>
Twoj plastry są już gotowe, możesz teraz przejść do <uri 
link="#filesystems">Zakładania Systemów Plików</uri>.
</p>

</body>
</subsection>
</section>
<section id="filesystems">
<title>Tworzenie Systemów Plików</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Po stworzeniu partycji <!--(lub logicznych woluminów)--> nadszedł czas na
założenie na nich systemów plików. Jeśli nie obchodzi Cię
jakie wybierzesz i jesteś zadowolony z domyślnych ustawień w podręczniku,
przejdź do
<uri link="#filesystems-apply">Zakładania na Partycji Systemu Plików</uri>.
W przeciwnym wypadku czytaj dalej aby dowiedzieć się co nieco na ich temat.
</p>

</body>
</subsection>
<subsection>
<title>Systemy Plików?</title>
<body>

<p>
Dostępnych jest kilka systemów plików. Większość z nich działa stabilnie na architekturze Alpha
</p>

<p>
<b>ext2</b> to sprawdzony i popularny linuksowy system plików, ale nie posiada
księgowania. Powoduje to, iż jego regularne kontrole przy starcie systemu
bywają długotrwałe. Obecnie istnieją nowoczesne systemy plików z księgowaniem,
mogące być szybko sprawdzane i są zasadniczo zalecane. Księgowanie
zapobiega długotrwałym kontrolom podczas uruchamiania i ewentualnym
błędom spójności danych.
</p>

<p>
<b>ext3</b> to odpowiednik ext2 posiadający księgowanie w trybach
full oraz ordered, dzięki czemu w razie awarii dane odzyskiwane są
błyskawicznie. Jest on bardzo dobrym i niezawodnym rozwiązaniem.
Posiada ukrytą opcję korzystania z drzewa b, co znacznie poprawia
wydajność niemal we wszystkich sytuacjach. Krótko mówiąc, ext3
jest świetny.
</p>

<p>
<b>ReiserFS</b> to system plików oparty na drzewie B*, oferujący
dużą wydajność. Przy wielu małych plikach (poniżej 4k) może
być szybszy od ext3 nawet piętnastokrotnie. ReiserFS jest
wysoce skalowalny i posiada księgowanie, a począwszy od jądra 2.4.18,
charakteryzuje go niezawodność i użyteczność zarówno na partycjach ogólnego
przeznaczenia jak i w ekstremalnych przypadkach, takich jak ogromne
partycje, operacje na wielu bardzo małych, lub bardzo dużych plikach czy też
operacje na katalogach zawierających dziesiątki tysięcy plików.
</p>

<p>
<b>XFS</b> to system plików z księgowaniem, w pełni wspierany
w Gentoo Linux przez jądro xfs-sources. Jest bardzo funkcjonalny i zoptymalizowany
do skalowalności. Zalecamy go wyłącznie do systemów z nowoczesnymi dyskami SCSI
i/lub ciągłego zapisu danych z nieprzerwanym dostępem zasilania. Ponieważ
XFS przechowuje dużo danych w pamięci RAM, źle zaprojektowane programy
(te nie zachowujące odpowiednich środków ostrożności podczas zapisywania plików
na dysk, których niestety jest sporo) mogą doprowadzić w razie padu
systemu do utraty danych.
</p>

<p>
<b>JFS</b> to bardzo wydajny system plików z księgowaniem IBMa.
Dopiero niedawno został uznany za stabilny i nie ma na swoim
koncie dostatecznych osiągnięć aby można było mówić
źle lub dobrze o jego stabilności.
</p>

</body>
</subsection>
<subsection id="filesystems-apply">
<title>Zakładanie Systemu Plików na Partycji</title>
<body>

<p>
Aby założyć na woluminie lub partycji system plików, możesz skorzystać z dostępnych
dla każdego narzędzi:
</p>

<table>
<tr>
  <th>System plików</th>
  <th>Komenda do zakładania</th>
</tr>
<tr>
  <ti>ext2</ti>
  <ti><c>mke2fs</c></ti>
</tr>
<tr>
  <ti>ext3</ti>
  <ti><c>mke2fs -j</c></ti>
</tr>
<tr>
  <ti>reiserfs</ti>
  <ti><c>mkreiserfs</c></ti>
</tr>
<tr>
  <ti>xfs</ti>
  <ti><c>mkfs.xfs</c></ti>
</tr>
<tr>
  <ti>jfs</ti>
  <ti><c>mkfs.jfs</c></ti>
</tr>
</table>

<p>
Na przykład, aby założyć ext2 na partycji boot (w naszym przypadku <path>/dev/hda1</path>)
oraz ext3 na partycji root (w naszym przypadku <path>/dev/hda3</path>), powinieneś
wykonać następujące polecenia:
</p>

<pre caption="Zakładanie systemu plików na partycji">
# <i>mke2fs -j /dev/sda2</i>
</pre>

<p>
Stwórz teraz systemy plików na swoich partycjach (lub woluminach logicznych).
</p>

</body>
</subsection>
<subsection>
<title>Aktywacja Partycji Swap</title>
<body>

<p>
Aby zainicjalizować partycje wymiany, skorzystaj z programu <c>mkswap</c>.
</p>

<pre caption="Inicjalizacja partycji wymiany">
# <i>mkswap /dev/sda1</i>
</pre>

<p>
Aby je aktywować skorzystaj ze <c>swapon</c>:
</p>

<pre caption="Aktywacja partycji wymiany">
# <i>swapon /dev/sda1</i>
</pre>

<p>
Teraz Twoja kolej na inicjalizację i aktywację.
</p>

</body>
</subsection>
</section>
<section>
<title>Montowanie</title>
<body>

<p>
Po założeniu partycji i utworzeniu systemów plików, nadszedł czas na ich
zamontowanie. Służy do tego program <c>mount</c>. Nie zapomnij utworzyć
odpowiednich katalogów dla każdego z nich. Pokażemy to na przykładzie
partycji boot oraz root:
</p>

<pre caption="Montowanie partycji">
# <i>mount /dev/sda2 /mnt/gentoo</i>
</pre>

<note>
Jeżeli chcesz przenieść <path>/tmp</path> na oddzielną partycję,
nie zapomnij po zamontowaniu odpowiedni poprawić praw dostępu: <c>chmod
1777 /mnt/gentoo/tmp</c>. Dotyczy to również <path>/var/tmp</path>.
</note>

<p>
Musimy też zamontować system plików proc (wirtualny interfejs jądra)
w <path>/proc</path>. Zacznijmy od utworzenia odpowiedniego katalogu
(<path>/mnt/gentoo/proc</path>):
</p>

<p>
Przejdź teraz do <uri link="?part=1&amp;chap=5">Instalacji Plików
Instalacyjnych Gentoo</uri>.
</p>

</body>
</section>
</sections>
