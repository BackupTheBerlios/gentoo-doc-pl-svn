<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->
<!-- Orig revision: 1.25 -->
<!-- Translator: veng <veng@wp.pl> -->
<!-- Title: O instalacji Gentoo Linux -->
<!-- Status: Ukończono -->
<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/handbook/Attic/hb-install-bootloader.xml,v 1.2 2004/01/17 23:25:44 veng Exp $ -->

<sections>
<section>
<title>Podejmowanie decyzji</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Gdy skonfigurowałeś jądro i zmodyfikowałeś odpowiednio niezbędne systemowe
pliki konfiguracyjne, nadeszła pora zainstalowania programu, który uruchomi jądro
w momencie startu systemu. Taki program nazywa się <e>bootloader</e>.
Ale zanim zaczniesz, rozważ wszystkie opcje...
</p>

<p>
Istnieje kilka bootloaderów dla Linuksa. Niektóre z nich działają tylko
na niewielkiej grupie architektur. Musisz zatem wybrać taki, który
obsługuje Twoją architekturę.
</p>

<p>
Następująca tabela zawiera architektury i bootloadery, które je wspierają.
Wybierz odpowiedni dla swojej platformy. Na przykład, jeśli posiadasz
Pentium IV, wtedy Twoją architekturą jest <e>x86</e>. Możesz wybierać
między programami GRUB (co jest zalecane) oraz LILO.
</p>

<table>
<tr>
  <th>Architektura</th>
  <th>Zalecany</th>
  <th>Alternatywa</th>
</tr>
<tr>
  <th>x86</th>
  <ti><uri link="#doc_chap2">GRUB</uri></ti>
  <ti><uri link="#doc_chap3">LILO</uri></ti>
</tr>
<tr>
  <th>alpha</th>
  <ti><uri link="#doc_chap4">aBoot</uri></ti>
  <ti><uri link="#doc_chap5">MILO</uri></ti>
</tr>
<tr>
  <th>sparc</th>
  <ti><uri link="#doc_chap6">SILO</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>ppc</th>
  <ti>
    <uri link="#doc_chap8">yaBoot</uri> (NewWorld), 
    <uri link="#doc_chap9">BootX</uri> (OldWorld)
  </ti>
  <ti></ti>
</tr>
<tr>
  <th>hppa</th>
  <ti><uri link="#doc_chap7">PALO</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>mips</th>
  <ti><uri link="#doc_chap10">MIPS PROM</uri></ti>
  <ti></ti>
</tr>
<tr>
  <th>amd64</th>
  <ti><uri link="#doc_chap2">GRUB</uri></ti>
  <ti></ti>
</tr>
</table>

</body>
</subsection>
<subsection>
<title>Opcjonalnie: Bufor ramki</title>
<body>

<note>
Ta część ma zastosowanie tylko w przypadku wykorzystania wsparcia dla bufora ramki
przez jądro przez użytkownika platformy x86, AMD64 lub PPC . To dotyczy także
użytkowników programu <c>genkernel</c>.
</note>

<p>
<e>Gdy</e> skonfigurowałeś jądro z obsługa bufora ramki i chcesz to wykorzystać,
musisz dodać parametr <c>vga</c> do konfiguracji bootloadera.
Kolejna tabela prezentuje wartości, które <c>vga</c> może przyjąć.
W przykładowych plikach konfiguracyjnych używamy
<e>800x600 @ 16bpp</e>, czyli <e>788</e>.
</p>

<table>
<tr>
  <ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th>
</tr>
<tr>
  <th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti>
</tr>
<tr>
  <th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti>
</tr>
<tr>
  <th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti>
</tr>
</table>

<p>
Zapamiętaj (albo zapisz) swoją wartość; niedługo Ci się ona przyda.
</p>

<p>
Teraz wybierz bootloader z tabeli powyżej.
</p>

</body>
</subsection>
</section>
<section>
<title>Domyślnie: Użycie programu GRUB</title>
<subsection>
<title>Wyjaśnienie terminologii GRUB'a</title>
<body>

<impo>
GRUB działa tylko na platformach x86 i AMD64 !
</impo>

<p>
Najważniejszym czynnikiem prowadzącym do zrozumienia programu
GRUB jest pojęcie jego sposobu odnoszenia się do dysków i partycji.
Twoja linuksowa partycja <path>/dev/hda1</path> jest określana
przez GRUB'a jako <path>(hd0,0)</path>.
Zauważ nawiasy po obu stronach <path>hd0,0</path> - ich użycie jest wymagane.
</p>

<p>
Dyski twarde są liczone od zera, a nie od "a", partycje także zaczynają
się od zera, a nie od jedynki. Bądź świadom także tego, że w grupie
urządzeń pamięci masowej, tylko twarde dyski są liczone, nie ma to
natomiast miejsca  w przypadku napędów atapi-ide takich jak cdrom'y
i nagrywarki. Ta sama sytuacja ma miejsce w przypadku dysków scsi.
(Normalnie otrzymują one wyższe numery niż dyski ide za wyjątkiem
sytuacji, gdy bios jest ustawiony na start systemu z urządzenia scsi.)
</p>

<p>
Zakładając, że masz dysk twardy oznaczony jako <path>/dev/hda</path>,
odtwarzacz cdrom <path>/dev/hdb</path>, nagrywarkę <path>/dev/hdc</path>,
drugi dysk twardy <path>/dev/hdd</path> i nie posiadasz dysku SCSI,
urządzenie <path>/dev/hdd7</path> jest rozumiane jako <path>(hd1,6)</path>.
To może brzmi pokrętnie i w rzeczywistości jest pokrętne, lecz, jak się
niedługo przekonamy, GRUB oferuje mechanizm uzupełniania wiersza polecenia
klawiszem tab, co z pewnością jest wybawieniem dla tych, którzy mają
dużo dysków twardych, partycji i gubią się nieco w sposobie numeracji
używanym przez program GRUB.
</p>

<p>
Już wiesz, co Cię czeka, nadeszła pora zainstalować GRUB'a.
</p>

</body>
</subsection>
<subsection>
<title>Instalowanie GRUB'a</title>
<body>

<p>
Aby zainstalować program GRUB, używamy emerge. Użytkownicy architektury
x86 wybierają <c>grub</c>, dla AMD64 mamy <c>grub-static</c>:
</p>

<pre caption = "Instalowanie GRUB'a">
<comment>(Dla architektury x86:)</comment>
# <i>emerge --usepkg grub</i>

<comment>(Dla architektury AMD64:)</comment>
# <i>emerge --usepkg grub-static</i>
# <i>cp -Rpv /usr/share/grub/i386-pc/* /boot/grub</i>
</pre>

<p>
Aby zacząć konfigurować GRUB'a, piszemy <c>grub</c>. Zobaczysz prompt
<path>grub&gt;</path> oznaczający tryb poleceń. Teraz trzeba podawać
odpowiednie komendy by umieścić boot rekord GRUB'a na dysku twardym.
</p>

<pre caption = "Uruchomienie powłoki GRUB'a">
# <i>grub</i>
</pre>

<p>
W przykładowej konfiguracji planujemy zainstalować GRUB'a w taki sposób,
by czytał dalsze informacje z partycji startowej <path>/dev/hda1</path>,
a jego boot rekord znajdował się w MBR (master boot rekord), co spowoduje,
że pierwszą rzeczą jaką zobaczymy po uruchomieniu komputera będzie prompt
programu GRUB. Oczywiście jeśli nie naśladujesz wzorcowych ustawień, które
podajemy od początku przewodnika, odpowiednio zmodyfikuj ustawienia.
</p>

<p>
Funkcję kompletowania klawiszem tab wykorzystuje się z poziomu
powłoki GRUB'a. Na przykład, jeśli napiszesz "<c>root (</c>" i następnie wciśniesz
TAB, zobaczysz listę urządzeń (np <path>hd0</path>). Gdy wpiszesz
"<c>root (hd0,</c>" i użyjesz TAB, otrzymasz spis dostępnych do wyboru partycji
(np <path>hd0,0</path>).
</p>

<p>
Z pomocą uzupełniania klawiszem tab, ustawienie programu GRUB nie powinno
być już takie trudne. To co, zabieramy się za konfigurowanie GRUB'a ? :-)
</p>

<pre caption = "Instalowanie GRUB'a w MBR">
grub&gt; <i>root (hd0,0)</i>	<comment>(Podanie umiejscowienia partycji /boot)</comment>
grub&gt; <i>setup (hd0)</i>	<comment>(Instalacja GRUB'a w MBR)</comment>
grub&gt; <i>quit</i>			<comment>(Wyjście z powłoki GRUB'a)</comment>
</pre>

<note>
Jeżeli chcesz zainstalować GRUB'a na którejś z partycji zamiast w MBR,
zastąp polecenie <c>setup</c> w taki sposób, by poprowadziło do właściwego
urządzenia. Na przykłąd, jeśli chcemy zainstalować GRUB'a na <path>/dev/hda3</path>,
wtedy nasze polecenie zamienia się w <c>setup (hd0,2)</c>.
Zapewne niewiele osób zechce z tego skorzystać.
</note>

<p>
Choć program GRUB został zainstalowany, potrzeba jeszcze napisać plik konfiguracyjny,
by GRUB automatycznie bootował dopiero co stworzone jądro. Za pomocą <c>nano</c>
 (lub innego edytora) utwórz <path>/boot/grub/grub.conf</path>:
</p>

<pre caption = "Tworzenie pliku /boot/grub/grub.conf">
# <i>nano -w /boot/grub/grub.conf</i>
</pre>

<p>
Teraz zamierzamy wyredagować <path>grub.conf</path>. Poniżej
znajdziesz trzy propozycje pliku <path>grub.conf</path> odpowiadające
schematowi partycjonowania użytemu w tym przewodniku, z obrazem jądra
o nazwie <path>kernel-2.4.22</path>. Wyczerpująco opatrzymy komentarzami
tylko pierwszy <path>grub.conf</path>.
</p>

<ul>
  <li>
    Pierwszy <path>grub.conf</path> jest dla osób, które nie wykorzystały
    programu <c>genkernel</c> do budowania jądra
  </li>
  <li>
    Drugi <path>grub.conf</path> jest dla tych, którzy użyli programu
    <c>genkernel</c> z LiveCD (np. <c>genkernel</c> zainstalowany z pakietów
    GRP)
  </li>
  <li>
    Trzeci <path>grub.conf</path> jest dla osób, które pobrały program
    <c>genkernel</c> z sieci
  </li>
</ul>

<pre caption = "grub.conf dla nie używających genkernela">
<comment># Która pozycja ma być uruchamiana domyślnie. 0 oznacza pierwszą, 1 drugą itd</comment>
default 0
<comment># Ile sekund oczekiwać przed uruchomieniem pozycji domyślnej.</comment>
timeout 30
<comment># Ładniutki, tłuściutki obrazek na zaostrzenie apetytu :)</comment>
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux 2.4.22
<comment># Partycja na której znajduje się obraz jądra (lub system operacyjny) </comment>
root (hd0,0)
kernel (hd0,0)/kernel-2.4.22 root=/dev/hda3

<comment># Następne trzy linie są potrzebne tylko, gdy chcesz uruchamiać także Windows.</comment>
<comment># W tym przypadku, Windows mieści się na /dev/hda6.</comment>
title=Windows XP
root (hd0,5)
chainloader +1
</pre>

<pre caption = "grub.conf dla użytkowników genkernela GRP">
default 0
timeout 30
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux 2.4.22
root (hd0,0)
kernel (hd0,0)/kernel-2.4.22 root=/dev/hda3
initrd (hd0,0)/initrd-2.4.22

<comment># Tylko jeśli chcesz uruchamiać dwa systemy</comment>
title=Windows XP
root (hd0,5)
chainloader +1
</pre>

<pre caption = "grub.conf dla użytkowników genkernela spoza GRP">
default 0
timeout 30
splashimage=(hd0,0)/grub/splash.xpm.gz

title=Gentoo Linux 2.4.22
root (hd0,0)
kernel (hd0,0)/kernel-2.4.22 root=/dev/ram0 init=/linuxrc real_root=/dev/hda3
initrd (hd0,0)/initrd-2.4.22

<comment># Tylko, gdy chcesz uruchamiać dwa systemy</comment>
title=Windows XP
root (hd0,5)
chainloader +1
</pre>


<note>
Jeśli partycjonowanie wykonałeś inaczej i/lub używasz innego obrazu jądra,
dokonaj niezbędnych poprawek. Ważne jest, by wszystko, co dotyczy urządzenia
z GRUB'em (np. <path>(hd0,0)</path>) było względne w stosunku do punktu
montowania, a nie partycji root. Innymi słowy, <path>(hd0,0)/grub/splash.xpm.gz</path>
w rzeczywistości znaczy <path>/boot/grub/splash.xpm.gz</path>, gdyż <path>(hd0,0)</path>
to partycja <path>/boot</path>.
</note>

<p>
Jeśli chcesz przekazać jakieś dodatkowe opcje do jądra na starcie, po prostu
dopisz je na końcu polecenia kernel. W tym momencie już dodaliśmy jeden
parametr (<c>root=/dev/hda3</c> lub <c>real_root=/dev/hda3</c>),
ale bez problemu możesz wzbogacić polecenie o kolejne. Przykładowo
posłużymy się opcją <c>vga</c> dotyczącą bufora ramki, którą
przedyskutowaliśmy uprzednio:
</p>

<pre caption = "Dodawanie parametru vga jako parametru startowego dla jądra">
title=Gentoo Linux
  root (hd0,0)
  kernel (hd0,0)/kernel-2.4.22 root=/dev/hda3 vga=788
</pre>

<p>
Użytkownicy programu <c>genkernel</c> powinni wiedzieć, że jądra, które zbudowali,
używają tych samych opcji bootowania co LiveCD. Na przykład, jeśli masz urządzenia
SCSI, powinieneś dodać parametr <c>doscsi</c>.
</p>

<p>
A teraz zapisz plik <path>grub.conf</path> i opuść edytor. W tej chwili, GRUB jest
w pełni skonfigurowany i możesz przejść do <uri link="?part=1&amp;chap=10">
Instalacji Niezbędnych Narzędzi Systemowych</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternatywnie: Używanie LILO</title>
<subsection>
<title>Instalowanie LILO</title>
<body>

<impo>
LILO może być użyte tylko dla architektury x86 !
</impo>

<p>
LILO, czyli LInuxLOader, jest programem wypróbowanym i prawdziwym koniem pociągowym
wśród bootloaderów. Mimo to, brakuje mu niektórych cech posiadanych przez
program GRUB (co jest także powodem rosnącej popularności GRUB'a).
Fakt, że na niektórych systemach LILO działa, a GRUB nie, powoduje,
iż LILO jest ciągle w użyciu. Oczywiście nie jest to jedyny powód - niektórzy
po prostu znają LILO i chcą sie go trzymać. Tak czy inaczej, Gentoo obsługuje
obydwa a Ty właśnie wybrałeś LILO.
</p>

<p>
Instalacja LILO to pikuś; po prostu użyj <c>emerge</c>.
</p>

<pre caption = "Instalowanie LILO">
# <i>emerge --usepkg lilo</i>
</pre>

</body>
</subsection>
<subsection>
<title>Konfigurowanie LILO</title>
<body>

<p>
Aby skonfigurować LILO, musisz utworzyć <path>/etc/lilo.conf</path>. Odpal
ulubiony edytor (w tym przewodniku konsekwentnie używamy <c>nano</c>)
i stwórz plik.
</p>

<pre caption = "Tworzenie /etc/lilo.conf">
# <i>nano -w /etc/lilo.conf</i>
</pre>

<p>
Kilka paragrafów temu prosiliśmy Cię o zapamiętanie nazwy utworzonego obrazu jądra.
W naszym przykładowym <path>lilo.conf</path> zakładamy, że nazwą obrazu jest
<path>kernel-2.4.22</path>. Użyjemy w tym przykładzie uprzednio zaprezentowanego
schematu partycjonowania. Wyróżniamy trzy części:
</p>

<ul>
  <li>
    Jedną dla tych, którzy nie skorzystali z programu <c>genkernel</c> przy budowaniu jądra
  </li>
  <li>
    Inną dla użytkowników <c>genkernel'a</c> z GRP
  </li>
  <li>
    Ostatnią dla tych, którzy użyli najnowszej, pobranej z sieci wersji programu <c>genkernel</c>
  </li>
</ul>

<pre caption = "Przykładowy /etc/lilo.conf">
boot=/dev/hda             <comment># Instalacja LILO w MBR</comment>
prompt                    <comment># Dajemy użytkownikowi możliwość wyboru innej pozycji</comment>
timeout=50                <comment># Czekamy 5 sekund przed uruchomieniem domyślnej pozycji</comment>
default=gentoo            <comment># Kiedy oczekiwanie się zakończy, uruchamiamy pozycję "gentoo"</comment>
<comment># Tylko jeśli używasz bufora ramki. W przeciwnym wypadku usuń następującą linię:</comment>
vga=788                   <comment># Ustawienia framebuffera. Dopasuj wedle uznania.</comment>

<comment># Dla nie korzystajacych z genkernela</comment>
image=/boot/kernel-2.4.22
  label=gentoo            <comment># Nazwa, jaką mianujemy tę pozycję</comment>
  read-only               <comment># Zaczynamy z partycja root tylko do odczytu. Nie zmieniać!</comment>
  root=/dev/hda3          <comment># Umiejscowienie głównego systemu plików</comment>

<comment># Dla użytkowników genkernela z GRP</comment>
image=/boot/kernel-2.4.22
  label=gentoo
  read-only
  root=/dev/hda3
  initrd=/boot/initrd-2.4.22

<comment># Dla posiadaczy ostatniej wersji genkernela</comment>
image=/boot/kernel-2.4.22
  label=gentoo
  read-only
  root=/dev/ram0
  append="init=/linuxrc real_root=/dev/hda3"
  initrd=/boot/initrd-2.4.22

<comment># Następne dwie linie są podane na wypadek, gdybyś chciał uruchamiać Windows.</comment>
<comment># W tym przypadku, Windows mieści się na /dev/hda6.</comment>
other=/dev/hda6
  label=windows
</pre>

<note>
Jeśli używasz innego schematu partycjonowania i/lub obrazu jądra,
dokonaj niezbędnych poprawek.
</note>

<p>
Jakiekolwiek dodatkowe parametry startowe jądra dodajesz po słowie kluczowym
<c>append</c>. Jako przykład, podajemy opcję <c>acpi=off</c> służącą
do wyłączenia obsługi ACPI:
</p>

<pre caption = "Użycie append do podawania parametrów startowych">
image=/boot/kernel-2.4.22
  label=gentoo
  read-only
  root=/dev/hda3
  <i>append="acpi=off"</i>
</pre>

<p>
Użytkownicy programu <c>genkernel</c> powinni wiedzieć, że jądra, które zbudowali,
używają tych samych opcji bootowania co LiveCD. Na przykład, jeśli masz urządzenia
SCSI, powinieneś dodać parametr <c>doscsi</c>.
</p>

<p>
A teraz zapisz plik i opuść edytor. By zakończyć, musisz uruchomić
<c>/sbin/lilo</c> a wtedy LILO zastosuje ustawienia z <path>/etc/lilo.conf</path>
do Twojego systemu (tzn. zainstaluje się na dysk).
</p>

<pre caption = "Kończenie instalacji LILO">
# <i>/sbin/lilo</i>
</pre>

<p>
Możesz juz przejść do <uri link="?part=1&amp;chap=10">Instalacji Niezbędnych
Narzędzi Systemowych</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternatywnie: Użytkowanie programu aboot</title>
<body>

<impo>
aboot działa tylko na platformie alpha!
</impo>

<p>
Najpierw zainstalujemy program w systemie. Rzecz jasna, korzystamy z <c>emerge</c> :
</p>

<pre caption = "Instalowanie programu aboot">
# <i>emerge --usepkg aboot</i>
</pre>

<p>
Następny krok umożliwi start systemu z dysku. <c>aboot</c> zostanie uruchomiony
po włączeniu komputera. Jest to możliwe dzięki zapisaniu bootloadera
<c>aboot</c> na samym początku dysku.
</p>

<pre caption = "Włączenie startu z dysku">
# <i>swriteboot -f3 /dev/sda /boot/bootlx</i>
# <i>abootconf /dev/sda 2</i>
</pre>

<note>
Jeśli używasz innego schematu partycjonowania niż omawiany w tym rozdziale,
zmodyfikuj odpowiednio polecenia. Przeczytaj odpowiednie strony podręcznika
systemowego (<c>man 8 swriteboot</c> oraz <c>man 8 abootconf</c>).
</note>

<p>
Dodatkowo, możesz ułatwić start Gentoo poprzez ustawienie pliku
konfiguracyjnego programu aboot i zmiennej SRM boot_osflags.
Musisz upewnić się, że bootdef_dev jest także ustawiony poprawnie
(łatwiej to zrobić przy konsoli niż spod Linuksa).
</p>

<pre caption = "Optymalizowanie startu Gentoo">
# <i>echo '0:2/boot/vmlinux.gz root=/dev/sda2' &gt; /etc/aboot.conf</i>
# <i>echo -n 0 &gt; /proc/srm_environment/named_variables/boot_osflags</i>
# <i>echo -n '' &gt; /proc/srm_environment/named_variables/boot_file</i>
</pre>

<p>
Jeśli instalujesz poprzez port szeregowy, nie zapomnij umieścić
flagi startu z konsoli szeregowej w <path>aboot.conf</path>.
Plik <path>/etc/aboot.conf.example</path> zawiera dodatkowe informacje.
Oprócz tego, musisz zezwolić na logowanie poprzez port szeregowy:
</p>

<pre caption = "Zezwolenie na logowanie poprzez port szeregowy">
# <i>echo tts/0 &gt;&gt; /etc/securetty</i>
# <i>echo 's0:12345:respawn:/sbin/agetty 9600 tts/0 vt100' &gt;&gt; /etc/inittab</i>
</pre>

<p>
Aboot jest już skonfigurowany i gotowy do uzytku. Przejdź do
<uri link="?part=1&amp;chap=10">Instalacji Niezbędnych Narzędzi Systemowych</uri>.
</p>

</body>
</section>
<section>
<title>Alternatywnie: Użytkowanie MILO</title>
<body>

<impo>
MILO działa tylko na platformie alpha!
</impo>

<p>
Zanim przejdziesz dalej, zdecyduj, w jaki sposób chcesz uruchamiać
MILO. W tej części zakładamy, że chcesz utworzyć dyskietkę startową
z MILO. Jeśli chcesz bootować z partycji MS-DOS dysku twardego,
musisz odpowiednio poprawić polecenia.
</p>

<p>
Aby zainstalować MILO, używamy <c>emerge</c>.
</p>

<pre caption = "Instalowanie MILO">
# <i>emerge --usepkg milo</i>
</pre>

<p>
Po zainstalowaniu MILO, obrazy MILO powinny znajdować się
w <path>/opt/milo</path>. Polecenia poniżej utworzą dyskietkę
startową zawierającą MILO. Pamiętaj by użyć właściwego obrazu
dla Twojej architektury Alpha.
</p>

<pre caption = "Instalowanie MILO na dyskietce">
<comment>(Najpierw włóż pustą dyskietkę)</comment>
# <i>fdformat /dev/fd0</i>
# <i>mformat a:</i>
# <i>mcopy /opt/milo/milo-2.2-18-gentoo-ruffian a:\milo</i>
# <i>mcopy /opt/milo/linload.exe a:\lilnload.exe</i>
<comment>(Tylko jeśli posiadasz Ruffian:</comment>
  # <i>mcopy /opt/milo/ldmilo.exe a:\ldmilo.exe</i>
<comment>)</comment>
# <i>echo -ne '\125\252' | dd of=/dev/fd0 bs=1 seek=510 count=2</i>
</pre>

<p>
Twoja dyskietka startowa MILO jest już przygotowana do uruchomienia
Gentoo Linuksa. Być może musisz ustawić zmienne środowiskowe
ARCS Firmware by MILO się uruchamiało; wyjaśnienie znajdziesz pod adresem
<uri link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri> wraz z kilkoma przykładami
popularniejszych systemów i niektórymi komendami do zastosowania w trybie interaktywnym.
</p>

<p>
Pominiecie <uri link="http://tldp.org/HOWTO/MILO-HOWTO/">MILO-HOWTO</uri>
byłoby <e>złym</e> pomysłem.
</p>

<p>
Możesz przejść do <uri link="?part=1&amp;chap=10">Instalacji Niezbędnych Narzędzi
Systemowych</uri>.
</p>

</body>
</section>
<section>
<title>Alternatywnie: Używanie SILO</title>
<body>

<p>
Pora zainstalować i skonfigurować <uri link="http://www.sparc-boot.org">
SILO</uri>, Sparc Improved boot LOader.
</p>

<pre caption = "Instalowanie SILO">
# <i>emerge --usepkg silo</i>
</pre>

<p>
Teraz otwórz ulubiony edytor (my na przykład używamy <c>nano</c>)
i utwórz <path>/etc/silo.conf</path>.
</p>

<pre caption = "Tworzenie /etc/silo.conf">
# <i>nano -w /etc/silo.conf</i>
</pre>

<p>
Poniżej znajdziesz przykładowy plik <path>silo.conf</path>.
Używa on schematu partycjonowania, który występuje
wielokrotnie w tym podręczniku oraz obrazu jądra
<path>kernel-2.4.22</path>.
</p>

<pre caption = "Przykładowy /etc/silo.conf">
partition = 1         <comment># Partycja startowa</comment>
root = /dev/hda4      <comment># Partycja root</comment>
timeout = 15          <comment># Odczekaj 15 sekund przed uruchomieniem domyślnej sekcji</comment>

image = /boot/kernel-2.4.22
  label = linux
</pre>

<p>
Jeśli korzystasz z wzorcowego <path>silo.conf</path> dostarczonego przez Portage,
zakomentuj <e>wszystkie</e> linie, których nie potrzebujesz.
</p>

<p>
Jeśli masz oddzielną partycję <path>/boot</path>, skopiuj plik
konfiguracyjny do <path>/boot</path> i uruchom <c>/sbin/silo</c>:
</p>

<pre caption = "Tylko gdy posiadasz /boot na osobnej partycji">
# <i>cp /etc/silo.conf /boot</i>
# <i>/sbin/silo -C /boot/silo.conf</i>
/boot/silo.conf appears to be valid
</pre>

<p>
Jeśli Twój katalog <path>/boot</path> znajduje się na partycji root,
musisz tylko uruchomić <c>/sbin/silo</c>:
</p>

<pre caption = "Uruchomienie silo">
# <i>/sbin/silo</i>
/etc/silo.conf appears to be valid
</pre>

<p>
Teraz możesz przejść do <uri link="?part=1&amp;chap=10">Instalacji
Niezbędnych Narzędzi Systemowych</uri>.
</p>

</body>
</section>
<section>
<title>Alternatywnie: Używanie PALO</title>
<body>

<impo>
PALO obsługuje tylko architekturę HPPA!
</impo>

<p>
Bootloader na platformie PA-RISC nazywa się palo. Jego plik
konfiguracyjny to <path>/etc/palo.conf</path>. Tutaj masz przykład konfiguracji:
</p>

<pre caption = "przykładowy /etc/palo.conf">
--commandline=2/vmlinux root=/dev/sdb2 HOME=/
--recoverykernel=/vmlinux.old
--init-partitioned=/dev/sdb
</pre>

<p>
Pierwsza linia wskazuje palo lokalizację jądra i parametry startowe.
<c>2/vmlinux</c> oznacza jądro o nazwie <c>/vmlinux</c>
znajdujące się na drugiej partycji. Uważaj, ścieżka do jądra
jest czytana względem partycji, nie głównego katalogu.
</p>

<p>
Druga linia definiuje zapasowe jądro. Jeśli to jest Twoja pierwsza
instalacja i nie masz zapasowego kernela, zakomentuj ją. Trzecia
linia niesie informację, na którym dysku rezyduje palo.
</p>

<p>
Kiedy zakończysz konfigurowanie, po prostu uruchom <c>palo</c>.
</p>

<pre caption = "Aktywowanie konfiguracji PALO">
# <i>palo</i>
</pre>

<p>
Teraz możesz przejść do <uri link="?part=1&amp;chap=10">Instalacji Niezbędnych
Narzędzi Systemowych</uri>.
</p>

</body>
</section>
<section>
<title>Alternatywnie: Używanie yaBoot</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<impo>
yaBoot może być używany tylko na systemach klasy NewWorld PPC!
</impo>

<p>
Są dwa sposoby konfiguracji yaBoot. Możesz wykonać konfigurację
yaboot automatycznie za pomocą nowego i poprawionego narzędzia
<c>yabootconfig</c> zawartego w wersji <path>yaboot-1.3.8-r1</path>
i późniejszych. Jeśli z jakiegoś powodu nie chcesz uruchamiać
<c>yabootconfig</c> i tworzyć <path>/etc/yaboot.conf</path>
automatycznie, możesz najzwyczajniej wyedytować wzorcowy plik
już zainstalowany w systemie.
</p>

<ul>
  <li><uri link="#doc_chap8_sect2">Domyślnie: Użycie yabootconfig</uri></li>
  <li>
    <uri link="#doc_chap8_sect3">Alternatywnie: Ręczna konfiguracja yaBoot</uri>
  </li>
</ul>

</body>
</subsection>
<subsection>
<title>Domyślnie: Użycie yabootconfig</title>
<body>

<p>
<c>yabootconfig</c> automatycznie wykryje partycje na Twoim komputerze
i umożliwi uruchamianie wybranego z dwóch lub trzech systemów, którymi mogą
być Linux, Mac OS, and Mac OS X.
</p>

<p>
Przed użyciem <c>yabootconfig</c>, musisz mieć na dysku partycję bootstrap
oraz odpowiednie wpisy dotyczące partycji Linuksa w <path>/etc/fstab</path>.
Obydwa warunki powinny być już spełnione w poprzednich krokach.
Upewnij się, że masz zainstalowaną najnowszą wersję yaboot wykonując
polecenie <c>emerge --update yaboot</c>. Jest to wymagane, gdyż aktualna
wersja bedzie dostępna via Portage, ale może jej jeszcze nie być w plikach
stage.
</p>

<pre caption = "Instalowanie yaboot">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
Teraz wykonaj polecenie <c>yabootconfig</c>. Uruchomi się program
i potwierdzi lokalizację partycji bootstrap. Wciśnij <c>Y</c> jeśli wszystko
się zgadza. Jeśli jest inaczej, sprawdź dwa razy <path>/etc/fstab</path>.
yabootconfig przeskanuje Twoje ustawienia, utworzy
<path>/etc/yaboot.conf</path> i uruchomi <c>mkofboot</c>.
<c>mkofboot</c> służy do formatowania partycji bootstrap i umieszczenia
na niej pliku konfiguracyjnego yaboot.
</p>

<p>
Zweryfikuj zawartość <path>/etc/yaboot.conf</path>. Jeśli zmienisz
<path>/etc/yaboot.conf</path> (choćby ustawienia domyślnie startującego
OS), uruchom <c>ybin -v</c> aby zmiany odniosły skutek na partycji bootstrap.
</p>

<p>
Teraz przejdź do <uri link="?part=1&amp;chap=10">Instalacji Niezbędnych
Narzędzi Systemowych</uri>.
</p>

</body>
</subsection>
<subsection>
<title>Alternatywnie: Ręczna konfiguracja yaBoot</title>
<body>

<p>
Po pierwsze upewnij się, że masz zainstalowaną aktualną wersję
<c>yaboot</c>:
</p>

<pre caption = "Instalowanie yaboot">
# <i>emerge --usepkg --update yaboot</i>
</pre>

<p>
Poniżej znajdziesz kompletny plik <path>yaboot.conf</path>.
Dopasuj go wedle życzenia:
</p>

<pre caption = "/etc/yaboot.conf">
<comment>## /etc/yaboot.conf
##
## uruchom: "man yaboot.conf" by poznać szczegóły. Nie zmieniaj nic, jeśli nie musisz!!
## dodatkowe przykłady możesz obejrzeć w: /usr/share/doc/yaboot/examples
##
## W celu uruchamiania innych systemów, dodaj jedną lub więcej pozycji spośród:
## bsd=/dev/hdaX, macos=/dev/hdaY, macosx=/dev/hdaZ

## nasza partycja bootstrap:</comment>

boot=/dev/hda9

<comment>##hd: jest równoważne hda</comment>
device=hd:
partition=11

root=/dev/hda11
delay=5
defaultos=macosx
timeout=30
install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot

<comment>#################
## Ta część może być powielona, jeśli masz więcej niż jeden kernel lub zestaw
## parametrów startowych
#################</comment>
image=/boot/vmlinux
  label=Linux
  sysmap=/boot/System.map
  read-only
<comment>##################</comment>

macos=/dev/hda13
macosx=/dev/hda12
enablecdboot
enableofboot
</pre>

<p>
Gdy <path>yaboot.conf</path> jest ustawiony w sposób, który Cię zadowala,
uruchom <c>mkofboot -v</c> by zmiany odniosły skutek na partycji bootstrap.
<e>Nie zapomnij o tym!</e> Jeśli wszystko poszło po myśli i wprowadziłeś takie
same opcje jak w przykładzie powyżej, po restarcie ujrzysz proste menu z pięcioma
pozycjami. Dokonując w przyszlości poprawek uruchom tylko <c>ybin -v</c>
by zaktualizować partycje bootstrap - <c>mkofboot</c> używa się tylko
za pierwszym razem.
</p>

<p>
Więcej informacji o programie yaboot, uzyskasz pod adresem
<uri link="http://penguinppc.org/projects/yaboot">projektu yaboot</uri>.
Tymczasem przejdź do <uri link="?part=1&amp;chap=10">Instalacji
Niezbędnych Narzędzi Systemowych</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>Alternatywnie: BootX</title>
<body>

<impo>
BootX może być używany tylko na systemach klasy OldWorld PPC!
</impo>

<p>
Jeśli chcesz używać BootX, nie musisz na tym etapie robić nic.
Mimo tego, po restarcie trzeba bedzie ustawić co nieco
w panelu kontrolnym BootX (wewnątrz MacOS). Omówimy to
nieco później.
</p>

<p>
Tymczasem przejdź do <uri link="?part=1&amp;chap=10">Instalacji Niezbędnych
Narzędzi Systemowych</uri>.
</p>

</body>
</section>
<section>
<title>Alternatywnie: MIPS PROM</title>
<subsection>
<body>

<p>
MIPS nie wymaga instalacji bootloadera. MIPS PROM jest w stanie
uruchomić system, ale musisz zainstalować jądro jako opcję wykonalną.
</p>

<p>
Po pierwsze, zainstaluj <c>dvhtool</c>, który będzie potrzebny do skopiowania
jądra na SGI Volume Header.
</p>

<pre caption="Instalowanie dvhtool">
# <i>emerge dvhtool</i>
</pre>

<p>
Teraz przekopiuj kernel na SGI Volume Header. Domyślnie <c>dvhtool</c>
zakłada obecność SGI Volume Header na <path>/dev/sda</path>. Jeśli w tym
przypadku tak nie jest, (na przykład, gdy IRIX zainstalowany jest na
<path>/dev/sda</path> a Gentoo/MIPS na <path>/dev/sdb</path>),
musisz o tym poinformować <c>dvhtool</c> używając <c>-d &lt;device&gt;</c>.
</p>

<pre caption="Kopiowanie jądra na SGI Volume Header">
# <i>dvhtool --unix-to-vh &lt;kernel name in /boot&gt; &lt;name you want to give in volume header&gt;</i>
</pre>

<p>
Jeśli chcesz obejrzeć wszystkie dostępne wpisy wolumenu,
użyj <c>--print-volume-directory</c>:
</p>

<pre caption="Oglądanie dostępnych wpisów wolumenu">
# <i>dvhtool --print-volume-directory</i>
</pre>

<p>
Musisz zmodyfikować kilka opcji w MIPS PROM by system Gentoo/MIPS
był w stanie się uruchomić. Omówimy to później, po zakończeniu instalacji Gentoo.
</p>

<p>
Teraz przejdź do <uri link="?part=1&amp;chap=10">Instalowania Niezbędnych
Narzędzi Systemowych</uri>.
</p>

</body>
</subsection>
</section>
</sections>
