<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- Orig revision: 1.79 -->
<!-- Translator: rane <rane@gentoo.pl> -->
<!-- Title: Krótki kurs zabezpieczania Gentoo Linux -->
<!-- Status: Do korekty -->
<!-- $Header: /cvsroot/gentoo-doc-pl/trans/translated/gentoo-security.xml,v 1.77
2005/04/20 19:57:08 rane Exp $ -->

<guide link = "/doc/en/gentoo-security.xml">
<title>Gentoo Linux Security Guide</title>
<author title="Author">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
	<mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Editor">
  <mail link="krispykringle@gentoo.org">Dan Margolis</mail>
</author>

<abstract>
Dokument opisuje proces zabezpieczania Gentoo Linux.
</abstract>

<license/>

<version>0.4.47</version>
<date>2005-05-03</date>

<chapter>
<title>Wprowadzenie.</title>
<section>
<body>

<p>
Dokument przeznaczony jest dla osób używających Gentoo Linux w środowisku
serwerowym oraz dla wszystkich tych, którzy mają wrażenie, że przyda im się
nieco więcej bezpieczeństwa.
</p>

<note>
Osoby zainteresowane jeszcze staranniejszym zabezpieczeniem swojego systemu
powinny zajrzeć również na strony <uri
link="http://www.gentoo.org/proj/en/hardened/">Hardened Gentoo Project</uri>.
</note>

</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>Czynności przedinstalacyjne.</title>
<section>
<title>Fizyczne bezpieczeństwo.</title>
<body>

<p>
Nieważne jak wiele rozwiązań związanych z zabezpieczeniami się zaimplementuje,
wszystkie mogą zostać łatwo ominięte przez włamywacza mającego fizyczny dostęp
do komputera. Należy zatem zastosować serię środków uniemożliwiających taki
dostęp. Na przykład zamknięcie komputera w szafie uniemożliwi włamywaczowi jego
odłączenie od prądu, a zamknięcie obudowy na klucz uniemożliwi kradzież twardego
dysku. Aby uniemożliwić uruchomienie systemu z innego dysku i obejście
wszystkich zabezpieczeń logowania oraz tych związanych z prawami dostępu do
plików należy ustawić twardy dysk jako pierwsze i jedyne urządzenie uruchamialne
w BIOS-ie oraz zabezpieczyć dostęp do BIOS-u hasłem. Kolejną ważną czynnością
jest ustawienie hasła dla LILO lub GRUB-a, co uniemożliwi zalogowanie się z nich
do systemu w trybie single-user i w konsekwencji uzyskanie pełnego do niego
dostępu. Więcej informacji na ten  temat znajduje się w rozdziałach <uri
link="#passwording_GRUB">Ustawianie hasła dla GRUB</uri> i <uri
link="#passwording_LILO">Ustawianie hasła dla LILO</uri>.
</p>

</body>
</section>
<section>
<title>Planowanie usług i demonów.</title>
<body>

<p>
Na samym początku należy podjąć decyzję, które usługi będą uruchomione na danej
maszynie. Pozwoli to na lepsze zaplanowanie schematu podziału dysku na partycje.
Oczywiście nie jest to konieczne na sprzęcie przeznaczonym na desktop lub
dedykowany firewall. W takim przypadku można uruchomić <e>każdą</e> usługę,
no może poza demonem sshd.
</p>

<p>
Utworzenie listy z aktualnymi numerami wersji uruchomionych programów ułatwi
ich uaktualnianie gdy pojawią się informacje o błędach w jednym nich.
</p>

</body>
</section>
<section>
<title>Schematy partycjonowania.</title>
<body>

<p>
Zasady partycjonowania:
</p>

<ul>
<li>
Wszystkie katalogi w których użytkownicy będą mieli możliwość zapisywania plików
(np. <path>/home</path>, lub <path>/tmp</path>) powinny znajdować się na
osobnych partycjach używających quota. Zmniejsza to ryzyko zapełnienia całego
dostępnego na dysku miejsca. Portage używa <path>/var/tmp</path> do kompilowania
plików, więc ta partycja powinna być stosunkowo duża. 
</li>
<li>
Każdy katalog przeznaczony do instalowania oprogramowania spoza dystrybucji
powinien znajdować się na osobnej partycji. Zgodnie ze <uri
link="http://www.pathname.com/fhs/">standardem hierarchii plików</uri> katalogi
te to <path>/opt</path> lub <path>/usr/local</path>. Jeśli są na osobnych
partycjach nie zostaną wyczyszczone przy ponownej instalacji systemu.
</li>
<li>
Dla jeszcze większego bezpieczeństwa nie zmieniające się dane mogą zostać
zapisane na partycji podmontowanej tylko do odczytu. Jeśli administrator jest
typem paranoika może używać do tego celu nawet dysków CD-ROM. :]
</li>
</ul>

</body>
</section>
<section>
<title>Użytkownik root.</title>
<body>

<p>
root jest najważniejszą osobą w systemie. Jego konto nie powinno
być używane do niczego do czego nie jest niezbędnie potrzebne. Jeśli włamywacz
uzyska dostęp do tego konta to konieczna będzie ponowna instalacja całego
systemu.
</p>

<p>
Zasady postępowania z kontem roota:
</p>

<ul>
<li>
Należy utworzyć zwykłe konto użytkownika do codziennej pracy. Jeśli wymagane
jest częste przełączanie się na roota warto dodać to konto do grupy 'wheel'.
Umożliwi to korzystanie z polecenia <c>su</c>, które znacznie upraszcza
procedurę przełączania się na konto roota.
</li>
<li>
Nigdy nie należy uruchamiać serwera X, lub jakiejkolwiek aplikacji użytkowników
z przywilejami roota. Konto roota powinno być używane tylko wtedy, gdy jest to
niezbędne. Jeśli uruchamiana z normalnymi prawami aplikacja zawiera błąd to
włamywacz uzyska dostęp jedynie do zwykłego konta, jeśli uruchomi się ją na
prawach roota łobuz dostanie dostęp do całego systemu.
</li>
<li>
Należy używać absolutnych ścieżek do programów kiedy jest się zalogowanym jako
root (lub zawsze używać <c>su -</c>, które zastępuje zmienne środowiskowe
użytkownika tymi należącymi do roota, zmienna <c>PATH</c> roota powinna zawierać
jedynie chronione katalogi jak <path>/bin</path> i <path>/sbin</path>). Istnieje
możliwość oszukania roota i zmuszenia go do uruchomienia innej aplikacji niż
zamierzał. Jeśli <c>PATH</c> roota jest chroniona, lub root zawsze używa
absolutnych ścieżek nie ma możliwości by to się stało.
</li>
<li>
Jeśli użytkownik potrzebuje wpisać jako root tylko kilka wybranych komend
powinno się rozważyć użycie <c>sudo</c> zamiast przelogowywania się na konto
roota. Oczywiście należy zwracać baczną uwagę na to komu daje się dostęp do
<c>sudo</c>.
</li>
<li>
Nigdy nie należy zostawiać otwartego terminala z zalogowanym do niego rootem.
</li>
</ul>

<p>
Gentoo posiada kilka domyślnych zabezpieczeń przed zwykłymi użytkownikami,
którzy chcą używać polecenia <c>su</c> do przełączania się na konto roota. Domyślne
ustawienie PAM umożliwia korzystanie z takiego ułatwienia jedynie tym, którzy są
członkami grupy 'wheel'.
</p>

</body>
</section>
<section id = "security_policies">
<title>Polityka bezpieczeństwa.</title>
<body>

<p>
Istnieje kilka powodów dla których warto naszkicować politykę bezpieczeństwa dla
swojego systemu i sieci.
</p> 

<ul>
<li>
Dobra polityka bezpieczeństwa powinna dotyczyć całego systemu, a nie być jedynie
zbieraniną różnych jego właściwości. Na przykład administrator, który nie
przemyślał polityki bezpieczeństwa mógłby wyłączyć telnet, ponieważ umożliwia
przesyłanie niezaszyfrowanych haseł, ale pozostawić dostęp przez FTP, który
posiada te same słabości. Dobra polityka bezpieczeństwa umożliwia rozpoznanie
wartych i niewartych zastosowania środków bezpieczeństwa.
</li>
<li>
W celu diagnozowania problemów, przeprowadzania audytu czy wykrywania
włamań administrator jest zmuszony do przechwytywania ruchu w sieci,
przeglądania historii logowania i poleceń poszczególnych użytkowników, oraz
kontroli ich katalogów domowych. Jeśli nie poinforumuje o tym użytkowników
może mieć poważne problemy z prawem, Taka działalność może zostać uznana za
naruszenie ich prywatności i wpędzić go w spore kłopoty.
</li>
<li>
Bardzo często dużym zagrożeniem dla systemu są przejęte konta użytkowników.
Jeśli nie wytłumaczy się użytkownikom jak mają postępować (np. nie zabroni się
im przyklejania listy haseł na kartkach na biurku) zabezpieczanie ich kont
będzie bezcelowe.
</li>
<li>
Dobrze udokumentowany rozkład sieci i systemu pomoże osobom badającym system po
włamaniu w zidentyfikowaniu zarówno osoby włamywacza jak i sposobu w jaki
dokonał włamania. Polityka bezpieczeństwa powinna zawierać również informację,
że cały system jest prywatną siecią i każda nieautoryzowana próba dostępu jest
zabroniona, co później może ułatwić dochodzenie swoich praw po namierzeniu
włamywacza.
</li>
</ul>

<p>
Jak widać dobra polityka bezpieczeństwa jest bardzo przydatnym narzędziem.
</p>

<p>
Polityka powinna być pojedyńczym dokumentem, lub ich zbiorem, który opisuje całą
sieć oraz usługi przez nią zapewniane, dozwolone oraz zakazane czynności,
zwyczaje obowiązujące w sieci i tak dalej. Wszyscy użutkownicy powinni zapoznać
się z tym dokumentem oraz być powiadamiani o wszelkich dokonywanych w nim
zmianach, które powinno się nanosić, aby dokument był aktualny. Warto pomóc
użytkownikom w zrozumieniu całej polityki oraz wytłumaczyć dlaczego należy jej
przestrzegać, a także jasno zaznaczyć jakie poniosą konsekwencje jeśli postąpią
wbrew niej (dokument powinien zawierać wszystkie te informacje). Należy
przypominać im o tym co najmniej raz w roku, ponieważ polityka może się zmieniać
(a także, żeby nie zapomnieli, że taki dokument istnieje).
</p>

<note>
Dokumenty te powinny być zrozumiałe, ale warto również zachować maksymalną
precyzję w każdym z poruszanych tematów.
</note>

<p>
Każda polityka bezpieczeństwa powinna (co najmniej) poruszać następujące tematy:
</p>

<ul>
<li>Właściwe postępowanie.</li>
<li>
  <ul>
  <li>Wygaszacze ekranu.</li>
  <li>Sposób postępowania z hasłami.</li>
  <li>Zasady pobierania i instalowania programów.</li>
  <li>Informację o tym, że działania użytkowników są monitorowane.</li>
  <li>Informacje o oprogramowaniu antywirusowym.</li>
  </ul>
</li>
<li>
Sposób postępowania z krytycznymi informacjami.
</li>
<li>
  <ul>
  <li>Czyszczenie biurka oraz zamykanie na klucz informacji utajnionych.</li>
  <li>Wyłączanie komputera przed wyjściem.</li>
  <li>Używanie szyfrowania.</li>
  <li>Sposób postępowania z kluczami zaufanych współpracowników.</li>
  <li>Sposób postępowania z poufnymi danymi podczas podróży.</li>
  </ul>
</li>
<li>Sposób postępowania ze sprzętem komputerowym podczas podróży.
  <ul>
  <li>
Postępowanie z laptopami w czasie podróży i pobytu w hotelach.
  </li>
  </ul>
</li>
</ul>

<p>
Różni użytkownicy zapewne będą posiadać różny zakres dostępu, w polityce warto
uwzględnić wszystkie przypadki.
</p>

<p>
Polityka bezpieczeństwa ma tendencję do nadmiernego rozrastania się, co może
prowadzić do przeoczenia najważniejszych informacji. Ponadto wersja dokumentu 
dla pracowników IT może zawierać poufne informacje, które nie powinny być znane
wszystkim użytkownikom. W związku z tym warto podzielić całość na serię
mniejszych dokumentów, np. dotyczących osobno: haseł, poczty, zdalnego dostępu
itd.
</p>

<p>
Przykładowe polityki bezpieczeństwa można znaleźć na stronach
<uri
link="http://www.sans.org/resources/policies/">The SANS Security Policy
Project</uri>. Dla małych sieci, które nie potrzebują tak rozbudowanych
opracowań powinny wystarczyć polityki takie jak ta pod adresem <uri
link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">Site Security
Handbook</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Uszczelnianie systemu podczas i tuż po instalacji.</title>
<section>
<title>Flagi USE.</title>
<body>

<p>
Plik <path>make.conf</path> zawiera zdefiniowane przez użytkownika flagi USE, a
w pliku <path>/etc/make.profile/make.defaults</path> znajduję się te wybrane
jako domyślne dla Gentoo. Związek z tematem tego przewodnika mają flagi
<c>pam</c> (Pluggable Authentication Modules), <c>tcpd</c> (TCP wrappers) i
<c>ssl</c> (Secure Socket Layer). Wszystkie są włączane w domyślnej
konfiguracji.
</p>

</body>
</section>
<section id = "passwording_GRUB">
<title>Ochrona hasłem w GRUB.</title>
<body>

<p>
Istnieją dwa sposoby zabezpieczenia tego bootloadera hasłem. Pierwszy przy użyyciu
otwartego tekstu, a drugi z hasłem zaszyfrowanym przy pomocy algorytmu md5+salt.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password zmień_mnie
</pre>

<p>
Taki wpis ustala hasło na ciąg znaków <c>zmień_mnie</c>. Jeśli hasło nie
zostanie wpisane przy starcie systemu, GRUB użyje domyślnych ustawień.
</p>

<p>
Przed ustawieniem hasła w postaci md5 trzeba je zaszyfrować do formatu takiego
jak ten używany w pliku <path>/etc/shadow</path>. Więcej informacji można
znaleźć w dokumencie <c>man crypt</c>. Zaszyfrowane hasło <e>zmień_mnie</e> ma
taką postać: <c>4ff4d55e97d977e3b9d04b5418426403</c>.
</p>

<p>
Zaszyfrowania hasła możesz dokonać bezpośrednio z powłoki GRUB-a:
</p>

<pre caption="md5crypt w powłoce grub'a">
#<i>/sbin/grub</i>

GRUB version 0.92 (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported. For the first word, TAB lists
     possible command completions. Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>**********</i>
<comment>(Wpisujemy zmień_mnie)</comment> 
Encrypted: 4ff4d55e97d977e3b9d04b5418426403.

grub> <i>quit</i>
</pre>

<p>
Następnie należy wyciąć zaszyfrowane hasło i wkleić je do pliku
<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5 
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
Pięciosekundowe opóźnienie jest przydatne przy zdalnej administracji systemem,
kiedy chcemy mieć możliwość uruchomienia systemu bez bezpośredniego do niego
dostępu. Więcej informacji o hasłach w GRUB można uzyskać wpisując polecenie
<c>info grub</c>.
</p>

</body>
</section>
<section id = "passwording_LILO">
<title>Ochrona hasłem w LILO.</title>
<body>

<p>
LILO również posiada dwie metody postępowania z hasłami: globalną oraz osobną
dla każdego obrazu, niestety nie ma możliwości ich zaszyfrowania.
</p>

<p>
Globalne hasło ustawia się na samej górze pliku konfiguracyjnego, ma ono
zastosowanie dla każdego obrazu jądra:
</p>

<pre caption="/etc/lilo.conf">
password=zmień_mnie
restricted 
delay=3
</pre>

<p>
Poniżej znajduje się przykład ustawienia hasła dla określonego obrazu:
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage 
      read-only 
      password=zmień_mnie
      restricted
</pre>

<p>
Jeśli nie dopiszemy opcji <c>restricted</c> będziemy za każdym razem pytani o
hasło.
</p>

<p>
Żeby zastosować zmiany należy uruchomić <c>/sbin/lilo</c>.
</p>

</body>
</section>
<section>
<title>Ograniczanie dostępu do konsoli.</title>
<body>

<p>
W pliku <path>/etc/securetty</path> można skonfiguować te urządzenia
<c>tty</c> (terminale), na których będzie mógł się logować root.
</p>

<p>
Zalecamy zakomentowanie wszystkich linii poza <c>vc/1</c>. Spowoduje to, że root
będzie mógł być zalogowany tylko raz i tylko na jednym terminalu.
</p>

<note>
Użytkownicy z grupy 'wheel' wciąż będą mogli stawać się rootem przy pomocy
polecenia <c>su -</c> na innych terminalach.
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Dokładniejsze logowanie.</title>
<section>
<body>

<p>
Aby wychwycić wszystkie ostrzeżenia i błędy wskazujące na próby ataku należy
włączyć dodatkowe usługi logowania. Włamywacze zwykle skanują i wypróbowują
system przed atakiem.
</p>

<p>
Ważną rzeczą jest również to, by logi były łatwe w zarządzaniu i
przeglądaniu. Gentoo podczas instalacji umożliwia wybranie jednego z trzech
programów logujących.
</p>

</body>
</section>
<section>
<title>Logowanie: Syslogd.</title>
<body>

<p>
Syslogd jest najpopularniejszym loggerem dla systemów Linux i Unix. Nie daje
możliwości rotowania logów. Można to sobie jednak zrekompensować używając
programu <path>/usr/sbin/logrotate</path>, warto dopisać go np. w demonie cron
(plik konfiguracyjny logrotate to <path>/etc/logrotate.conf</path>).
Częstotliwość rotacji logów będzie uzależniona od obciążenia systemu.
</p>

<p>
Poniżej znajduje się standardowy plik <path>syslog.conf</path> do którego
wprowadzono kilka pożytecznych zmian. Odkomentowano linie dotyczące <c>crona</c> i
<c>tty</c> oraz dodano opcję wysyłania logów na zdalny serwer. Żeby jeszcze
bardziej zwiększyć bezpieczeństwo, można skonfigurować program, tak aby
zapisywał logi w dwóch różnych miejscach.
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf	 Configuration file for syslogd.
#
#			For more information see syslog.conf(5)
#			manpage.
#			This is from Debian, we are using it for now
#			Daniel Robbins, 5/15/99

#
# First some standard logfiles.  Log by facility.
#

auth,authpriv.*			/var/log/auth.log
*.*;auth,authpriv.none		-/var/log/syslog
cron.*			       /var/log/cron.log
daemon.*			-/var/log/daemon.log
kern.*				-/var/log/kern.log
lpr.*				-/var/log/lpr.log
mail.*				/var/log/mail.log
user.*				-/var/log/user.log
uucp.*				-/var/log/uucp.log
local6.debug			/var/log/imapd.log

#
# Logging for the mail system. Split it up so that
# it is easy to write scripts to parse these files.
#
mail.info			-/var/log/mail.info
mail.warn			-/var/log/mail.warn
mail.err			/var/log/mail.err

# Logging for INN news system
#
news.crit			/var/log/news/news.crit
news.err			/var/log/news/news.err
news.notice			-/var/log/news/news.notice

#
# Some `catch-all' logfiles.
#
*.=debug;\
	auth,authpriv.none;\
	news.none;mail.none	-/var/log/debug
*.=info;*.=notice;*.=warn;\
	auth,authpriv.none;\
	cron,daemon.none;\
	mail,news.none		-/var/log/messages

#
# Emergencies and alerts are sent to everybody logged in.
#
*.emerg				*
*.=alert			*

#
# I like to have messages displayed on the console, but only on a virtual
# console I usually leave idle.
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

#Setup a remote logging server
*.*			   @logserver

# The named pipe /dev/xconsole is for the `xconsole' utility.  To use it,
# you must invoke `xconsole' with the `-file' option:
# 
#    $ xconsole -file /dev/xconsole [...]
#
# NOTE: adjust the list below, or you'll go crazy if you have a reasonably
#      busy site..
#
#daemon.*,mail.*;\
#	news.crit;news.err;news.notice;\
#	*.=debug;*.=info;\
#	*.=notice;*.=warn	|/dev/xconsole

local2.*		--/var/log/ppp.log
</pre>

<p>
Włamywacze zwykle próbują wyczyścić swoje ślady poprzez wyedytowanie lub
skasowanie logów. Można im to utrudnić ustawiając zdalne logowanie na innych
komputerach. Więcej informacji o syslogd znajduje się w <c>man syslog</c>.
</p>

</body>
</section>
<section>
<title>Metalog.</title>
<body>

<p>
<uri link="http://metalog.sourceforge.net">Metalog</uri> Franka Dennisa nie ma
możliwości logowania na zdalnym serwerze. Ma za to sporą przewagę jeśli chodzi o
elastyczność i wydajność logowania. Może logować nazwę programu, priorytet i
wiele innych informacji. Daje możliwość korzystania z wyrażeń regularnych oraz
uruchamiania skryptów w przypadku wystąpienia w logu określonego ciągu znaków.
Bardzo przydaje się to do błyskawicznego wykonywania niezbędnych działań w
przypadku gdy dzieje się coś złego.
</p> 

<p>
Zwykle wystarcza domyślna konfiguracja. Aby być powiadamianym e-mailem
za każdym razem gdy wystąpi błąd przy wpisywaniu hasła można użyć jednego z
następujących skryptów:
</p>

<p>
Dla postfix:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh dla postfix">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
Dla qmail:
</p>

<pre caption="/usr/local/sbin/mail_pwd_failures.sh dla qmail">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2) 
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
Aby skrypt zadziałał należy mu nadać prawa wykonywalności poprzez wpisanie
<c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c>.
</p>

<p>
Następnie należy odkomentować linię "Password failures" w pliku
<path>/etc/metalog/metalog.conf</path>:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Syslog-ng.</title>
<body>

<p>
Syslog-ng posiada te same funkcje co syslog i metalog, jednak z małymi
różnicami. Może filtrować wiadomości zależnie od poziomu i zawartości (jak
metalog), umożliwia zdalne logowanie (jak syslog), dobrze współpracuje z
rozmaitymi plikami, tak jak syslogd (nawet ze strumieniami z Solarisa) potrafi
wyświetlać logi na tty, wykonywać programy i może pełnić funkcje serwera
logów. Jest najlepszym dostępnym programem tego typu i jakby tego było mało
posiada jeszcze najszersze możliwości konfiguracyjne.
</p>

<p>
Poniżej znajduje się standardowy plik konfiguracyjny na który naniesiono kilka
drobnych poprawek.
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

#source where to read log
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

#define destinations
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#create filters
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) 
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

#connect filter and destination
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

#default log
log { source(src); destination(console_all); };
</pre>

<p>
Konfiguracja syslog-ng jest dość łatwa, ale z powodu ogromnych rozmiarów całego
pliku łatwo przegapić coś ważnego. Autor wciąż obiecuje dodatkowe opcje, jak na
przykład szyfrowanie, uwierzytelnianie, kompresja czy kontrola MAC (Mandatory Access
Control). Z tymi opcjami program będzie idealnym narzędziem do logowania ruchu
sieciowego, bo uniemożliwi włamywaczom szpiegowanie logów.
</p>

<p>
Ogromną zaletą syslog-ng jest również to, że nie musi być uruchamiany z prawami
roota.
</p>

</body>
</section>
<section>
<title>Analiza logów przy pomocy logcheck.</title>
<body>

<p>
Oczywiście uniemożliwienie dostępu do logów to tylko połowiczne zwycięstwo.
Aplikacje takie jak logcheck znacznie ułatwiają ich codzienną analizę. Logcheck
to skrypt powiązany z plikiem binarnym o nazwie <c>logtail</c>, który jest
zwykle uruchamiany z demona cron i dzięki zestawowi prostych reguł sprawdza logi
pod kątem występowania podejrzanych wyrażeń. Jeśli coś takiego wystąpi wysyła
e-mail na skrzynkę roota.
</p>

<p>
Logchek i logtail są częścią pakietu <c>app-admin/logsentry</c>.
</p>

<p>
Logcheck do filtrowania ważnych wpisów w logach używa informacji z czterech
plików. Te pliki to <path>logcheck.hacking</path>, który zawiera znane
wiadomości opisujące atak, <path>logcheck.violations</path>, który zawiera
wzory naruszeń bezpieczeństwa, <path>logcheck.violations.ignore</path> z
informacjami pozwalającymi na zdefiniowanie często występujących, omyłkowo
branych za ataki wpisów w logach, oraz <path>logcheck.ignore</path>, który
pozwala na ich zignorowanie.
</p>

<warn>
Nigdy nie należy zostawiać pliku <path>logcheck.violations.ignore</path>
pustego. Logcheck używa programu <c>grep</c> do analizy logów, a niektóre jego
wersje mogą nie zadziałać poprawnie w takim wypadku i wszystkie naruszenia
ochrony zostaną zignorowane.
</warn>

<!-- FIXME: Might want to add more details on logcheck here...I have to install
it on Gentoo to figure out how it's configured! -->

</body>
</section>
</chapter>
<chapter>
<title>Montowanie partycji.</title>
<section>
<body>

<p>
Podczas montowania partycji <c>ext2</c>, <c>ext3</c> lub <c>reiserfs</c> mamy do
dyspozycji szereg ważnych z punktu widzenia bezpieczeństwa opcji. Są to:
</p>

<ul>
<li>
  <c>nosuid</c> - ignoruje wszystkie bity SUID, przez co wszystkie pliki z nimi
  będą traktowane jakby ich nie miały.
</li>
<li>
  <c>noexec</c> - uniemożliwia uruchomienie jakiegokolwiek programu z tej
  partycji.
</li>
<li>
  <c>nodev</c> - ignoruje urządzenia.
</li>
</ul>

<p>
Niestety te ustawienia można w łatwy sposób obejść poprzez użycie
pośredniej ścieżki. Mimo wszystko jednak ustawienie <path>/tmp</path> na
noexec uniemożliwi wykonanie większości exploitów zaprojektowanych tak, aby
zostały wykonane właśnie tam.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
Przełączenie <path>/tmp</path> w tryb <c>noexec</c> uniemożliwi
prawidłowe wykonanie niektórych skryptów.
</warn>

<note>
Więcej informacji o quotach znajduje się w <uri
link="#doc_chap6_sect3">sekcji dotyczącej quota</uri>.
</note>

<note>
Osobiście nie ustawiam <path>/var</path> jako <c>noexec</c> i <c>nosuid</c>,
nawet jeśli żadne pliki nie są normalnie stamtąd wykonywane. Powodem tego jest
fakt, że w <path>/var/qmail</path> mam zainstalowany qmail, który musi mieć
możliwość uruchomienia się z bitem SUID. Partycję <path>/usr</path> przestawiam
na read-only, ponieważ nigdy nic tam nie zapisuję, chyba, że akurat uaktualniam
Gentoo. W takich wypadkach przemontowuję tą partycję w tryb do zapisu,
uaktualniam system i znów przestawiam ją na 'tylko do odczytu'.
</note>

<note>
Nawet jeśli nie używa się qmail, Gentoo wciąż będzie potrzebowało możliwości
uruchamiania programów w <path>/var/tmp</path> ponieważ są tam tworzone pliki
ebuild. Można zmienić tą ścieżkę jeśli koniecznie chce się montować
<path>/var</path> jako <c>noexec</c>.
</note>

</body>
</section>
</chapter>
<chapter>
<title>Ograniczanie możliwości użytkowników i grup.</title>
<section id = "limits_conf">
<title>/etc/security/limits.conf</title>
<body>

<p>
Kontrola użycia zasobów jest bardzo efektywnym sposobem zapobiegania lokalnym
atakom typu "Denial of Service". Możemy też przy okazji również nałożyć
restrykcje dla maksymalnej dopuszczalnej ilości zalogowań dla użytkowników oraz
grup.
</p>

<pre caption="/etc/security/limits.conf">
*    soft core 0
*    hard core 0
*    hard nproc 15
*    hard rss 10000
*    -	  maxlogins 2
@dev hard core 100000
@dev soft nproc 20
@dev hard nproc 35
@dev -	  maxlogins 10
</pre>

<p>
Zamiast ustawiania wartości <c>nproc</c> lub <c>maxlogins</c> na 0
należy rozważyć całkowite usunięcie takiego użytkownika. W powyższym
przykładzie ustawiliśmy grupie <c>dev</c> ilość procesów, plików core oraz
wartość <c>maxlogins</c>. Reszta to wartości domyślne.
</p>

<note>
<path>/etc/security/limits.conf</path> jest częścią pakietu PAM i ma
zastosowanie wyłącznie dla pakietów go używających.
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
Plik <path>/etc/limits</path> jest bardzo podobny do pliku
<path>/etc/security/limits.conf</path>. Jedyne różnice to format pliku oraz
to, że ma on zastosowanie dla użytkowników, a nie dla grup. Jego przykładowa
konfiguracja wygląda tak:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
Definiujemy tu domyślne ustawienia dla użytkownika kn. Plik ten jest
częścią pakietu sys-apps/shadow. Nie ma tu sensu ustawiać czegokolwiek jeśli nie
skonfigurowano prawidłowo PAM, lub całkiem ją wyłączono w pliku
<path>make.conf</path>.
</p>

</body>
</section>
<section>
<title>Quota.</title>
<body>

<warn>
Należy upewnić się, że system plików na którym się pracuje posiada wsparcie dla
quota. Żeby używać ich na ReiserFS trzeba nałożyć na kernel łatkę <uri link =
"ftp://ftp.namesys.com/pub/reiserfs-for-2.4/testing/quota-2.4.20">Namesys</uri>.
Narzędzia użytkownika są dostępne na stronach <uri link =
"http://www.sf.net/projects/linuxquota/">Projektu DiskQuota dla Linux</uri>.
Spowoduje to, że quoty będą działać, ale nie oznacza, że nie przysporzą żadnych
problemów.
</warn>

<p>
Umieszczenie quoty na systemie plików nałoży ograniczenie w użyciu przestrzeni
dyskowej zarówno przez grupy jak i przez użytkowników. Quoty włącza się w
jądrze, a następnie dodaje je do punktu montowania w pliku
<path>/etc/fstab</path>. Opcja w konfiguracji kernela, które je włącza to <c>File
systems-&gt;Quota support</c>. Należy zaznaczyć wymagane opcje, przebudować
jądro, a następnie przy jego pomocy uruchomić system.
</p>

<p>
Zaczniemy od zainstalowania quota przy pomocy polecenia <c>emerge quota</c>.
Następnie zmodyfikujemy plik <path>/etc/fstab</path> dodając tam <c>usrquota</c>
i <c>grpquota</c> dla partycji, na których chcemy ograniczać użycie dysku.
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
Na każdej partycji na której uaktywniono quoty należy stworzyć pliki quota
(<path>quota.user</path> i <path>quota.group</path>) oraz umieścić je w katalogu
głównym każdej partycji.
</p>

<pre caption="Tworzenie plików quota">
# <i>touch /tmp/aquota.user</i>
# <i>touch /tmp/aquota.group</i>
# <i>chmod 600 /tmp/aquota.user</i>
# <i>chmod 600 /tmp/aquota.group</i>
</pre>

<p>
Trzeba powtórzyć te czynności osobno dla każdej partycji na której chce się
używać quota. Po skonfigurowaniu wszystkich plików dodajemy skrypt
<c>quota</c> na runlevel o nazwie boot.
</p>

<pre caption="Dodawanie skryptu quota do runlevelu boot">
# <i>rc-update add quota boot</i>
</pre>

<p>
Następnie konfigurujemy system tak, żeby sprawdzał quoty raz w tygodniu. Robimy
to dodając następującą linię do pliku <path>/etc/crontab</path>:
</p>

<pre caption="Dodawanie sprawdzania quota w crontabie">
0 3 * * 0 /usr/sbin/quotacheck -avug.
</pre>

<p>
Po ponowym uruchomieniu komputera przychodzi pora na skonfigurowanie quota dla
poszczególnych użytkowników i grup. Polecenie <c>edquota -u kn</c> otworzy
edytor zdefiniowany zmienną $EDITOR (domyślnie jest to nano) i pozwoli
wyedytować quota dla użytkownika kn. Polecenie <c>edquota -g</c> robi to samo
dla grup.
</p>

<pre caption="Ustawianie quota dla użytkownika kn">
Quotas for user kn: 
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500) 
	 inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
Aby uzyskać więcej informacji należy zapoznać się z dokumentami <c>man
edquota</c> i <uri link="http://www.tldp.org/HOWTO/mini/Quota.html">Quota mini
howto</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>
	    
<p>
Jeśli w polityce bezpieczeństwa założono, że użytkownicy powinni
co tydzień zmieniać hasło trzeba zmienić wartość zmiennej <c>PASS_MAX_DAYS</c>
na 14 oraz zmiennej <c>PASS_WARN_AGE</c> na 7. Zalecamy częste zmienianie haseł
ponieważ metodami brute force można złamać każde z nich, jeśli tylko ma się dość
dużo czasu. Ponadto polecamy ustawienie zmiennej <c>LOG_OK_LOGINS</c> na 'yes'.
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
Plik <path>login.access</path> także jest częścią pakietu sys-apps/shadow.
Daje możliwość skonfigurowania tabeli dostępu do logowania. Dzięki tej tabeli
można decydować czy ktoś będzie mógł się zalogować na podstawie swojej
nazwy użytkownika, przynależności do grupy czy nazwy hosta. Domyślnie taką
możliwość mają wszyscy użytkownicy w systemie, więc plik ten zawiera jedynie
zakomentowane przykładowe wartości ustawień. Niezależnie od tego czy
konfigurujemy serwer czy stację roboczą warto zablokować dostęp do konsol
wszystkim poza administratorami.
</p>

<note>
Te ustawienia nie dotyczą roota.
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
Należy zachować ostrożność przy tym ustawieniu. Zły wpis skończy się utratą
dostępu do konta root i możliwości administrowania komputerem.
</impo>

<note>
Ustawienie te nie mają wpływu na SSH, ponieważ SSH nie używa domyślnie
<c>/bin/login</c>. Możemy jednak analogicznie ustawić SSH, dodając linię
<c>UseLogin yes</c> w <path>/etc/ssh/sshd_config</path>.
</note>

<p>
Takie ustawienie umożliwi zalogowanie się jedynie członkom grupy wheel z domeny
gentoo.org. Może jest to dość paranoiczne podejście, lepiej jednak być trochę
"za bardzo" zabezpieczonym niż później żałować.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Prawa do plików.</title>
<section>
<title>Dostępne do odczytu dla wszystkich.</title>
<body>

<p>
Zwykli użytkownicy nie powinni mieć dostępu do plików konfiguracyjnych i
zawierających hasła. Jeśli włamywaczowi uda się wykraść hasła z bazy danych lub
strony internetowej to będzie mógł podmienić albo nawet usunąć nasze pliki.
Właśnie to jest powodem, dla którego warto uważnie ustawić prawa do wszystkich
ważnych plików. Jeśli jest się pewnym, że z danego pliku będzie korzystał
wyłącznie root należy ustawić jego prawa na <c>0600</c> i przypisać plik
odpowiedniemu użytkownikowi przy pomocy polecenia <c>chown</c>.
</p>

</body>
</section>
<section>
<title>Dostępne do zapisu dla wszystkich.</title>
<body>

<pre caption="Znajdowanie takich plików i katalogów">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \ 
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \ 
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
Polecenie to utworzy listę plików z prawami do zapisu dla wszystkich
użytkowników lub grup. Należy sprawdzić prawa, a następnie usunąć zapisywalność
przy pomocy polecenia <c>/bin/chmod o-w</c> dla każdego z plików.
</p>

</body>
</section>
<section>
<title>Pliki z bitami SUID i SGID.</title>
<body>

<p>
Pliki z ustawionymi bitami SUID i SGID uruchamiane są zawsze z prawami dostępu
swojego <e>właściciela</e>, a nie z prawami osoby je uruchamiającej. Normalnie
bity te są ustawiane na programach, które muszą być uruchamiane z prawami roota
aby mogły wykonywać swoją pracę. Jeśli taki plik zawiera błąd może spowodować
kompromitację lokalnego konta root. W związku z takim niebezpieczeństwem należy
za wszelką cenę unikać ustawiania tych bitów. Jeśli któryś z takich plików nie
jest używany wykonujemy na nim polecenie <c>chmod 0</c> lub odmergowujemy pakiet
do którego należy (pakiety do którego należą dane pliki wyszukujemy przy pomocy
polecenia <c>equery</c>; jeśli nie ma takiego polecenia należy zainstalować pakiet
gentoolkit). W każdym innym wypadku należy użyć polecenia <c>chmod -s</c> do
zdjęcia bitu SUID. 
</p>


<pre caption="Znajdowanie plików z bitem SUID">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \ 
   -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
To polecenie utworzy plik z listą wszystkich programów, które mają ustawione
bity SUID i SGID.
</p>

<pre caption="Lista plików binarnych z suidem">
bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
Domyślnie Gentoo nie zawiera wielu plików SUID (chociaż ich ilość zależy od tego
jakie programy są zainstalowane), ale istnieje również możliwość, że otrzymamy
listę równie długą jak ta powyżej. Większość komend nie powinna być uruchamiana
przez zwykłych użytkowników z prawami roota. Polecamy zdjęcie bitów SUID z
programów <c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>,
<c>chsh</c>, <c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> i
<c>traceroute</c>. Dokonuje się tego przy pomocy polecenia <c>chmod -s</c>. Nie
należy usuwać tego bitu z <c>su</c>, <c>qmail-queue</c> czy <c>unix_chkpwd</c>.
Usunięcie setuid z tych plików spowoduje utratę możliwości przełączania się na
konto superużytkownika czy otrzymywania poczty. Usuwając SUID odbieramy zwykłemu
użytkownikowi (lub włamywaczowi) możliwość uzyskania dostępu do konta roota
przez któryś z tych plików.
</p>

<p>
Jedynymi plikami z SUID w moim systemie są <c>su</c>, <c>passwd</c>,
<c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> i <c>pwdb_chkpwd</c>.
Każdy kto używa serwera X może potrzebować jeszcze kilku, ponieważ serwer
korzysta czasem z rozszerzonego dostępu, oferowanego przez bity SUID.
</p>

</body>
</section>
<section>
<title>Twarde dowiązania do plików binarnych z SUID/SGID.</title>
<body>

<p>
Plik można uznać za skasowany tylko wtedy gdy nie istnieją żadne na niego
wskazujące odnośniki. Może to wydawać się dziwne, ale na przykład plik
<path>/usr/bin/perl</path> jest wyłącznie odnośnikiem do inody gdzie znajdują
się właściwe dane. Do pliku może istnieć nieskończenie duża ilość dowiązań i
dopóki wszystkie nie zostaną skasowane plik wciąż istnieje.
</p>

<p>
Jeśli użytkownicy posiadają dostęp do partycji nie zamontowanej z opcjami
<c>nosuid</c> i <c>noexec</c> (na przykład gdy <path>/tmp</path>,
<path>/home</path>, lub <path>/var/tmp</path> nie znajdują się na osobnych
partycjach) należy się upewnić, że nie będą mieli możliwości utworzenia twardego
dowiązania do plików binarnych i korzystania z nich np. po uaktualnieniu przez
Portage pliku do nowej, nie zawierającej błędów wersji.
</p>

<warn>
Jeśli otrzymamy od Portage ostrzeżenie o istniejących twardych dowiązaniach, a
użytkownicy mają dostęp do partycji umożliwiającej wykonywanie plików SUID/SGID
należy uważnie przeczytać ten rozdział. Jeden z użytkowników może podejmować
próbę obejścia uaktualnień poprzez zatrzymanie przestarzałej wersji
programu. Jeśli użytkownicy nie mogą tworzyć własnych plików SUID lub uruchamiać
programów poprzez dynamiczny program ładujący (partycje zamontowane jako
<c>noexec</c>) nie ma powodu do zmartwień.
</warn>

<note>
Użytkownik nie musi posiadać prawa odczytu pliku, aby móc utworzyć do niego
dowiązanie, wystarczy, że ma prawa do katalogu go zawierającego.
</note>

<p>
Aby sprawdzić ilość istniejących dowiązań do danego pliku należy skorzystać z
polecenia <c>stat</c>.
</p>

<pre caption="Polecenie stat">
$ stat /bin/su	  
  File: `/bin/su'
  Size: 29350		Blocks: 64	   IO Block: 131072 regular file
Device: 900h/2304d	Inode: 2057419	   Links: 1
Access: (4711/-rws--x--x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2005-02-07 01:59:35.000000000 +0000
Modify: 2004-11-04 01:46:17.000000000 +0000
Change: 2004-11-04 01:46:17.000000000 +0000
</pre>

<p>
Do znajdowania plików z ustawionymi bitami SUID i SGID korzystamy z programu
<c>find</c>.
</p>

<pre caption="Znajdowanie wielokrotnie zlinkowanych plików binarnych z bitem suid/sgid">
$ find / -type f \( -perm -004000 -o -perm -002000 \) -links +1 -ls
</pre>

</body>
</section>
</chapter>

<chapter>
<title>PAM (Pluggable Authentication Modules).</title>
<section>
<body>

<p>
PAM jest zestawem bibliotek, które umożliwiają korzystanie z różnych metod
autoryzacji w programach. Flaga USE <c>pam</c> jest włączana domyślnie. Domyślne
ustawienia PAM w Gentoo są stosunkowo dobre, zawsze jednak można je nieco
ulepszyć. Po pierwsze warto zainstalować sobie cracklib. 
</p>

<pre caption="Instalowanie cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
Takie ustawienie zmusi użytkowników do ustawiania co najmniej ośmioliterowych
haseł, zawierających co najmniej dwie cyfry i co najmniej 2 inne znaki, oraz co
najmniej 3 znaki różne w stosunku do tych z poprzedniego hasła. Spowoduje to, że
wszyscy użytkownicy będą mieli ustawione dobre hasła. Więcej opcji
znajduje się w dokumentacji <uri
link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">PAM</uri>.
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok 
auth	 required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
Każda nieskonfigurowana w pliku <path>/etc/pam.d</path> usługa
zostanie potraktowana zgodnie z zasadami z pliku  <path>/etc/pam.d/other</path>.
Domyślnie jest to <c>deny</c>, tak jak powinno to być zresztą
ustawione. Osobiście lubię mieć dużą ilość logów, w związku z czym dodałem
<c>pam_warn.so</c>. Ostatnim ustawieniem jest <c>pam_limits</c>, które jest
konfigurowane w pliku <path>/etc/security/limits.conf</path>. Więcej informacji
o tych ustawieniach znajduje się w <uri link="#limits_conf">paragrafie
dotyczącym /etc/security/limits.conf</uri>.
</p>

<pre caption="/etc/pam.d/other">
auth	 required pam_deny.so 
auth	 required pam_warn.so 
account  required pam_deny.so 
account  required pam_warn.so 
password required pam_deny.so 
password required pam_warn.so 
session  required pam_deny.so 
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>
<chapter>
<title>TCP Wrappers.</title>
<section>
<body>

<p>
Jest to metoda kontrolowania dostępu do usług normalnie uruchamianych przez
inetd (którego nie ma Gentoo), ale może również być używana przez xinetd i inne
tego typu usługi.
</p>

<note>
Usługa ta powinna być uruchamiana z argumentem serwera tcpd (w xinetd). Więcej
informacji znajduje się w paragrafie dotyczącym xinetd.
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
Jak widać format tego pliku jest bardzo podobny do tego z pliku
<path>/etc/login.access</path>. Tcpd posiada wsparcie dla określonych usług i nie
nakłada się z <path>/etc/login.access</path>. Te ustawienie będą miały
wpływ wyłącznie na usługi używające tcp wrappers.
</p>

<p>
Możliwe jest również wykonywanie poleceń podczas dostępu do usługi (np. jeśli
chcemy włączyć przekazywanie dla użytkowników korzystających z łączności
komutowanej) ale nie jest to zalecane, ponieważ ludzie mają tendencję do
komplikowania prostych spraw. Przykładem takiej sytuacji może być przypadek, gdy
chcemy skonfigurować skrypt, który będzie wysyłał e-mail za każdym razem gdy
ktoś zostanie zakwalifikowany do reguły deny. Włamywacz może wykorzystać taką
regułę do ataku typu DoS poprzez jej nadużywanie, co skończy się ogromnym
obciążeniem systemu i wielką ilością e-maili w naszej skrzynce. Dlatego nie
należy tego robić. Więcej informacji znajduje się w dokumentacji <c>man 5
hosts_access</c>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Ochrona jądra.</title>
<section>
<title>Usuwanie zbędnych funkcji.</title>
<body>

<p>
Podstawową zasadą przy konfigurowaniu jądra jest to, by wyłączać wszystko
czego się nie potrzebuje. Dzięki temu stworzymy nie tylko mały, ale i mniej
podatny na potencjalne błędy kernel.
</p>

<p>
Ponadto warto rozważyć wyłączenie opcji 'loadable module support' - wsparcia
dla ładowania modułów. Nie uniemożliwi to zainstalowania rootkita przez moduły
jądra, ale na pewno znacznie to utrudni - zwłaszcza mniej wyedukowanym
włamywaczom. 
</p>

</body>
</section>
<section>
<title>System plików proc.</title>
<body>

<p>
Wiele parametrów jądra można skonfigurować poprzez system plików
<path>/proc</path> lub przy pomocy <c>sysctl</c>.
</p>

<p>
Możliwość zmiany tych parametrów bez konieczności restartowania komputera
umożliwia zaznaczenie opcji <c>CONFIG_SYSCTL</c> w konfiguracji jądra. Jest ona
standardowo zaznaczona w kernelach serii 2.4.
</p>

<pre caption="Wyłączanie przekazywania IP">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
Należy upewnić się, że przekazywanie (forwardowanie) IP jest wyłączone. Jest ono
potrzebne jedynie w przypadku stacji roboczych czy węzłów sieciowych o wielu
podłączeniach. Radzimy wyłączyć tą flagę na samym początku, ponieważ zmienia ona
wartość kilku innych omawianych tu opcji.
</p>

<pre caption="Upuszczanie pakietów ping">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
Włączenie tej opcji spowoduje, że kernel po prostu zignoruje wszystkie
wiadomości typu ping (czyli wiadomości typu 0 protokołu ICMP). Uzasadnieniem
takiej decyzji jest to, że pakiet IP przenoszący wiadomość ICMP może przenosić
ładunek inny niż możnaby się po nim spodziewać. Administratorzy często używają
ping jako narzędzia diagnostycznego i narzekają jeśli jest wyłączony, ale są
również powody dla których warto zabronić pingowania serwera ludziom z zewnątrz.
Czasem zdarza się sytuacja, że ktoś z wewnątrz będzie chciał użyć ping, dlatego
znacznie lepszym pomysłem jest wyłączenie tego typu pakietów w firewallu i
umożliwienie korzystania z tego narzędzia administratorom naszej sieci.
</p>

<pre caption="Ignorowanie transmisji ping">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
Opcja ta wyłączy odpowiedzi na rozgłaszanie ICMP (ICMP broadcast) co
zapobiegnie atakom typu smurf. Atak typu smurf polega na wysłaniu wiadomości
ICMP typu 0 (czyli ping) na adres całej sieci ze sfałszowanego adresu, co
spowoduje odpowiedź wszystkich działających w tej sieci komputerów i zalania
falą odpowiedzi komputera, którego adresu użył atakujący.
</p>

<pre caption="Wyłączanie source routingu">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
Ustawienie to spowoduje odrzucanie source routowanych pakietów. Włamywacze mogą
ich używać do stworzenia pozorów, że ruch pochodzący od nich tak naprawdę
pochodzi z wnętrza sieci, a faktycznie będzie routowany z powrotem do ich
komputera. Source routingu bardzo rzadko używa się do legalnych czynności, więc
można go bezpiecznie wyłączyć.
</p>

<pre caption="Wyłączanie akceptowania przedresowań">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/secure_redirects</i>
</pre>

<p>
Spowoduje to odrzucanie przeadresowanych pakietów ICMP, które mogą być używane do
zmiany tablic routingu, co zwykle źle się kończy.
</p>

<pre caption="Ochrona przed błędnymi informacjami o błędach">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
Włącza ochronę przed błędnymi komunikatami o błędach.
</p>

<pre caption="Włączanie filtrowania trasy powrotnej (reverse path filtering)">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
	/bin/echo "1" &gt; $i/rp_filter
done</i>
</pre>

<p>
Włącza filtrowanie trasy powrotnej pakietu. Dzięki temu wszystkie pakiety, które
nie docierają interfejsem, z którego rzekomo wyszło zapytanie zostaną
zignorowane. Znacznie poprawia to bezpieczeństwo, ponieważ poważnie utrudnia
spoofowanie IP. Aby uzyskać pełną funkcjonalność musimy je uruchomić dla każdego
<path>net/ipv4/conf/*</path>.
</p>

<warn>
Wyłączenie filtrowania trasy powrotnej może stwarzać problemy jeśli korzysta się
z routingu asymetrycznego (pakiety od nas do komputera docelowego podróżują inną
trasą niż te od niego do nas) lub jeśli pracuje się na nie routoującym hoście
posiadającym kilka adresów IP na różnych interfejsach.
</warn>

<pre caption="Logowanie wszystkich spoofowanych, source routowanych lub
przeadresowanych pakietów">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
Loguje wszystkie spoofowane, source routowane i przeadresowane pakiety.
</p>

<p>
Wszystkie wprowadzone w powyższy sposób zmiany zostaną zresetowane po ponownym
uruchomieniu komputera. Aby zapamiętać je na dłużej należy dopisać je do pliku
<path>/etc/sysctl.conf</path>, z którego informacje są automatycznie wczytywane
przez skrypt startowy <path>/etc/init.d/bootmisc</path>.
</p>

<p>
Składnia pliku <path>/etc/sysctl.conf</path> jest bardzo przejrzysta. Wystarczy
usunąć z podanych wyżej linii <path>/proc/sys/</path> i zamienić wszystkie
<path>/</path> na <path>.</path>.
</p>

<pre caption="Tłumaczenie na składnię sysctl.conf">
<comment>(Ręcznie, przy użyciu echo):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automatycznie w sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity.</title>
<body>

<p>
Łatka <uri link="http://grsecurity.net">grsecurity</uri> jest standardowo
nakładana na jądra Gentoo, chociaż w domyślnym pliku konfiguracyjnym wyłączamy
wszystkie dostarczane przez nią moduły. Najpierw konfiguruje się standardowe
opcje kernela, potem przychodzi pora na dodanie tych związanych z grsecurity.
Dokładne omówienie wszystkich użytych ustawień znajduje się na stronie projektu
<uri link="/proj/en/hardened">Gentoo Hardened</uri>.
</p>

<p>
Najnowsze <c>grsec-sources</c> są oparte na wersjach 2.* Grsecurity. Więcej
informacji o tych łatkach znajduje się na stronach <uri
link="http://www.grsecurity.net/">projektu Grsecurity</uri>.
</p>

</body>
</section>
<section>
<title>Kerneli.</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri> jest to łatka dodająca
do jądra funkcje związane z szyfrowaniem takie jak szyfry kryptograficzne,
algorytmy skrótów czy filtry pętli kryptograficznych.
</p>

<warn>
Przy używaniu kerneli trzeba zachować ostrożność, nie jest to jeszcze wersja
stabilna.
</warn>

</body>
</section>
<section>
<title>Inne przydatne patche dla jądra.</title>
<body>

<ul>
<li><uri link="http://www.openwall.com">Projekt OpenWall</uri></li>
<li><uri link="http://www.lids.org">Linux Intrusion Detection System</uri></li>
<li><uri link="http://www.rsbac.org">Rule Set Based Access Control</uri></li>
<li>
<uri link="http://www.nsa.gov/selinux">NSA's security enhanced kernel</uri>
</li>
<li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>
  
<p>
I wiele innych.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Zabezpieczanie usług.</title>
<section>
<title>Apache.</title>
<body>

<p>
Apache (1.3.26) posiada stosunkowo dobry domyślny plik konfiguracyjny, warto
jednak nanieść na niego kilka poprawek, jak na przykład związanie go z jednym
adresem czy zapobieganie wyciekom informacji. Poniżej podajemy opcje,
które warto dodać do pliku konfiguracyjnego.
</p>

<p>
O ile nie wyłączono <c>ssl</c> w pliku <path>/etc/make.conf</path> przed
instalacją, Apache powinien posiadać jego obsługę. Aby ją uaktywnić należy
dopisać następującą linię:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Make it listen on your ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#It is not a good idea to use nobody or nogroup - 
#for every service not running as root 
#(just add the user apache with group apache)
User apache
Group apache
#Will keep apache from telling about the version
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache jest kompilowany z opcjami <c>--enable-shared=max</c> i
<c>--enable-module=all</c>, czyli ze wszystkimi modułami, co zmusza do
wykomentowywania wszystkich przez nas nie używanych z sekcji <c>LoadModule</c>
(<c>LoadModule</c> i <c>AddModule</c>). Następnie należy zrestartować usługę
poleceniem <c>/etc/init.d/apache restart</c>.  
</p>

<p>
Całość dokumentacji znajduje się na stronie <uri>http://www.apache.org</uri>.
</p>

</body>
</section>

<section>
<title>Bind.</title>
<body>

<p>
Dokumentacja znajduje się na stronach <uri
link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri>. "The BIND 9 Administrator Reference Manual" znajduje się
również w katalogu <path>doc/arm</path>.
</p>

<p>
Nowsze ebuildy BIND umożliwiają chrootowanie się poza maszynę. Po zemergowaniu
<c>bind</c> należy wykonać następujące czynności:
</p>

<pre caption="chrootowanie BIND">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<comment>(Before running the above command you might want to change the chroot 
directory in /etc/conf.d/named. Otherwise /chroot/dns will be used.)</comment>
<comment>(Należy zamienić podany numer wersji aktualnie używanym)</comment>
</pre>

</body>
</section>
<section>
<title>Djbdns.</title>
<body>

<p>
Djbdns to implementacja zabezpieczeń DNS, której autor jest tak pewny, że
stawia na nią <uri link="http://cr.yp.to/djbdns/guarantee.html">pieniądze</uri>.
Jej sposób działania bardzo różni się od tego z Bind 9, ale mimo wszystko warto
ją wypróbować. Więcej informacji znajduje się na stronie
<uri>http://www.djbdns.org</uri>.
</p>

</body>
</section>
<section>
<title>FTP.</title>
<body>

<p>
Generalnie używanie FTP (File Transfer Protocol) to kiepski pomysł. FTP używa
niezaszyfrowanych haseł (są przesyłane czystym tekstem), nasłuchuje na dwóch
portach (standardowo 20 i 21), a ponadto jest często atakowane przez
włamywaczy szukających anonimowych serwerów w celu wymiany warezów. W związku z
wieloma brakami w bezpieczeństwie protokołu FTP powinno się zamiast niego używać
<c>sftp</c> lub HTTP. Jeśli nie jest to możliwe należy zabezpieczyć FTP jak to
tylko możliwe i przygotować się na sporo problemów.
</p>

</body>
</section>
<section>
<title>Mysql.</title>
<body>

<p>
Jeśli dostęp do bazy <c>mysql</c> jest potrzebny wyłącznie lokalnym aplikacjom
należy odkomentować następującą linię w pliku <path>/etc/mysql/my.cnf</path>:
</p>

<pre caption="Zamknięcie dostępu z sieci">
skip-networking
</pre>

<p>
Następnie wyłączymy komendę LOAD DATA LOCAL INFILE. Zapobiegnie to
nieautoryzowanemu dostępowi do lokalnych plików. Takie zabezpieczenie przydaje
się np. w przypadku odkrycia słabych punktów w PHP umożliwiających atak typu SQL
Injection.
</p>

<pre caption="Wyłączanie LOAD DATA LOCAL INFILE w sekcji [mysqld]">
set-variable=local-infile=0
</pre>

<p>
Następnie musimy usunąć przykładową bazę danych (test) i wszystkie konta poza
kontem roota.
</p>

<pre caption="Usuwanie przykładowej bazy i zbędnych kont">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>
Należy uważać z wpisywaniem powyższych poleceń jeśli posiada się już
skonfigurowane konta użytkowników.
</warn>

<note>
Jeśli zmieniano hasła z wiersza poleceń MySQL należy wyczyścić pliki
<path>~/.mysql_history</path> i <path>/var/log/mysql/mysql.log</path> ponieważ
zawierają one historię poleceń SQL wraz z hasłami zapisanymi otwartym
tekstem.
</note>

</body>
</section>
<section>
<title>Proftpd.</title>
<body>

<p>
Proftpd miało wiele problemów związanych z bezpieczeństwem, na szczęście
większość z nich już naprawiono. Do domyślnego pliku konfiguracyjnego warto
dodać następujące opcje:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#Don't show the ident of the server
ServerIdent on "Go away"

#Makes it easier to create virtual users
RequireValidShell off

#Use alternative password and group file (passwd uses crypt format)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# Permissions
Umask 077

# Timeouts and limitations
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

#Chroot everyone
DefaultRoot ~

#don't run as root
User  nobody
Group nogroup

#Log every transfer
TransferLog /var/log/transferlog

#Problems with globbing
DenyFilter \*.*/
</pre>

<p>
Całość dokumentacji znajduje się na stronie <uri>http://www.proftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Pure-ftpd.</title>
<body>

<p>
Pure-ftpd to odmiana trollftpd, zmodyfikowana pod kątem bezpieczeństwa przez
Franka Dennisa.
</p>

<p>
Dzięki włączeniu opcji <c>AUTH</c> uniemożliwia się korzystania z kont
użytkowników systemowych i zmusza serwer do pracy z kontami wirtualnymi.
Bazę danych wirtualnych użytkowników tworzy się poleceniem
<c>-lpuredb:/etc/pureftpd.pdb</c>, a użytkowników do niej dodaje za pomocą
<c>/usr/bin/pure-pw</c>.
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
Warto również skonfigurować opcję <c>MISC_OTHER</c>, tak aby uniemożliwić
logowanie się jako anonymous (<c>-E</c>), zamykać każdego użytkownika w chroocie
(<c>-A</c>), uniemożliwić dostęp do plików rozpoczynających się od . (kropki)
(<c>-X</c>), podać maksymalny czas beczynności (<c>-I</c>), zabronić
rekursywnego pobierania (<c>-L</c>), oraz ustawić sensowny <c>umask</c>.
</p>

<warn>
<e>Nie wolno używać</e> opcji <c>-w</c> lub <c>-W</c>! Jeśli chcesz założyć warez
zrezygnuj z czytania tego przewodnika!
</warn>

<p>
Całość dokumentacji znajduje się na stronie <uri>http://www.pureftpd.org</uri>.
</p>

</body>
</section>
<section>
<title>Vsftpd.</title>
<body>

<p>
Vsftp (skrót od "bardzo bezpieczne ftp" (very secure ftp)) to mały daemon ftp z
bardzo dobrą domyślną konfiguracją. Jest bardzo prostym programem, więc nie
posiada tak rozbudowanych możliwości jak pureftp albo proftp.
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#read only
write_enable=NO

#enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
Jak widać nie ma możliwości, aby usługa ta posiadała jakieś indywidualne
ustawienia praw dostępu. Jeśli jednak chodzi o ustawienia dla
anonimowych użytkowników okazuje się ona bardzo dobra, a taki anonimowy serwer
przydaje się np. gdy trzeba szybko podzielić się z kimś kodem open source.
</p>

</body>
</section>
<section>
<title>Qmail.</title>
<body>

<p>
Qmail jest uważany za bardzo bezpieczny serwer pocztowy. Przy jego pisaniu
zwrócono szczególną uwagę na opcje związane z bezpieczeństwem. Domyślna
konfiguracja nie umożliwia przekazywania poczty, a w samym programie nie
znaleziono błędu związanego z bezpieczeństwem od 1996 roku. Nie ma się co
zastanawiać, należy po prostu wpisać <c>emerge qmail</c> i zabrać się za
konfigurację.
</p>

</body>
</section>
<section>
<title>Samba.</title>
<body>

<p>
Samba jest protokołem umożliwiającym wymianę plików z sieciami Microsoft i
Novell, z którego <e>nie powinno</e> używać się w Internecie. Ponadto jak niemal każdy
program wymaga pewnego dokonfigurowania.
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  #Bind to an interface
  interfaces = eth0 10.0.0.1/32

  #Make sure to use encrypted password
  encrypt passwords = yes
  directory security mask = 0700

  #allow traffic from 10.0.0.*
  hosts allow = 10.0.0.

  #Enables user authentication 
  #(don't use the share mode)
  security = user

  #Disallow privileged accounts
  invalid users = root @wheel

  #Maximum size smb shows for a share (not a limit)
  max disk size = 102400

  #Uphold the password policy
  min password length = 8
  null passwords = no

  #Use PAM (if added support)
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
Warto upewnić się, że wszystkie prawa dostępu są ustawione prawidłowo
oraz zapoznać się z <uri link="http://www.samba.org">dokumentacją</uri>
programu.
</p>

<p>
Następnie należy zrestartować serwer i dodać konta użytkowników, którzy mają
mieć dostęp do tej usługi. Dokonuje się tego przy pomocy polecenia
<path>/usr/bin/smbpasswd</path> z parametrem <c>-a</c>.
</p>

</body>
</section>
<section>
<title>ssh.</title>
<body>

<p>
Jedynym zabezbieczeniem jakiego potrzebuje OpenSSH jest przełączenie go na
silniejszy mechanizm uwierzytelniania, oparty na szyfrowaniu klucza publicznego
(przy pomocy niewłaściwie ustawionych haseł włamano się już między innymi na
strony <uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> i
<uri>http://www.apache.org</uri>).
</p>

<pre caption="/etc/ssh/sshd_config">
#Only enable version 2
Protocol 2

#Disable root login. Users have to su to root
PermitRootLogin no

#Turn on Public key authentication
PubkeyAuthentication yes
AuthorizedKeysFile	.ssh/authorized_keys

#Disable .rhost and normal password authentication
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

#Only allow userin the wheel or admin group to login
AllowGroups wheel admin

#In those groups only allow the following users
#The @&lt;domainname&gt; is optional but replaces the 
#older AllowHosts directive
AllowUsers kn@gentoo.org bs@gentoo.org

#Logging 
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
Należy sprawdzić czy w pliku konfiguracyjnym nie ma linii <c>UsePAM yes</c>,
ponieważ nadpisze ona ustawienia dla uwierzytelniania poprzez klucze publiczne.
</p>

<p>
Teraz wszyscy użytkownicy muszą wygenerować własne klucze na komputerach, z
których będą się logować na nasz serwer. Dokonuje się tego następującym
poleceniem:
</p>

<pre caption="Tworzenie pary kluczy DSA">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
Następnie należy wpisać hasło.
</p>

<pre caption="Wynik polecenia ssh-keygen">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[wciskamy enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[wpisujemy hasło]</i>
Enter same passphrase again: <i>[ponownie wpisujemy hasło]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
W wyniku tych czynności w katalogu <path>~/.ssh/</path> zostaną utworzone dwa
pliki o nazwach <path>id_dsa</path> i <path>id_dsa.pub</path>. Plik o nazwie
<path>id_dsa</path> to prywatny klucz i nie powinien być przekazywany innym
osobom. Natomiast drugi plik, <path>id_dsa.pub</path>, powinno umieścić się
w <path>~/.ssh/authorized_keys</path> na każdym serwerze, na który zamierzamy
się logować.
</p>

<p>
Użytkownicy powinni pilnować swoich prywatnych kluczy i przechowywać je
wyłącznie na nośnikach, które będą zawsze mieć przy sobie lub na swoich
stacjach roboczych. Informację o tym należy umieścić w <uri
link="#security_policies">polityce</uri> bezpieczeństwa dotyczącej haseł.
</p>

<p>
Więcej informacji na ten temat można znaleźć na stronie projektu <uri
link="http://www.openssh.org">OpenSSH</uri>.
</p>

</body>
</section>
<section>
<title>Używanie xinetd.</title>
<body>

<p>
xintetd to zastępstwo dla demona usług internetowych - <c>inetd</c> (którego nie
ma w Gentoo). Umożliwia kontrolę dostępu na podstawie adresu i czasu tego
dostępu. Posiada również szerokie możliwości logowania, obejmujące między
innymi czas uruchomienia serwera, zdalne adresy hostów, zdalnych użytkowników,
czas działania serwera i wszystkie zgłoszone żądania.
</p>

<p>
Jak w przypadku wszystkich innych usług ważną rzeczą jest tu bardzo uważna
konfiguracja. Ponieważ jednak <c>xinetd</c> jest uruchamiane z konta
roota i obsługuje wiele protokołów, których działanie nie jest powszechnie
znane, odradzamy jego używanie. Jeśli jednak koniecznie chcecie go używać oto
jak należy go zabezpieczyć:
</p>

<pre caption="Instalowanie xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
Następnie edytujemy plik konfiguracyjny:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from = localhost
 instances = 10
 log_type = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps = 25 30
}

# This will setup pserver (cvs) via xinetd with the following settings:
# max 10 instances (10 connections at a time)
# limit the pserver to tcp only
# use the user cvs to run this service
# bind the interfaces to only 1 ip
# allow access from 10.0.0.*
# limit the time developers can use cvs from 8am to 5pm
# use tpcd wrappers (access control controlled in 
# <i>/etc/hosts.allow</i> and <i>/etc/hosts.deny</i>)
# max_load on the machine set to 1.0
# The disable flag is per default set to no but I like having 
# it in case of it should be disabled
service cvspserver
{
 socket_type = stream
 protocol = tcp
 instances = 10
 protocol = tcp
 wait = no
 user = cvs
 bind = 10.0.0.2
 only_from = 10.0.0.0
 access_times = 8:00-17:00
 server = /usr/sbin/tcpd
 server_args = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load = 1.0
 log_on_failure += RECORD
 disable = no
}
</pre>

<p>
Więcej informacji znajduje się w <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>

<section>
<title>X.</title>
<body>

<p>
Domyślnie Xorg jest skonfigurowane jako serwer X. Może to być niebezpieczne,
ponieważ X używa nieszyfrowanych połączeń TCP i oczekuje na połączenia od
xklientów.
</p>

<impo>
Jeśli nie potrzebuje się tej usługi należy ją po prostu wyłączyć.
</impo>

<p>
Jeśli jednak stacja robocza musi działać jako serwer X należy używać polecenia
<c>/usr/X11R6/bin/xhost</c> z ostrożnością. Polecenie to umożliwia łączenie się
z naszym serwerem klientom z innych hostów i używanie naszego ekranu. Może to
być pomocne, jeśli chcemy użyć aplikacji opartej na X na innym komputerze, do
którego dostęp mamy jedynie przez sieć, ale może również zostać wykorzystane w
niecnych celach przez włamywaczy. Składnia dla tej komendy to
<c>/usr/X11R6/bin/xhost +hostname</c>.
</p>

<warn>
Nie wolno używać składni <c>xhost +</c>! Umożliwi to połączenie z serwerem i
przejęcie nad nim kontroli dowolnemu klientowi. Jeśli włamywacz uzyska dostęp do
X może bez trudu logować sekwencje klawiszy wpisywane przez użytkowników, poznać
ich hasła i w efekcie tego przejąć całkowitą kontrolę nad maszyną. Jeśli
używanie X jako serwera jest konieczne należy zawsze wyszczególnić prawidłowe
hosty.
</warn>

<p>
Dużo bezpieczniejszym rozwiązaniem jest nie korzystanie z tej możliwości np.
poprzez uruchamianie serwera X poleceniem <c>startx -- -nolisten tcp</c> lub
całkowite jej wyłączenie w plikach konfiguracyjnych.
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
Aby uniemożliwić nadpisanie pliku <path>startx</path> w trakcie emergowania
nowych wersji Xorg należy dodać go do listy plików chronionych, dokonuje się
tego poprzez dopisanie następującej linii do pliku <path>/etc/make.conf</path>:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
Graficzny menedżer logowania wymaga nieco innego podejścia:
</p>

<p>
Dla <c>gdm</c> (Gnome Display Manager):
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
Dla <c>xdm</c> (X Display Manager) i <c>kdm</c> (Kde Display Manager):
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>
</chapter>
<chapter>
<title>Chrootowanie i wirtualne serwery.</title>
<section>
<title>Chrootowanie.</title>
<body>

<p>
Zamknięcie usługi (użytkownika) w chroocie uniemożliwi dostęp do plików
i informacji, do których dostępu mieć nie powinna oraz zamknie wiele z
możliwości uzyskania dostępu do konta roota tą drogą. Ponadto uruchomienie
usługi z konta użytkownika innego niż root (np. <c>nobody</c>, <c>apache</c>,
<c>named</c>) ograniczy włamywaczom dostęp, pozostawiając im do dyspozycji tylko
pliki przypisane do tych kont. Takie postępowanie uniemożliwi także
nieautoryzowany dostęp do konta w przypadku błędu związanego z bezpieczeństwem w
którejś z usług.
</p>

<p>
Niektóre usługi, takie jak np. <c>pure-ftpd</c> i <c>bind</c> posiadają
wbudowane możliwości zamykania się w chroocie. Jeśli jednak nie ma
takiej możliwości należy dokonać tego ręcznie. Oto prosty przykład tworzenia
środowiska chroot. Dla uproszczenia przetestujemy je przy pomocy <c>basha</c>.
</p>

<p>
Na początek tworzymy katalog <path>/chroot</path> przy pomocy polecenia <c>mkdir
chroot</c> oraz wyszukujemy wszystkie biblioteki, z którymi bash jest
dynamicznie zlinkowany (jeśli skompilowano go z opcją <c>-static</c> można
pominąć ten krok).
</p>

<p>
Listę bibliotek używanych przez <c>bash</c> uzyskamy dzięki poleceniu:
</p>

<pre caption="Uzyskiwanie listy używanych bibliotek">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
Następnie tworzymy środowisko dla <c>basha</c>.
</p>

<pre caption="Tworzenie środowiska chroot dla basha">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
Później kopiujemy pliki używane przez <c>bash</c> (<path>/lib</path>) do
katalogu <path>lib</path> w chroocie oraz plik binarny bash do nowego
<path>bin</path>. Spowoduje to utworzenie kopii naszego środowiska, posiadającej
jednak nieco mniej możliwości. Po utworzeniu warto je wypróbować poleceniem
<c>chroot /chroot/bash /bin/bash</c>. Jeśli pokaże się znak zachęty w postaci
<path>/</path> to znaczy, że wszystko działa prawidłowo. W przeciwnym wypadku
zostaniemy poinformowani o braku pewnych plików. Niektóre współdzielone
biblioteki są wzajemnie od siebie zależne.
</p>

<p>
Łatwo zauważyć, że wewnątrz chroota nie działa nic poza <c>echo</c>.
Spowodowane jest to tym, że w naszym nowym środowisku jedynym dostępnym
poleceniem jest bash, a echo jest jego wbudowaną funkcją.
</p>

<p>
Zamykanie usług w chroocie wygląda bardzo podobnie. Jedyną różnicą jest
to, że usługom potrzebne są czasem urządzenia i pliki konfiguracyjne z
<path>/etc</path>. Należy je więc po prostu skopiować do nowego środowiska
(urządzenia kopiuje się poleceniem <c>cp -a</c>), należy również odpowiednio
edytować skrypt startowy zanim skorzysta się z nowego środowiska. Czasem ciężko
znaleźć wszystkie urządzenia i pliki jakich wymaga dana usługa, wtedy bardzo
przydatny jest program <c>strace</c>. Uruchamiamy usługę poprzez
<c>/usr/bin/strace</c> i szukamy wszystkich odwołań open, read, stat i connect.
Zwykle naprowadza to na ślad wszystkich plików i urządzeń, które należy
skopiować. W większości przypadków wystarczy skopiowanie pliku passwd (należy z
niego usunąć wszystkie linie dotyczące użytkowników nie mających nic wspólnego z
usługą), oraz <path>/dev/zero</path>, <path>/dev/log</path> i
<path>/dev/random</path>.
</p>

</body>
</section>
<section>
<title>User Mode Linux.</title>
<body>

<p>
Kolejnym dobrym sposobem zabezpieczenia środowiska pracy jest uruchomienie
wirtualnej maszyny. Taka maszyna to proces działający jako nakładka na właściwy
system operacyjny, na który składa się drugi OS i pewna konfiguracja 
urządzeń, tworząca złudzenie, że jest właściwym komputerem. Korzyści z punktu
widzenia zabezpieczeń systemu są takie, że w przypadku włamania zostanie
pokonana tylko wirtualna maszyna, a właściwy system operacyjny pozostanie
nienaruszony.
</p>

<p>
Więcej informacji o konfigurowaniu User Mode Linux znajduje się w <uri
link="http://www.gentoo.org/doc/en/uml.xml">User Mode Linux
Guide</uri>.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Firewalle.</title>
<section>
<title>Firewall.</title>
<body>

<p>
Ludzie często sądzą, że firewall zapewnia pełną ochronę. Są w błędzie. W
większości przypadków źle skonfigurowany firewall zapewnia mniej ochrony niż
nie posiadanie firewalla w ogóle. Ponadto każdy firewall należy traktować jak
zwykły, podatny na błędy program.
</p>

<p>
Należy zatem poważnie przemyśleć jego używanie i dokładnie sprawdzić czy jest
nam potrzebny. Należy również spisać dokładnie jakiego typu ma to być firewall,
określić reguły jego działania oraz użytkowników jacy będą z niego korzystać.
</p>

<p>
Firewall jest przydatny z dwóch powodów:
</p>

<ul>
<li>Nie wpuszcza części niepożądanych użytkowników (robaków/włamywaczy)</li>
<li>Wpuszcza całą resztę (pracowników/dzieci)</li>
</ul>

<p>
Są trzy typy firewalli:
</p>

<ul>
<li>Zajmujące się filtrowaniem pakietów.</li>
<li>Kontrolujące połączenia sieciowe między systemami wewnętrznymi i
zewnętrznymi (circuit relay).</li>
<li>Bramy aplikacyjne.</li>
</ul>

<p>
Firewallem powinien być dedykowany komputer, na którym nie są uruchomione żadne
usługi (oprócz <c>sshd</c>, które może stanowić tu wyjątek) i który jest
zabezpieczony w sposób opisany w tym przewodniku. 
</p>

</body>
</section>
<section>
<title>Filtrowanie pakietów.</title>
<body>

<p>
Cały ruch sieciowy odbywa się za pomocą pakietów. Duże ilości danych są dzielone
na małe pakiety, przesyłane, a następnie składane w całość na komputerze
docelowym. W nagłówku każdego pakietu znajduje się informacja o tym w jaki
sposób i dokąd powinien on zostać dostarczony. Właśnie z tych informacji
korzysta filtr pakietów. Filtrowanie polega na:
</p>

<ul>
<li>Dopuszczaniu lub odrzucaniu pakietów na podstawie ich źródłowego i
docelowego adresu IP.</li>
<li>Dopuszczaniu lub odrzucaniu pakietów na podstawie ich źródłowego i
docelowego portu.</li>
<li>Odrzucanie lub dopuszczanie na podstawie używanego protokołu.</li>
<li>Odrzucaniu lub dopuszczaniu pakietów na podstawie ustawionych w nagłówku
pakietu flag danego protokołu.</li>
</ul>

<p>
Innymi słowy filtrowanie pakietów opiera się na danych pochodzących z nagłówka
pakietu, a nie danych jakie on przenosi.
</p>

<p>
Słabości:
</p>

<ul>
<li>
Informacje o adresie wewnątrz pakietów mogą zostać sfałszowane (zespoofowane)
przez nadawcę.
</li>
<li>
Treść dopuszczonego pakietu może zawierać niechciane informacje, których
włamywacz może użyć do złamania aplikacji znajdujących się za firewallem.
</li>

<!-- <li>Usually single point of failure</li> <tłumacz>: nie mam pojęcia o co
chodzi autorowi -->

</ul>

<p>
Mocne strony:
</p>

<ul>
<li>Łatwość implementacji.</li>
<li>
Możliwość informowania o potencjalnych atakach zanim jeszcze się odbędą (np.
poprzez wykrywanie skanowania portów).
</li>
<li>Doskonale nadaje się do zatrzymywania ataków typu SYN.</li>
</ul>

<p>
Przykładowe filtry pakietów na Linuksa:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>
<!--FIXME: should SmoothWall really be included, since it uses iptables?-->

<note>
Zaleca się używanie iptables. Ipchains to przeżytek.
</note>

</body>
</section>
<section>
<title>Circuit relay.</title>
<body>

<p>
Jest to firewall, który zatwierdza połączenia zanim pozwoli na wymianę jakichś
danych. Oznacza to, że nie odrzuca i nie dopuszcza pakietów jedynie na podstawie
ich nagłówków, ale na podstawie skonfigurowanego zestawu reguł sprawdza czy
połączenie jest prawidłowe i dopiero kiedy to potwierdzi pozwala na wymianę informacji.
Filtrowanie może się odbywać poprzez kontrolę:
</p>

<ul>
<li>Źródłowego i docelowego adresu IP.</li>
<li>Źródłowego i docelowego portu.</li>
<li>Okresu czasu.</li>
<li>Protokołu.</li>
<li>Użytkownika.</li>
<li>Hasła.</li>
</ul>

<p>
Cały ruch jest zatwierdzany i monitorowany, ten niechciany jest po prostu
odrzucany.
</p>

<p>
Słabości:
</p>

<ul>
<li>
Działa na warstwie transportowej, przez co niektóre aplikacje mogą wymagać
pewnych modyfikacji, aby mogły w normalny sposób spełniać swoje funkcje.
</li>
</ul>

</body>
</section>
<section>
<title>Brama aplikacyjna (application gateway).</title>
<body>

<p>
Brama aplikacyjna to rodzaj proxy dla programów, które wymienia dane klientów ze
zdalnymi hostami w ich imieniu. Zwykle znajduje się poza widokiem publicznym i
poza strefą zdemilitaryzowaną (de-militarized zone, część prywatnej sieci, która
jest widoczna poprzez firewall) lub firewallem odrzucającym wszystkie
połączenia. Filtrowanie odbywa się na zasadzie:
</p>

<ul>
<li>
Odrzucania lub akceptowania na podstawie źródłowego i docelowego adresu IP.
</li>
<li>
Zawartości pakietu.
</li>
<li>
Limitowanym dostępie do plików opartym na ich typie i rozszerzeniu.
</li>
</ul>

<p>
Korzyści:
</p>

<ul>
<li>Pozwala na buforowanie (cache) plików, co zwiększa wydajność sieci.</li>
<li>Dokładnie loguje wszystkie połączenia.</li>
<li>Dobrze się skaluje (niektóre proxy mogą współdzielić buforowane dane)</li>
<li>Uniemożliwia bezpośredni dostęp z zewnątrz.</li>
<li>Może "w locie" zmieniać zawartość pakietu.</li>
</ul>

<p>
Wady:
</p>

<ul>
<li>Skomplikowany proces konfiguracji.</li>
</ul>

<p>
Bramy aplikacyjne to najlepszy sposób zabezpieczania sieci, ponieważ nie muszą
być uruchamiane z przywilejami roota, oraz uniemożliwiają bezpośredni dostęp z
Internetu do komputerów w sieci.
</p>

<p>
Przykład darmowej bramy aplikacyjnej:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri>.</li>
</ul>

</body>
</section>
<section>
<title>Iptables.</title>
<body>

<p>
Korzystanie z iptables jest możliwe tylko wtedy gdy włączy się ich obsługę w
jądrze. Zwykle całość kompiluje się jako moduły, a polecenie <c>iptables</c> w
razie potrzeby ładuje te z nich, które są mu potrzebne. Jeśli jednak zgodnie z
poprzednimi sugestiami zrezygnowano z włączania opcji Loadable Kernel Modules
można spokojnie wkompilować wszystko na stałe. Więcej informacji na temat tego
jak skonfigurować jądro przed użyciem iptables znajduje się w <uri
link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables
Tutorial Chapter 2: Preparations</uri>. Po skompilowaniu jądra z odpowiednimi
opcjami (lub jeszcze w trakcie jego kompilowania) należy zainstalować program
iptables przy pomocy polecenia <c>emerge iptables</c>.
</p>

<p>
Test czy program działa prawidłowo wykonuje się wpisując polecenie <c>iptables
-L</c>. Jeśli się nie uda to znaczy, że coś poszło nie tak i należy sprawdzić
swoją konfigurację.
</p>

<p>
Iptables to filtr pakietów, który wprowadzono do jądra Linuksa w serii 2.4.x.
Jednym z głównych usprawnień w stosunku do poprzedniej wersji (ipchains), było
dodanie dynamicznego filtrowania pakietów (stateful packet filtering). Dzięki
dynamicznemu filtrowaniu pakietów możliwe jest śledzenie każdego nawiązanego
połączenia TCP.
</p>

<p>
Każde połączenie TCP składa się z serii pakietów zawierających informacje o
źródłowym i docelowym adresie IP, źródłowym i docelowym porcie oraz numerach
porządkowych, tak aby mogły być bez utraty danych sortowane po odebraniu. TCP
to protokół połączeniowy, w przeciwieństwie do np. protokołu UDP.
</p>

<p>
Dzięki analizie nagłówka pakietu TCP dynamiczny filtr pakietów jest w stanie
ustalić czy otrzymany pakiet TCP jest częścią już nawiązanego połączenia oraz
zdecydować jak z nim postąpić, czyli czy go zaakceptować, czy odrzucić.
</p>

<p>
Tradycyjny filtr pakietów można poprzez manipulowanie nagłówkami oszukać tak
żeby akceptował pakiety, które powinien upuścić. Można tego dokonać poprzez
manipulowanie flagami (zwłaszcza SYN) w nagłówkach pakietów TCP, tak by
stworzyć złudzenie, że sfałszowany pakiet jest częścią już nawiązanego
połączenia. Dzieje się tak ponieważ ten przestarzały sposób filtrowania nie daje
możliwości śledzenia połączeń. Filtrowanie dynamiczne daje możliwość wykrycia
takich pakietów i ich upuszczenia. Spowoduje ono również, że wszystkie
próby "niewidocznych" skanowań (stealth scans) będą nieudane. Niewidoczne
skanowanie to takie, które polega na wysłaniu przez skaner portów do
skanowanego komputera serii pakietów z tak ustawionymi flagami, że szansa na ich
zapisanie w logach jest mniejsza niż w przypadku zwykłych pakietów z flagą SYN.
</p>

<p>
Ponadto iptables posiada kilka innych bardzo użytecznych narzędzi, jak np. NAT
(Network Adress Translation) czy limitowanie prędkości transmisji. To drugie
jest szczególnie przydatne do zapobiegania atakom typu DoS (Denial of Service)
typu SYN flood.
</p>

<p>
Połączenie TCP jest nawiązywane przez tak zwane potrójne uściśnięcie ręki.
Podczas nawiązywania połączenia klient wysyła do serwera pakiet z ustawioną
flagą SYN. Kiedy serwer otrzyma taki pakiet odpowiada na niego wysłaniem pakietu
SYN+ACK. Kiedy ten pakiet dotrze do klienta odpowiada on trzecim pakietem, ACK,
którym potwierdza nawiązanie połączenia.
</p>

<p>
Atak typu SYN flood polega na wysłaniu pakietu typu SYN i nie odpowiadaniu na
pakiety SYN+ACK. Najczęściej wysyłane są pakiety ze sfałszowanym źródłowym
adresem IP, ponieważ atakujący i tak nie oczekuje na nie odpowiedzi. Serwer po
otrzymaniu każdego pakietu SYN dodaje odpowiedni wpis do kolejki pół-otwartych
połączeń i rozpoczyna oczekiwanie na pakiet ACK. Ponieważ ilość miejsc w kolejce
jest ograniczona możliwe jest jej przepełnienie i w konsekwencji uniemożliwienie
nawiązywania przez komputer zwykłych połączeń. Jeśli pakiet ACK nie przyjdzie po
określonym okresie czasu wpis zostaje automatycznie usunięty z kolejki. Ten
okres czasu zależy od atakowanego komputera, ale zwykle waha się pomiędzy 30 i
60 sekundami. Klient rozpoczyna atak przez wysłanie serii pakietów SYN z różnymi
źródłowymi adresami IP i wysyła kolejne tak szybko i często jak to tylko
możliwe, czym wypełnia kolejkę pół-otwartych połączeń i uniemożliwia innym
klientom nawiązania połączenia z atakowanym komputerem.
</p>

<p>
I tu właśnie przydaje się limitowanie prędkości transmisji. Dzięki opcjom <c>-m
limit --limit 1/s</c> można regulować ilość przyjmowanych pakietów
SYN. Dzięki temu możliwe jest ograniczenie ilości pakietów SYN przyjmowanych w
ciągu każdej sekundy co udaremnia wszystkie ataki typu SYN flood.
</p>

<note>
Inną metodą zapobiegania atakom typu SYN flood są <uri link
="http://cr.yp.to/syncookies.html">SYN cookies</uri>, które pozwalają
komputerowi na odpowiadanie na pakiety SYN bez zapełniania miejsca w kolejce
połączeń. SYN cookies są już częścią jądra Linux i można z nich korzystać
poprzez zaznaczenie w jego konfiguracji odpowiednich opcji, wciąż jest to jednak
mocno eksperymentalny projekt.
</note>

<p>
A teraz pora na odrobinę praktyki.
</p>

<p>
Kiedy iptables zostaną załadowane do jądra powstanie 5 "zaczepów", na których
można umieścić reguły. Ich nazwy to <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>,
<c>PREROUTING</c> i <c>POSTROUTING</c>. Każdy z nich nazywany jest łańcuchem i
składa się listy reguł. Każda z nich mówi o tym jak ma postępować firewall w
przypadku otrzymania pakietu z określonym nagłówkiem. Jeśli pakiet nie pasuje do
żadnej z reguł jest traktowany zgodnie z polityką określoną dla całego łańcucha,
do którego trafił.
</p>

<p>
Własne reguły można umieszczać bezpośrednio w jednym z 5 głównych łańcuchów,
bądź też dodać własne łańcuchy do któregoś z nich i dopiero w nich umieścić
określone reguły. Iptables posiadają następujące opcje: 
</p>

<table>
<tr>
  <th>Opcja:</th>
  <th>Opis:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>Dodaj</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>Usuń</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>Umieść w określonym miejscu</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>Zamień</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>Pokaż listę</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>Usuń wszystkie reguły z łańcucha</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>Wyzeruj liczniki łańcucha</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>Sprawdź pakiet w łańcuchu</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>Utwórz nowy, zdefiniowany przez użytkownika łańcuch</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>Usuń zdefiniowany przez użytkownika łańcuch</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>Zmień politykę łańcucha</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>Zmień nazwę łańcucha</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>Protokół</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>Źródłowy adres/maska</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>Docelowy adres/maska</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>Interfejs, na którym pakiet został przyjęty</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>Interfejs, przez który pakiet zostanie wysłany</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>Cel</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>Rozszerzone dopasowanie, przez podanie tekstu</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>Numeryczne wynikowe adresy i porty</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>Tabela do manipulowania</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>Tryb szczegółowy</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>Rozszerzanie numerów (podaje dokładne wartości)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>Dopasuj drugie i dalsze fragmenty</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>Wersja pakietu</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>Wyświetla numery linii na liście</ti>
</tr>
</table>

<p>
Zaczniemy od prostego przykładu upuszczania wszystkich pakietów ICMP
przychodzących do naszego komputera.
</p>

<pre caption="Upuszczanie pakietów ICMP">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
Na pierwszym miejscu podajemy łańcuch, do którego chcemy dopisać regułę,
następnie protokół, do którego należą pakiety, a wreszcie cel. Celem może być
nazwa zdefiniowanego przez użytkownika łańcucha, lub jedno ze specjalnych
wyrażeń: <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, <c>QUEUE</c>,
lub <c>MASQUERADE</c>. 
</p>

<note>
Cel <c>LOG</c> nie jest celem ostatecznym. Pakiet pasujący do reguły z takim
celem zostanie również przetestowany pod kątem przynależności do innych reguł.
Umożliwia to jednoczesne logowanie i przetwarzanie pakietów.
</note>

<p>
Sprawdzimy teraz skutki naszych działań. Wpisujemy polecenie <c>ping
localhost</c> i czekamy na odpowiedź. Nie powinniśmy jej otrzymać
ponieważ wszystkie pakiety ICMP przychodzące do naszego komputera są upuszczane.
Uniemożliwiliśmy sobie również pingowanie innych komputerów, ponieważ także
pakiety ICMP z odpowiedziami na nasze zapytania będą przez nasz firewall
upuszczane. Wyczyśćmy teraz wszystkie regułki i pozwólmy na swobodny przepływ
pakietów ICMP.
</p>

<pre caption="Czyszczenie wszystkich reguł">
# <i>iptables -F</i>
</pre>

<p>
Przyjrzyjmy się dynamicznemu filtrowaniu pakietów w iptables. Jeśli chcemy
włączyć dynamiczny nadzór nad pakietami przychodzącymi na interfejs eth0 musimy
ustalić następującą regułę:
</p>

<pre caption="Akceptowanie pakietów należących do już nawiązanego połączenia">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
Wprowadzenie takiej reguły skutkuje akceptowaniem wszystkich przychodzących
pakietów, które należą do już nawiązanych połączeń lub są z nimi
powiązane. Jeśli przed dodaniem tej reguły wpiszemy dodatkowo polecenie <c>iptables
-A INPUT -i eth0 -m state --state INVALID -j DROP</c> załadujemy rozszerzenie
"state", dzięki któremu będziemy mieli możliwość upuszczania każdego pakietu,
którego brakuje w tabeli stanu. Aby umożliwić innym łączenie się z naszym
komputerem możemy użyć flagi <c>--state NEW</c>. Iptables zawiera całą serię
modułów o różnym przeznaczeniu, niektóre z nich to:
</p>

<table>
<tr>
  <th>Rozszerzenie/Test</th>
  <th>Opis</th>
  <th>Rozszerzone opcje</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>Test polegający na sprawdzaniu źródłowego adresu mac.</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>Test stanu</ti>
  <ti>--state (stany to ESTABLISHED, RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>Ograniczenie częstotliwości pasowania reguły</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>Próba sprawdzenia pewnych charakterystyk twórcy pakietu</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>Wykonuje różne losowe testy sprawdzające na pakiecie.</ti><ti></ti>
</tr>
</table>

<p>
Następne ćwiczenie będzie polegało na utworzeniu własnego łańcucha i przypisaniu
go do jednego z już instniejących głównych łańcuchów.
</p>

<pre caption="Definiowanie własnego łańcucha">
<comment>(Tworzymy nowy łańcuch z jedną regułą)</comment>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<comment>(Domyślna polityka polega na przepuszczaniu całego wychodzącego ruchu. Ruch przychodzący będzie upuszczany.</comment>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<comment>(Cały przychodzący ruch przekierowujemy do naszego łańcucha)</comment>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
Dzięki dodaniu tych reguł zmienimy naszą politykę na następującą: wszystkie
wychodzące pakiety będą przepuszczane, a pakiety przychodzące upuszczane.
</p>

<p>
Więcej informacji można znaleźć w <uri
link="http://www.iptables.org/documentation/index.html#HOWTO">dokumentacji
netfilter/iptables</uri>.
</p>

<p>
Pora na pełnowartościowy przykład. W tym przypadku polityka naszego firewalla
opiera się na następujących regułach:
</p>

<ul>
<li>
Do firewalla można łączyć się tylko przez SSH (port 22).
</li>
<li>
Lokalna sieć powinna mieć dostęp do HTTP, HTTPS i SSH (pozwalamy również na
korzystanie z DNS).
</li>
<li>
Część ruchu ICMP jest niepożądana, bo może posiadać niechcianą przez nas
zawartość.
</li>
<li>
Wszystkie skanowania portów powinny zostać wykryte i zalogowane.
</li>
<li>
Należy uniemożliwić ataki typu SYN.
</li>
<li>
Cała reszta niechcianych połączeń powinna być upuszczana i logowana.
</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#inside
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#outside
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #default rule
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP traffic
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #Incoming traffic
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #outgoing traffic
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #Catch portscanners
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # Apply and add invalid states to the chains
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #Allow client to route through via NAT (Network Address Translation)
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)	    will restore setting if exists else force rules"
  echo "stop)	    delete all rules and set all to accept"
  echo "rules)	    force settings of new rules"
  echo "save)	    will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<p>
Kilka rad dotyczących tworzenia firewalli:
</p>

<ol>
<li>
Warto spisać politykę firewalla zanim przystąpi się do jej implementowania.
</li>
<li>
Nie warto nadmiernie komplikować zestawu reguł.
</li>
<li>
Należy poznać podstawy pracy każdego z protokołów, np. poprzez przeczytanie
odpowiednich <uri link="http://www.ietf.org/">RFC</uri>.
</li>
<li>
Należy pamiętać, że firewall jest kolejnym programem uruchamianym z przywilejami
roota.
</li>
<li>
Warto przetestować firewall zanim na dobre zacznie się go używać.
</li>
</ol>

<p>
W przypadku, gdy iptables wydają się zbyt skomplikowane aby je zrozumieć, lub
też ich skonfigurowanie zajmowałoby zbyt dużo czasu można skorzystać z programu
<uri link="http://www.shorewall.net">Shorewall</uri>. Jest to prosty w
konfiguracji firewall zabezpieczający komputer przy pomocy iptables.
</p>

</body>
</section>
<section>
<title>Squid.</title>
<body>

<p>
Squid to doskonały serwer proxy, dzięki któremu możemy filtrować ruch sieciowy w
oparciu o czas, wyrażenia regularne, źródłowy lub docelowy adres IP, domenę,
przeglądarkę, uwierzytelniane konta użytkowników, typ MIME, oraz numer portu
(wraz z protokołem).
</p> 

<p>
W poniższym przykładzie opisuję odfiltrowywanie bannerów zamiast filtrowania
treści pornograficznych. Robię tak ponieważ chcę uniknąć sytuacji, że Gentoo.org zostanie
zaindeksowane jako strona zawierająca treści porno, a poza tym nie mam czasu
na szukanie dla was ciekawych stron. 
</p>

<p>
Moja polityka wygląda następująco:
</p>

<ul>
<li>
Na surfowanie w Internecie (HTTP/HTTPS) zezwalamy jedynie w godzinach pracy
(poniedziałek-piątek 8-17, soboty 8-13). Jeśli pracownicy zostają po godzinach
powinni zajmować się pracą, a nie chodzeniem po Internecie.
</li>
<li>
Pobieranie plików nie jest dozwolone (żadych .exe, .com, .arj, .zip, .asf, .avi,
.mpg, .mpeg, etc)
</li>
<li>
Nie lubimy bannerów, więc będą one odfiltrowywane i zastępowane przezroczystym
gifem. (i to jest to miejsce, w którym trzeba uruchomić wyobraźnię...)
</li>
<li>
Wszystkie inne połączenie do i z Internetu są zabronione. 
</li>
</ul>

<p>
Implementowanie takiej polityki składa się z 4 <e>prostych</e> kroków.
</p>

<pre caption="/etc/squid/squid.conf">
# Bind to a ip and port
http_port 10.0.2.1:3128

# Standard configuration
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# Add basic access control lists
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# Add who can access this proxy server
acl localnet src 10.0.0.0/255.255.0.0

# And ports
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# Add access control list based on regular
# expressions within urls
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# Add access control list based on time and day
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#allow manager access from localhost
http_access allow manager localhost
http_access deny manager

# Only allow purge requests from localhost
http_access allow purge localhost
http_access deny purge

# Deny requests to unknown ports
http_access deny !Safe_ports

# Deny CONNECT to other than SSL ports
http_access deny CONNECT !SSL_ports

# My own rules

# Add a page do be displayed when
# a banner is removed
deny_info NOTE_ADS_FILTERED url_ads

# Then deny them
http_access deny url_ads

# Deny all archives
http_access deny archives

# Restrict access to work hours
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# Deny the rest
http_access deny all
</pre>

<p>
Następnie wypełniamy listę plików, na których pobieranie nie pozwalamy naszym
użytkownikom. Na liście są pliki zip, viv, exe, mp3, rar, ace, avi, mov, mpg,
mpeg, au, ra, arj, tar, gz i z.
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[Gg][Zz]$
\.[Zz]$
</pre>

<note>
Warto zwrócić uwagę na nawiasy [] zawierające małą i dużą literę. Dzięki
temu nikt nie oszuka naszego filtra poprzez wpisanie rozszerzenia pliku w wersji AvI
zamiast avi.
</note>

<p>
Następnie dodamy wyrażenie regularne dzięki którym będziemy identyfikować
bannery. Spodziewam się, że okażecie się tu znacznie bardziej kreatywni niż ja.
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
Ostatnią częścią całego procesu konfigurowania serwera proxy jest przygotowanie
pliku, który będzie wyświetlany zamiast usuniętego bannera. Jest to prosty plik
html zawierający plik gif o rozmiarach 4x4.
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
Nie należy zamykać tagów &lt;HTML&gt; &lt;BODY&gt;. Squid zrobi to za nas.
</note>

<p>
Jak widać Squid posiada bardzo szerokie możliwości i jest bardzo efektywny
zarówno jako filtr treści jak i serwer proxy. W dużych sieciach może z
łatwością współpracować z innymi serwerami proxy. Moja konfiguracja najlepiej
funkcjonuje w małych sieciach, składających się z góra 20 użytkowników.
</p>

<p>
Polecam używanie filtra pakietów (iptables) wraz z bramą aplikacyjną (Squid)
nawet jeśli serwer proxy znajduje się w bezpiecznym miejscu i nikt z zewnątrz
nie ma do niego dostępu. Zawsze istnieje możliwość ataku od wewnątrz.
</p>

<p>
Ostatnia kwestia to odpowiednie skonfigurowanie przeglądarek użytkowników, tak
aby korzystały z naszego serwera proxy. Brama uniemożliwi użytkownikom
jakikolwiek kontakt ze światem zewnętrzym sposobami innymi niż przez serwer
proxy.
</p>

<note>
W Mozilli dokonuje się tego w menu Edit->Preferences->Advanced->Proxies.
</note>

<p>
Można to również robić w sposób niewidoczny dla użytkownika (transparentny)
poprzez przekazanie przy pomocy iptables całego wychodzącego ruchu do serwera
proxy. Można tego dokonać poprzez dodanie do łańcuchów forwarding/prerouting
następującej reguły:
</p>

<pre caption="Konfigurowanie przekazywania portów do serwera proxy">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

<note>
Jeśli proxy działa na tym samym komputerze co filtr pakietów (nie polecamy
takiego rozwiązania, ale czasem z braku dodatkowych komputerów jest to konieczne)
należy użyć celu <c>REDIRECT</c> zamiast <c>DNAT</c> (<c>REDIRECT</c> kieruje
ruch na localhost).
</note>

</body>
</section>
<section>
<title>Czego się nauczyliśmy?</title>
<body>

<p>
Nauczyliśmy się, że:
</p>

<ol>
<li>
Zaimplementowanie firewalla może się wiązać z pewnym ryzykiem. Posiadanie źle
skonfigurowanego firewalla jest gorsze niż nie posiadanie go w ogóle.
</li>
<li>
Nauczyliśmy się konfigurowania transparentnego proxy.
</li>
<li>
Dowiedzieliśmy się, że warunkiem budowy solidnego firewalla jest dobra znajomość
protokołów sieciowych.
</li>
<li>
Wiemy, że ruch IP nie zawsze zawiera pożądane dane, np. pakiety ICMP mogą
zawierać szkodliwe informacje.
</li>
<li>
Umiemy zapobiegać atakom typu SYN.
</li>
<li>
Wiemy jak filtrować ruch HTTP, tak aby uniemożliwić pobieranie wirusów i
niestosownych treści.
</li>
<li>
Umiemy połączyć filtr pakietów z bramą aplikacyjną co zapewnia nam lepszą
kontrolę nad naszą siecią.
</li>
</ol>

<p>
Teraz, pod warunkiem, że jest to<e>naprawdę</e> niezbędne, należy przystąpić do
konfigurowania własnego, dostosowanego do indywidualnych potrzeb firewalla.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Wykrywanie włamań.</title>
<section>
<title>AIDE (Advanced Intrusion Detection Environment).</title>
<body>

<p>
AIDE jest systemem wykrywania włamań będącym darmową alternatywą dla Tripwire
(osoby dobrze znające Tripwire nie powinny mieć żadnych problemów z konfiguracją
AIDE). Systemów HID używa się do wykrywania zmian w ważnych systemowych plikach
konfiguracyjnych i binarnych. Dokonuje się tego poprzez utworzenie i
zachowanie unikalnych hashy każdego z tych plików. Co jakiś czas, zwykle
codziennie, przechowywane w bezpiecznym miejscu hashe są porównywane z nowo
utworzonymi hashami odpowiednich plików, co umożliwia wykrycie dokonanych w
nich zmian. HIDS jest więc doskonałym sposobem wykrywania wszelkiej niepożądanej
aktywności w naszym systemie, a jego jedyną wadą jest to, że odpowiednie
zaimplementowanie takiego systemu wymaga trochę pracy.
</p>

<p>
Plik konfiguracyjny jest oparty na wyrażeniach regularnych, makrach i regułach
dla plików oraz katalogów. Mamy do dyspozycji następujące makra:
</p>

<table>
<tr>
  <th>Makro</th>
  <th>Opis</th>
  <th>Składnia</th>
</tr>
<tr>
  <ti>ifdef</ti>
  <ti>"Jeśli zdefiniowano"</ti>
  <ti>@@ifdef "nazwa"</ti>
</tr>
<tr>
  <ti>ifndef</ti>
  <ti>"Jeśli nie zdefiniowano..."</ti>
  <ti>@@ifndef "nazwa"</ti>
</tr>
<tr>
  <ti>define</ti>
  <ti>Definiuje zmienną</ti>
  <ti>@@define "zmienna" "wartość"</ti>
</tr>
<tr>
  <ti>undef</ti>
  <ti>Usuwa zmienną</ti>
  <ti>@@undef "nazwa"</ti>
</tr>
<tr>
  <ti>ifhost</ti>
  <ti>Jeśli "nazwa hosta"...</ti>
  <ti>@@ifhost "nazwa hosta"</ti>
</tr>
<tr>
  <ti>ifnhost</ti>
  <ti>Jeśli nazwa hosta różna od "nazwa hosta"...</ti>
  <ti>@@ifnhost "nazwa hosta"</ti>
</tr>
<tr>
  <ti>endif</ti>
<ti>
Endif używa się po każdym z powyżyszych makr, poza define i undef.
</ti>
<ti>@@endif</ti>
</tr>
</table>

<p>
Makra te są bardzo pomocne kiedy administruje się więcej niż jednym komputerem z
Gentoo i chce się używać AIDE na każdym z nich. Należy jednak zwrócić uwagę, że
nie wszystkie komputery posiadają te same usługi i identyczne konta
użytkowników.
</p>

<p>
Kolejny zestaw wyrażeń to flagi dla plików i katalogów, czyli kombinacja praw
dostępu, właściwości plików i hashy (sum kontrolnych).
</p>

<table>
<tr>
  <th>Flaga</th>
  <th>Opis</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>prawa dostępu</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>inoda</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>liczba połączeń</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>użytkownik</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>grupa</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>rozmiar</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>ilość bloków</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>mtime</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>atime</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>ctime</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>sprawdza przyrost rozmiaru</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>suma kontrolna md5</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>suma kontrolna sha1</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>suma kontrolna rmd160</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>suma kontrolna tiger</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>Pusta grupa</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>Rosnący plik z logami p+u+g+i+n+S</ti>
</tr>
</table>

<p>
Ponadto jeśli AIDE zostanie skompilowane ze wsparciem dla mhash dostępne będą
dodatkowo takie opcje:
</p>

<table>
<tr>
<th>Flaga</th>
<th>Opis</th>
</tr>
<tr>
<ti>haval</ti>
<ti>suma kontrolna haval</ti>
</tr>
<tr>
<ti>gost</ti>
<ti>suma kontrolna gost</ti>
</tr>
<tr>
<ti>crc32</ti>
<ti>suma kontrolna crc32</ti>
</tr>
</table>

<p>
Przy użyciu powyższych flag można stworzyć własny zestaw reguł. Na przykład:
</p>

<pre caption="Zbór reguł dla AIDE">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
Ostatnią rzeczą jaką trzeba dopisać do pliku konfiguracyjnego są zasady obsługi
plików i katalogów. Regułę dodajemy poprzez dopisanie nazwy pliku bądź katalogu
wraz z odpowiednim zestawem flag. AIDE doda wszystkie możliwe pliki rekursywnie
o ile nie nakażemy inaczej.
</p>

<table>
<tr>
<th>Flaga</th>
<th>Opis</th>
</tr>
<tr>
<ti>!</ti>
<ti>Nie dodawać tego pliku bądź katalogu.</ti>
</tr>
<tr>
<ti>=</ti>
<ti>Dodaj ten katalog, ale nie rekursywnie.</ti>
</tr>
</table>

<p>
A oto przykładowy końcowy efekt:
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# The location of the database to be read.
database=file:@@{AIDEDIR}/aide.db

# The location of the database to be written.
database_out=file:aide.db.new

verbose=20
report_url=stdout

# Rule definition
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
W powyższym przykładzie definiujemy poprzez makra katalog główny oraz miejsce
gdzie zainstalowano AIDE. AIDE sprawdza plik <path>/etc/aide/aide.db</path> przy
kontrolowaniu integralności plików, ale podczas uaktualniania lub tworzenia
nowej bazy wszystkie informacje zapisuje do pliku
<path>/etc/aide/aide.db.new</path>. Robimy tak, aby zapobiec automatycznemu
nadpisaniu starego pliku z bazą danych. Opcja <c>report_URL</c> nie została
jeszcze zaimplementowana, autor zamierza dzięki niej umożliwić programowi
wysyłanie e-maili oraz wykonywanie skryptów.
</p>

<p>
Po zakończeniu etapu konfigurowania programu należy jeszcze utworzyć plik z bazą
danych - przy pomocy polecenia <c>aide -i</c> i skopiować plik
<path>/etc/aide/aide.db.new</path> na miejsce <path>/etc/aide/aide.db</path> oraz
dodać odpowiedni wpis do crona, przy użyciu polecenia <c>crontab -e</c> z konta
roota.
</p>

<note>
Zadanie to może zająć trochę czasu, w zależności od sprzętu i użytych flag.
</note>

<pre caption="Planowanie aide jako zadania dla crona">
0 3 * * * /usr/bin/aide -u
</pre>

<note>
Jeśli zapomni się o ustawieniu aliasu pocztowego, który będzie przekierowywał
całą pocztę roota na prywatne konto administratora to nigdy nie urjrzy się
żadnego z raportów AIDE.
</note>

<p>
W naszym przypadku test będzie uruchamiany co 24 godziny, o 3 w nocy. Postępujemy
tak, gdyż nie chcemy przeszkadzać użytkownikom w codziennej pracy. Warto zwrócić
uwagę na użycie opcji <c>-u</c> (uaktualnienie) zamiast <c>-C</c> (sprawdzanie).
Dzięki temu przy uaktualnianiu bazy danych nie zostanie nadpisany oryginalny jej
plik i jedynym co trzeba zrobić po wykryciu zmian będzie skopiowanie
jednego pliku na drugi. Zanim jednak to się zrobi należy się upewnić, że to my
dokonaliśmy wykrytej zmiany, a nie włamywacz. :]
</p>

<p>
Przechowywanie plików bazy danych na tym samym systemie, na którym dokonujemy
testów wiąże się z pewnym ryzykiem. Jeśli włamywacz będzie świadom tego, że
używamy AIDE zwykle spróbuje zmienić plik bazy danych, uaktualnić go po
wprowadzeniu zmian lub nawet zmodyfikować plik <path>/usr/bin/aide</path>. W
związku z tym warto rozważyć nagrywanie każdej kolejnej wersji pliku z bazą oraz
plików binarnych AIDE na płyty CD. 
</p>

<p>
Więcej informacji znajduje się na stronach projektu <uri
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri>.
</p>

</body>
</section>
<section>
<title>Snort.</title>
<body>

<p>
Snort jest to sieciowy system wykrywania włamań (NIDS - Network Intrusion
Detection System). Aby go zainstalować i skonfigurować należy wykonać
następujące czynności:
</p>

<pre caption="Dodawanie użytkownika snort do systemu">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<comment>(krok 1)</comment>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<comment>(krok 2)</comment>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<comment>(krok 3)</comment>
include classification.config

<comment>(krok 4)</comment>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# NEW CLASSIFICATIONS
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
Więcej informacji znajduje się na stronie projektu <uri
link="http://www.snort.org">Snort</uri>.
</p>

</body>
</section>
<section>
<title>Wykrywanie nieprawidłowości przy pomocy chkrootkit.</title>
<body>

<p>
HIDS taki jak AIDE to świetny sposób wykrywania niepożądanych zmian w
systemie. Warto jednak mieć też drugą linię obrony. <c>chkrootkit</c> to program
skanujący najważniejszy pliki systemowe pod kątem obecności rootkitów, czyli
programów pisanych, aby ukryć obecność włamywacza i pozwolić mu na zachowanie
dostępu do komputera. Program skanuje również system w poszukiwaniu śladów
loggerów klawiszy i innych niepożądanych programów. Jest to bardzo użyteczne
narzędzie, posiadające zresztą kilka podobnie działających alternatyw (jak
<c>rkhunter</c>). Mimo wszystko należy pamiętać, że żaden z nich nie gwarantuje
bezpieczeństwa systemu.
</p>

<p>
Najwygodniejszym sposobem korzystania z <c>chkrootkit</c> jako metody wykrywania
włamań jest uruchamianie go przy pomocy <c>crona</c>. Przede wszystkim trzeba go
jednak zainstalować - poleceniem emerge <c>app-admin/chkrootkit</c>.
<c>chkrootkit</c> może być uruchamiany z linii poleceń przy pomocy komendy o tej
samej nazwie, lub poprzez taki wpis w <c>cronie</c>:
</p>

<pre caption="Planownie chkrootkit jako zadania dla crona">
0 3 * * * /usr/sbin/chkrootkit
</pre>

</body>
</section>

</chapter>

<chapter>
<title>Aktualizowanie.</title>
<section>
<body>

<p>
Udana instalacja systemu i jego odpowiednie zabezpieczenie to nie wszystko.
Większość włamań do systemów udaje się dzięki wykorzystaniu znanych błędów
w starych wersjach programów. Częste aktualizowanie systemu jest niezbędne dla
zachowania odpowiedniego poziomu bezpieczeństwa.
</p>

<p>
Przede wszystkim należy się upewnić, że jest zainstalowana najnowsza wersja
<c>Portage</c>. Jeśli ją posiadamy wystarczy wydać polecenie <c>emerge
--sync</c> i zsynchronizować drzewo Portage, a następnie poleceniem
<c>glsa-check --list</c> sprawdzić czy system jest aktualny pod względem
bezpieczeństwa.
</p>

<pre caption="Przykładowy wynik glsa-check -l">
# <i>glsa-check -l</i>
WARNING: This tool is completely new and not very tested, so it should not be
used on production systems. It's mainly a test tool for the new GLSA release
and distribution system, it's functionality will later be merged into emerge
and equery.
Please read http://www.gentoo.org/proj/en/portage/glsa-integration.xml
before using this tool AND before reporting a bug.

[A] means this GLSA was already applied,
[U] means the system is not affected and
[N] indicates that the system might be affected.

200406-03 [N] sitecopy: Multiple vulnerabilities in included libneon ( net-misc/sitecopy )
200406-04 [U] Mailman: Member password disclosure vulnerability ( net-mail/mailman )
.......
</pre>

<warn>
Narzędzie <c>glsa-check</c> wciąż jest eksperymentalne warto więc sprawdzić
również inne źródła informacji, zwłaszcza jeśli naszym głównym priorytetem jest
maksymalne bezpieczeństwo.
</warn>

<p>
Wszystkie linie zawierające <c>[A]</c> oraz <c>[U]</c> mogą zostać zignorowane
ponieważ oznaczają, że system nie jest podatny na błąd opisany w określonym GLSA.
</p>

<p>
Niektórzy ludzie wolą mimo wszystko korzystanie z <c>emerge
nazwa_paczki</c> zamiast używania <c>glsa-check -f</c>. W związku z tym
wszystkie GLSA będą wymieniane jako <c>[N]</c>.
</p>

<p>
Aby otrzymywać mail za każdym razem gdy wypuszczane jest GLSA należy
najpierw zapisać się do listy mailingowej <c>gentoo-announce</c>. Instrukcje na
temat dołączania do tej i innych list mailingowych można znaleźć na stronie
<uri link="/main/en/lists.xml">Gentoo Linux Mailing List Overview</uri>.
</p>

<p>
Świetnym źródłem informacji dotyczących bezpieczeństwa jest
<uri
link="http://www.securityfocus.com/archive/1">lista mailingowa bugtraq</uri>.
</p>

</body>
</section>
</chapter>
</guide>
