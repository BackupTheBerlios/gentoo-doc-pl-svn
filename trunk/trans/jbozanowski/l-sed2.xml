<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/articles/l-sed2.xml,v 1.2 2005/08/15 23:16:06 cam Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/articles/l-sed2.xml" lang="pl"> 
<title>Sed w przykładach, Część druga</title>

<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Redaktor">
  <mail link="rane@gentoo.org">Łukasz Damentko</mail>
</author>
<author title="Tłumaczenie">
  <mail link="jbozanowski@gmail.com">Kuba Bożanowski</mail>
</author>

<abstract>
Sed jest rozbudowanym i podręcznym edytorem strumieni tekstowych. W tym
artykule, który jest drugim z kolei, Daniel ukaże nam jak użyć seda do 
podstawiania łańcuchów tekstowych; tworzyć większe skrypty seda; oraz używać 
komend dołącz, wstaw oraz zmień linię. FIXME
</abstract>

<!-- Pierwotna wersja tego artykułu została opublikowana przez IBM
developerWorks i jest własnością Westtech Information Services. Niniejszy
dokument jest uaktualnioną wersją pierwotnego artykułu i zawiera liczne
usprawnienia dokonane przez zespół Dokumentacji systemu Gentoo Linux FIXME -->

<!-- The original version of this article was published on IBM developerWorks,
and is property of Westtech Information Services. This document is an updated
version of the original article, and contains various improvements made by the
Gentoo Linux Documentation team -->

<version>1.0</version>
<date>2005-07-15</date>

<chapter>
<title>Jak jeszcze lepiej wykorzystać edytor tekstowy systemu UNIX</title>
<section>
<title>Podstawianie!</title>
<body>

<note>
Pierwotna wersja tego artykułu została opublikowana przez IBM
developerWorks i jest własnością Westtech Information Services. Niniejszy
dokument jest uaktualnioną wersją pierwotnego artykułu i zawiera liczne
usprawnienia dokonane przez zespół Dokumentacji systemu Gentoo Linux. FIXME
</note>

<p>
Przyjrzyjmy się jednej z najbardziej przydatnych komend edytora sed,
podstawieniu. Przy jej pomocy możemy zastąpić określony ciąg znaków lub
dopasowane wyrażenie regularne innym ciągiem znaków. Oto przykład najbardziej
elementarnego zastosowania tej komendy:
</p>

<pre caption="Najbardziej elementarne zastosowanie komendy podstawienia">
$ <i>sed -e 's/cos/cosinnego/' mojplik.txt</i>
$ <i>sed -e 's/foo/bar/' myfile.txt</i>
</pre>

<p>
Powyższe polecenie wypisze na standardowe wyjście zawartość pliku FIXME 
myfile.txt, zastępując w każdej linii pierwsze wystąpienie napisu 'foo' 
(o ile w ogóle wystąpi) napisem 'bar'. Zauważmy, że napisałem o pierwszym
wystąpieniu w każdej linii, pomimo iż zwykle nie o to nam chodzi. Najczęściej
gdy wykonuję podstawienie napisu, chcę tego dokonać globalnie. Oznacza to, że
chcę zastąpić wszystkie wystąpienia napisu w każdej linii, w ten sposób:
</p>

<pre caption="Zastępowanie wszystkich wystąpień w każdej linii">
$ <i>sed -e 's/foo/bar/g' myfile.txt</i>
</pre>

<p>
Dodatkowa opcja 'g' po ostatnim ukośniku mówi sedowi, aby wykonał globalne
podstawienie.
</p>

<p>
Powinniśmy wiedzieć jeszcze kilka rzeczy o komendzie <c>s///</c>. Po pierwsze,
mówiliśmy wyłącznie o komendzie; w powyższych przykładach nie podawaliśmy
adresów. Oznacza to, że możemy użyć polecenia <c>s///</c> wraz z adresem, aby
kontrolować, do których wierszy będzie ona zastosowana. Robimy to w następujący
sposób:
</p>

<pre caption="Określanie wierszy, do których komenda zostanie zastosowana">
$ <i>sed -e '1,10s/enchantment/entrapment/g' myfile2.txt</i>
</pre>

<p>
Powyższy przykład sprawi, że wszystkie wystąpienia wyrazu 'enchantment' zostaną
zastąpione wyrazem 'entrapment', ale tylko w wierszach od pierwszego do
dziesiątego włącznie.
</p>

<pre caption="Podawanie dalszych opcji">
$ <i>sed -e '/^$/,/^END/s/hills/mountains/g' myfile3.txt</i>
</pre>

<p>
W tym przykładzie wyraz 'hills' zostanie zastąpiony wyrazem 'mountains', ale
tylko w tych blokach tekstu, które zaczynają się pustą linią, a kończą linią
zaczynającą się od liter 'END' włącznie. 
</p>

<p>
Kolejną miłą rzeczą dotyczącą komendy <c>s///</c> jest mnogość opcji dotyczących
separatorów <c>/</c>. Jeśli chcemy dokonać podstawienia napisów i wyrażenie
regularnie lub napis, który chcemy zmienić zawiera wiele ukośników, możemy
zmienić separator, podając inny znak po literze 's'. Zilustrujmy to przykładem,
w którym zamienimy wszystkie wystąpienia <path>/usr/local</path> na 
<path>/usr</path>:
</p>

<pre caption="Zamiana wszystkich wystąpień napisu innym napisem">
$ <i>sed -e 's:/usr/local:/usr:g' mylist.txt</i>
</pre>

<note>
W powyższym przykładzie użyliśmy dwukropka jako separatora. Jeśli musielibyśmy 
użyć znaku separatora w wyrażeniu regularnym, należałoby poprzedzić go 
odwrotnym ukośnikiem. 
</note>

</body>
</section>
<section>
<title>FIXME Regexp snafus</title>
<body>

<p>
Do tej pory wykonywaliśmy jedynie podstawienia zwykłych napisów. Mimo iż często
się to przydaje, to jednak możemy zrobić to samo dla wyrażeń regularnych.
Poniższa komenda znajdzie frazę rozpoczynającą się znakiem '&lt;' i kończącą się
znakiem '&gt;', posiadającą dowolną ilość znaków pomiędzy nimi. Fraza ta
zostanie skasowana (zastąpiona pustym napisem):
</p>

<pre caption="Kasowanie podanej frazy">
$ <i>sed -e 's/&lt;.*&gt;//g' myfile.html</i>
</pre>

<p>
Jest to dobry początek skryptu, który usunie tagi języka HTML z pliku, jednakże
nie zadziała dobrze ze względu na pewną właściwość wyrażeń regularnych.
Mianowicie, gdy sed szuka wyrażenia regularnego w linii, znajduje najdłuższe
możliwe dopasowanie w tej linii. Nie było to problemem w poprzednim artykule o
sedzie, ponieważ używaliśmy komend <c>d</c> i <c>p</c>, które tak czy inaczej
skasują lub wypiszą całą linię. W przypadku komendy <c>s///</c> nie odpowiada
nam to, ponieważ cały dopasowany fragment tekstu zostanie zastąpiony przez
docelowy napis, a w tym przypadku skasowany. Oznacza to, że powyższy przykład
zamieni poniższą linię:
</p>

<pre caption="Przykładowy kod HTML">
&lt;b&gt;This&lt;/b&gt; is what &lt;b&gt;I&lt;/b&gt; meant.
</pre>

<p>
W tę:
</p>

<pre caption="Niepożądany wynik">
meant.
</pre>

<p>
Zamiast w tę, czyli w to, co chcieliśmy osiągnąć:
</p>

<pre caption="Pożądany wynik">
This is what I meant.
</pre>

<p>
Na szczęście da się temu zaradzić. Zamiast wyrażenia regularnego, które znajdzie
"dowolną ilość znaków, poprzedzoną znakiem '&lt;' i zakończoną znakiem '&gt;'"
musimy użyć takiego, które odnajdzie "dowolną ilość znaków różnych od znaku
'&gt;', poprzedzoną znakiem '&lt;' i zakończoną znakiem '&gt;'". W ten sposób
znajdziemy najkrótsze możliwe dopasowanie, zamiast najdłuższego. Nowe polecenie
powinno wyglądać tak:
</p>

<pre caption="">
$ <i>sed -e 's/&lt;[^&gt;]*&gt;//g' myfile.html</i>
</pre>

<p>
W powyższym przykładzie wyrażenie '[^&gt;]' oznacza "znak różny od '&gt;'", 
a symbol "*" uzupełnia je o znaczenie 'zero lub więcej znaków różnych od
'&gt;'". Warto wypróbować to polecenie na kilku przykładowych plikach html,
przeglądając wyniki za pomocą programu more.
</p>

</body>
</section>
<section>
<title>FIXME More character matching</title>
<body>

<p>
Składnia wyrażenia regularnego '[ ]' oferuje jeszcze kilka możliwości. Możemy 
określić zakres znaków za pomocą symbolu '-', o ile nie znajduje się on na
pierwszym lub ostatnim miejscu:
</p>

<pre caption="Podawanie zakresu znaków">
'[a-x]*'
</pre>

<p>
W ten sposób wyszukamy zero lub więcej znaków, dopóki wszystkie należeć będą do
zbioru 'a','b','c'...'v','w','x'. Oprócz tego dysponujemy klasą znakową
'[:space:]' do znajdywania odstępu. Poniżej znajduje się prawie kompletna lista
dostępnych klas znakowych. 
</p>


<table>
  <tr>
    <th>Klasa znakowa</th>
    <th>Opis</th>
  </tr>
  <tr>
    <ti>[:alnum:]</ti>
    <ti>Alfanumeryczne [a-z A-Z 0-9]</ti>
  </tr>
  <tr>
    <ti>[:alpha:]</ti>
    <ti>Alfabetyczne [a-z A-Z]</ti>
  </tr>
  <tr>
    <ti>[:blank:]</ti>
    <ti>Spacje lub tabulatory</ti>
  </tr>
  <tr>
    <ti>[:cntrl:]</ti>
    <ti>Dowolny znak kontrolny</ti>
  </tr>
  <tr>
    <ti>[:digit:]</ti>
    <ti>Cyfry [0-9]</ti>
  </tr>
  <tr>
    <ti>[:graph:]</ti>
    <ti>Znaki drukowalne (bez odstępów)</ti>
  </tr>
  <tr>
    <ti>[:lower:]</ti>
    <ti>Małe litery [a-z]</ti>
  </tr>
  <tr>
    <ti>[:print:]</ti>
    <ti>Znaki drukowalne z odstępami</ti>
  </tr>
  <tr>
    <ti>[:punct:]</ti>
    <ti>Znaki drukowalne za wyjątkiem odstępów, liter i cyfr</ti>
  </tr>
  <tr>
    <ti>[:space:]</ti>
    <ti>Wszystkie znaki odstępu</ti>
  </tr>
  <tr>
    <ti>[:upper:]</ti>
    <ti>Duże litery [A-Z]</ti>
  </tr>
  <tr>
    <ti>[:xdigit:]</ti>
    <ti>Cyfry w systemie szesnastkowym [0-9 a-f A-F]</ti>
  </tr>
</table>

<p>
Używanie klas znakowych wszędzie tam, gdzie to możliwe jest wysoce pożądane, 
ponieważ znakomicie dopasowują się one do innych niż angielskie zestawów 
znaków (uwzględniając znaki akcentowane, itd).
</p>

</body>
</section>
<section>
<title>Zaawansowane podstawianie</title>
<body>

<p>
We've looked at how to perform simple and even reasonably complex straight
substitutions, but sed can do even more. We can actually refer to either parts
of or the entire matched regular expression, and use these parts to construct
the replacement string. As an example, let's say you were replying to a message.
The following example would prefix each line with the phrase "ralph said: ":
</p>

<pre caption="Prefixing each line with certain string">
$ <i>sed -e 's/.*/ralph said: &amp;/' origmsg.txt</i>
</pre>

<p>
The output will look like this:
</p>

<pre caption="Output of the above command">
ralph said: Hiya Jim,
ralph said:
ralph said: I sure like this sed stuff!
ralph said:
</pre>

<p>
In this example, we use the '&amp;' character in the replacement string,
which tells sed to insert the entire matched regular expression. So, whatever
was matched by '.*' (the largest group of zero or more characters on the line,
or the entire line) can be inserted anywhere in the replacement string, even
multiple times. This is great, but sed is even more powerful.
</p>

</body>
</section>
<section>
<title>Those wonderful backslashed parentheses</title>
<body>

<p>
Even better than '&amp;', the <c>s///</c> command allows us to define regions in
our regular expression, and we can refer to these specific regions in our
replacement string. As an example, let's say we have a file that contains the
following text:
</p>

<pre caption="Sample text">
foo bar oni
eeny meeny miny
larry curly moe
jimmy the weasel
</pre>

<p>
Now, let's say we wanted to write a sed script that would replace "eeny meeny
miny" with "Victor eeny-meeny Von miny", etc. To do this, first we would write a
regular expression that would match the three strings, separated by spaces:
</p>

<pre caption="Matching regular expression">
'.* .* .*'
</pre>

<p>
There. Now, we will define regions by inserting backslashed parentheses around
each region of interest:
</p>

<pre caption="Defining regions">
'\(.*\) \(.*\) \(.*\)'
</pre>

<p>
This regular expression will work the same as our first one, except that it will
define three logical regions that we can refer to in our replacement string.
Here's the final script:
</p>

<pre caption="Final script">
$ <i>sed -e 's/\(.*\) \(.*\) \(.*\)/Victor \1-\2 Von \3/' myfile.txt</i>
</pre>

<p>
As you can see, we refer to each parentheses-delimited region by typing '\x',
where x is the number of the region, starting at one. Output is as follows:
</p>

<pre caption="Output of the above command">
Victor foo-bar Von oni
Victor eeny-meeny Von miny
Victor larry-curly Von moe
Victor jimmy-the Von weasel
</pre>

<p>
As you become more familiar with sed, you will be able to perform fairly
powerful text processing with a minimum of effort. You may want to think about
how you'd have approached this problem using your favorite scripting language --
could you have easily fit the solution in one line?
</p>

</body>
</section>
<section>
<title>Mixing things up</title>
<body>

<p>
As we begin creating more complex sed scripts, we need the ability to enter more
than one command. There are several ways to do this. First, we can use
semicolons between the commands. For example, this series of commands uses the
'=' command, which tells sed to print the line number, as well as the <c>p</c>
command, which explicitly tells sed to print the line (since we're in '-n'
mode):
</p>

<pre caption="First method, semicolons">
$ <i>sed -n -e '=;p' myfile.txt</i>
</pre>

<p>
Whenever two or more commands are specified, each command is applied (in order)
to every line in the file. In the above example, first the '=' command is
applied to line 1, and then the <c>p</c> command is applied. Then, sed proceeds
to line 2, and repeats the process. While the semicolon is handy, there are
instances where it won't work. Another alternative is to use two -e options to
specify two separate commands:
</p>

<pre caption="Second method, multiple -e">
$ <i>sed -n -e '=' -e 'p' myfile.txt</i>
</pre>

<p>
However, when we get to the more complex append and insert commands, even
multiple '-e' options won't help us. For complex multiline scripts, the best way
is to put your commands in a separate file. Then, reference this script file
with the -f options:
</p>

<pre caption="Third method, external file with commands">
$ <i>sed -n -f mycommands.sed myfile.txt</i>
</pre>

<p>
This method, although arguably less convenient, will always work.
</p>

</body>
</section>
<section>
<title>Multiple commands for one address</title>
<body>

<p>
Sometimes, you may want to specify multiple commands that will apply to a single
address. This comes in especially handy when you are performing lots of
<c>s///</c> to transform words or syntax in the source file. To perform multiple
commands per address, enter your sed commands in a file, and use the '{ }'
characters to group commands, as follows:
</p>

<pre caption="Entering multiple commands per address">
1,20{
	s/[Ll]inux/GNU\/Linux/g
	s/samba/Samba/g
	s/posix/POSIX/g
}
</pre>

<p>
The above example will apply three substitution commands to lines 1 through 20,
inclusive. You can also use regular expression addresses, or a combination of
the two:
</p>

<pre caption="Combination of both methods">
1,/^END/{
        s/[Ll]inux/GNU\/Linux/g 
        s/samba/Samba/g 
        s/posix/POSIX/g 
	p
}
</pre>

<p>
This example will apply all the commands between '{ }' to the lines starting at
1 and up to a line beginning with the letters "END", or the end of file if
"END" is not found in the source file.
</p>

</body>
</section>
<section>
<title>Append, insert, and change line</title>
<body>

<p>
Now that we're writing sed scripts in separate files, we can take advantage of
the append, insert, and change line commands. These commands will insert a line
after the current line, insert a line before the current line, or replace the
current line in the pattern space. They can also be used to insert multiple
lines into the output. The insert line command is used as follows:
</p>

<pre caption="Using the insert line command">
i\
This line will be inserted before each line
</pre>

<p>
If you don't specify an address for this command, it will be applied to each
line and produce output that looks like this:
</p>

<pre caption="Output of the above command">
This line will be inserted before each line
line 1 here
This line will be inserted before each line
line 2 here
This line will be inserted before each line
line 3 here
This line will be inserted before each line
line 4 here
</pre>

<p>
If you'd like to insert multiple lines before the current line, you can add
additional lines by appending a backslash to the previous line, like so:
</p>

<pre caption="Inserting multiple lines before the current one">
i\
insert this line\
and this one\
and this one\
and, uh, this one too.
</pre>

<p>
The append command works similarly, but will insert a line or lines after the
current line in the pattern space. It's used as follows:
</p>

<pre caption="Appending lines after the current one">
a\
insert this line after each line.  Thanks! :)
</pre>

<p>
On the other hand, the "change line" command will actually replace the current
line in the pattern space, and is used as follows:
</p>

<p>
Because the append, insert, and change line commands need to be entered on
multiple lines, you'll want to type them in to text sed scripts and tell sed to
source them by using the '-f' option. Using the other methods to pass commands
to sed will result in problems.
</p>

</body>
</section>
<section>
<title>Next time</title>
<body>

<p>
Next time, in the final article of this series on sed, I'll show you lots of
excellent real-world examples of using sed for many different kinds of tasks.
Not only will I show you what the scripts do, but why they do what they do.
After you're done, you'll have additional excellent ideas of how to use sed in
your various projects. I'll see you then!
</p>

</body>
</section>
</chapter>

<chapter>
<title>Resources</title>
<section>
<title>Useful links</title>
<body>

<ul>
  <li>
    Read Daniel's other sed articles from developerWorks: Common threads: Sed by
    example, <uri link="l-sed1.xml">Part 1</uri> and <uri
    link="l-sed3.xml">Part 3</uri>.
  </li>
  <li>
     Check out Eric Pement's excellent <uri
     link="http://www.student.northpark.edu/pemente/sed/sedfaq.html">sed
     FAQ</uri>.
  </li>
  <li>
     You can find the sources to sed 3.02 at
     <uri>ftp://ftp.gnu.org/pub/gnu/sed</uri>.
  </li>
  <li>
     You'll find the nice, new sed 3.02.80 at <uri>ftp://alpha.gnu.org</uri>.
  </li>
  <li>
    Eric Pement also has a handy list of <uri
    link="http://www.student.northpark.edu/pemente/sed/sed1line.txt">sed
    one-liners</uri> that any aspiring sed guru should definitely look at.
  </li>
  <li>
    If you'd like a good old-fashioned book, <uri
    link="http://www.oreilly.com/catalog/sed2/">O'Reilly's sed &amp; awk, 2nd
    Edition</uri> would be wonderful choice.
  </li>
<!-- FIXME BOTH DEAD and no other locations, sorry
 <li>
    Maybe you'd like to read <uri
    link="http://www.softlab.ntua.gr/unix/docs/sed.txt">7th edition UNIX's sed
    man page</uri> (circa 1978!).
  </li>
  <li>
    Take Felix von Leitner's short <uri
    link="http://www.math.fu-berlin.de/~leitner/sed/tutorial.html">sed
    tutorial</uri>.
  </li>
-->
    <li>
    Brush up on <uri link="http://vision.eng.shu.ac.uk/C++/misc/regexp/">using
    regular expressions</uri> to find and modify patterns in text in this free,
    dW-exclusive tutorial.
  </li>
</ul>

</body>
</section>
</chapter>

</guide>
