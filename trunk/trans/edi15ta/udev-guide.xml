<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<!-- $Header: $ -->

<guide link="/doc/pl/dev-guide.xml" lang="pl">
<title>Praca z udev w Gentoo</title>

<author title="Autor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Współpracownik">
  <mail link="greg_g@gentoo.org">Gregorio Guidi</mail>
</author>
<author title="Tłumaczenie">
        <mail link="edi15ta@gazeta.pl">Mateusz Kotyrba</mail>
</author>

<abstract>
Ten dokument wyjaśnia czym jest udev i jak go można używać, aby sprostał
naszym wymaganiom.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>0.21</version>
<date>2005-08-12</date>

<chapter>
<title>Czym jest udev?</title>
<section>
<title>Katalog /dev</title>
<body>

<p>
Kiedy użytkownicy Linuksa rozmawiają o ich sprzęcie w pobliżu ludzi, którzy
wierzą, że Linux jest pewnego rodzaju wirusem lub gatunkiem kawy, użycie słów
"ukosnik dev ukośnik cośtam" spowoduje, że zaczną się oni dziwnie na nich
patrzeć. Ale szczęśliwy użytkownik (i to jesteśmy my) używając
<path>/dev/hda1</path> skrótowo wyjaśnia, że rozmowa tyczy się pierwszej
partycji na dysku, który jest podpięty jako primary master. Czy nie mam racji?
</p>

<p>
Wszyscy wiemy czym jest plik urządzenia. Niektórzy nawet wiedzą dlaczego pliki
urządzeń posiadają specjalne numery, które widać wykonując polecenie
<c>ls -l</c> w <path>/dev</path>. Ale zawsze dysk podpięty jako primary master
jest widoczny jako <path>/dev/hda</path>. Można tego nie widzieć w ten sposób,
ale jest to wada projektu.
</p>

<p>
Pomyślmy o urządzeniach typu hotplug takich jak USB, IEEE1394, PCI,... Co jest
pierwszym urządzeniem? I na jak długo? Jak będą inne urządzenia nazwane, kiedy
to pierwsze zninknie? Jaki to będzie miało wpływ na inne procesy?  Czyż nie
byłoby to zabawne gdyby zadanie do drukowania zostało nagle przeniesione z
naszej nowiutkiej drukarki laserowej do naszej zrupieciałej drukarki mozaikowej,
ponieważ mama zdecydowała się wyciągnąć wtyczkę drukarki laserowej z kontaktu,
która była pierwszą drukarką?
</p>

<p>
Wchodzimy do <e>udev</e>. Głównymi cele projektu udev są zarówno ciekawe jak i
konieczne:
</p>

<ul>
  <li>Działa w przestrzeni użytkownika</li>
  <li>Dynamicznie tworzy lub usuwa pliki urządzeń</li>
  <li>Dostarcza spójne nazewnictwo</li>
  <li>Dostarcza interfejsu API przestrzeni użytkownika</li>
</ul>

<p>
Aby dostarczyć te cechy, udev jest rozwijany w trzech odrębnych projektach:
<e>namedev</e>, <e>libsysfs</e> oraz <e>udev</e>.
</p>

</body>
</section>
<section>
<title>namedev</title>
<body>

<p>
Namedev pozwala nam zdefiniować odrębne nazewnictwo od programu udev. To pozwala
na elastyczne polityki i schematy nazewnictwa rozwijane przez odrębne jednostki.
Ten podsystem nazewnictwa urządzeń dostarcza standardowego interfejsu, którego
może używać udev.
</p>

<p>
Obecnie namedev dostarcza tylko jeden schemat nazewnictwa - LANANA, który jest
używany przez większość obecnych systemów Linuksowych, a zatem pasuje on
większości użytkowników Linuksa.
</p>

<p>
Namedev używa pięciostopniowej procedury pozyskiwania nazwy urządzenia. Jeśli
nazwa urządzenia zostanie znalziona w tych pięciu krokach, wtedy ta nazwa
zostaje użyta. Są nimi
</p>

<ul>
  <li>etykieta lub numer seryjny</li>
  <li>numer urządzenia magistrali</li>
  <li>topologia magistrali</li>
  <li>statycznie przydzielana nazwa</li>
  <li>nazwa dostarczona przez jądro</li>
</ul>

<p>
 Krok <e>etykieta lub numer seryjny</e> sprawdza czy urządzenie posiada
 jednoznaczny identyfikator. Na przykład urządzenia USB posiadają unikalny numer
 seryjny, urządzenia SCSI posiadają unikalny UUID. Jeśli namedev znajdzie
 odpowiednią nazwę wtedy zostanie ona użyta.
</p>

<p>
Krok <e>numer urządzenia magistrali</e> sprawdza numer urządzenia magistrali. W
środowisku  step checks the device bus number. Dla systemów, które nie mają
możliwości podłączania urządzeń w trakcie pracy, ten krok jest wystarczający.
Na przykład numery magistrali bardzo rzadko są zmieniane. Ponownie jeśli namedev
znajdzie odpowiednią nazwę wtedy zostanie ona użyta. 
</p>

<p>
Podobnie krok <e>topologia magistrali</e> jest statycznym sposobem
przydzielania nazw, po warunkiem, że użytkownik nie zamieni urządzeń. Jeśli
pozycja urządzenia będzie zgodna z tym co podał użytkownik, wtedy nazwa temu
towarzysząca zostanie użyta.
</p>

<p>
Krok czwarty, <e>statycznie przydzielana nazwa</e>, jest prostym zastępowaniem
ciągów znaków. Kiedy nazwa dostarczona przez jądro (domyślna nazwa) pasuje do
danego ciągu znaków, wtedy ten ciąg zostanie zastąpiony.
</p>

<p>
Ostatnim krokiem (<e>nazwa dostarczona przez jądro</e>) jest nadanie wszystkim
urządzeniom domyślnej nazwy dostarczonej wraz z jądrem. Większości systemów
Linuksowych ten krok jest wystarczający.
</p>

</body>
</section>
<section>
<title>libsysfs</title>
<body>

<p>
udev komunikuje się z jądrem poprzez pseudo system plików sysfs. Projekt
libsysfs dostarcza interfejsu API, który zezwala na dostęp do informacji danych
przez system plików sysfs. To pozwala na sprawdzenie całego sprzętu bez
konieczności posiadania wiedzy jakiego typu sprzęt jest sprawdzany.
</p>

</body>
</section>
<section>
<title>udev</title>
<body>

<p>
Za każdym razem kiedy jądro zauważy zmianę w drzewie urządzeń, przywołuje ono
program <path>/sbin/hotplug</path>. Hotplug uruchamia aplikacje dowiązane w
katalogu <path>/etc/hotplug.d/default</path>, w którym to znajdziemy również
dowiązanie symboliczne do aplikacji udev. Hotplug przekierowywuje informacje
dane przez jądro do aplikacji udev, która wykona wymagane czyności na strukturze
<path>/dev</path> (tworząc lub usuwając pliki urządzeń).
</p>

</body>
</section>
</chapter>

<chapter>
<title>Praca z udev w Gentoo</title>
<section>
<title>Wymagania</title>
<body>

<p>
udev został stworzony do pracy wraz jądrem 2.6 (na przykład
<c>vanilla-sources</c> lub <c>gentoo-sources</c> w domyślnym profilu 2005.0).
Jeśli używamy takiego jądra, wtedy należy się upewnić, że posiadamy najnowszą
wersj pakietu <c>sys-apps/baselayout</c>.
</p>

<pre caption="Instalacja udev">
# <i>emerge udev</i>
</pre>

<p>
udev, jako jedną ze swoich zależności, zainstaluje <c>hotplug-base</c>.
Instalacja <c>hotplug</c> nie jest wymagana dopóki nie będziemy chcieli mieć
automatycznie załadowanych modułów po podpięciu dowolnego urządzenia.
<c>hotplug</c> zarządza również zautomatyzowanym uruchamianiem urządzeń
sieciowych oraz ściąganiem oprogramowania sieciowego.
</p>

<pre caption="Opcjonalna instalacja skryptów hotplug">
# <i>emerge hotplug</i>
</pre>

<p>
If you want modules loaded for devices that have been plugged in before you
boot, use the coldplug package:
</p>

<pre caption="Instalacja pakietu coldplug">
# <i>emerge coldplug</i>
</pre>

<p>
Nie należy zapomnieć o dodaniu <c>coldplug</c> do poziomu uruchamiania o nazwie
"boot":
</p>

<pre caption="Dodawanie coldplug do poziomu uruchamiania o naziwe "boot"">
# <i>rc-update add coldplug boot</i>
</pre>

<p>
Użytkownicy korzystający z ręcznie kompilowanego jądra muszą włączyć następujące
opcje:
</p>

<pre caption="Wymagane opcje jądra">
General setup ---&gt;
  [*] Support for hot-pluggable devices

File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /proc file system support
    [*] Virtual memory file system support (former shm fs)
</pre>

<p>
Opcję <c>/dev file system support (OBSOLETE)</c> można zostawić włączoną, przy
czym opcja "Automatically mount at boot" musi być wyłączona:
</p>

<pre caption="Nie należy montować automatycznie devfsd">
File systems ---&gt;
  Pseudo Filesystems ---&gt;
    [*] /dev file system support (OBSOLETE)
      [ ]   Automatically mount at boot
</pre>

<p>
Użytkownicy <c>genkernela</c>, muszą uruchomić ten skrypt z flagą <c>--udev</c>,
aby włączyć wszystkie instrukcje konfigurujące jądro. Jednak domyślna
konfiguracja wykonana przez samo polecenie <c>genkernel</c> również wystarczy do
prawidłowego uruchomienia systemu.
</p>

</body>
</section>
<section>
<title>Konfiguracja</title>
<body>

<p>
If you want to use the udev-tweaks Gentoo added to make your life
comfortable, then read no more. Gentoo will use udev but keep a static
<path>/dev</path> so that you will never have any missing device nodes.
The Gentoo init scripts won't run the devfsd daemon and will deactivate devfs
when you boot up.
</p>

<p>
But if you are a die-hard and want to run a udev-only, no-tweaked system as is
intended by the udev development (including the difficulties of missing device
nodes because udev doesn't support them yet), by all means, read on :)
</p>

<p>
We'll deactivate the rules that save the device file nodes: edit the
<c>RC_DEVICE_TARBALL</c> variable in <path>/etc/conf.d/rc</path> and set it to
<c>no</c>:
</p>

<pre caption="/etc/conf.d/rc">
RC_DEVICE_TARBALL="no"
</pre>

<p>
If you have included devfs support in your kernel, you can deactivate it in
the bootloader configuration: add <c>gentoo=nodevfs</c> as a kernel parameter.
If you want to use devfs and deactivate udev, add <c>gentoo=noudev</c> as
kernel
parameter.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Znane problemy</title>
<section>
<title>Brakujące pliki węzła urządzenia podczas ładowania systemu</title>
<body>

<p>
If you can't boot successfully because you get an error about
<path>/dev/null</path> not found, or because the initial console is missing,
the
problem is that you lack some device files that must be available
<e>before</e>
<path>/dev</path> is mounted and handled by udev. This is common on Gentoo
machines installed from old media.
</p>

<p>
If you run <c>sys-apps/baselayout-1.8.12</c> or later, this problem is
alleviated since the boot process should still manage to complete. However, to
get rid of those annoying warnings, you should create the missing device nodes
as described below.
</p>

<p>
To see which devices nodes are present before the <path>/dev</path> filesystem
is mounted, run the following commands:
</p>

<pre caption="Wyświetlanie węzłów urządzeń dostępnych podczas uruchamiania
	systemu">
# <i>mkdir test</i>
# <i>mount --bind / test</i>
# <i>cd test/dev</i>
# <i>ls</i>
</pre>

<p>
The devices needed for a successful boot are <path>/dev/null</path> and
<path>/dev/console</path>. If they didn't show up in the previous test, you
have
to create them manually. Issue the following commands in the
<path>test/dev/</path> directory:
</p>

<pre caption="Tworzenie wymaganych plików węzłów urządzeń">
# <i>mknod -m 660 console c 5 1</i>
# <i>mknod -m 660 null c 1 3</i>
</pre>

<p>
When you're finished, don't forget to unmount the <path>test/</path>
directory:
</p>

<pre caption="Odmontowywanie katalogu test/ ">
# <i>cd ../..</i>
# <i>umount test</i>
# <i>rmdir test</i>
</pre>

</body>
</section>
<section>
<title>udev i nvidia</title>
<body>

<p>
If you use the proprietary driver from nVidia and the X server fails to start
on
a udev-only system, then make sure you have:
</p>

<ul>
  <li>
    the <c>nvidia</c> module listed in
    <path>/etc/modules.autoload.d/kernel-2.6</path>
  </li>
  <li>
    a version of <c>nvidia-kernel</c> equal to or greater than
    <c>media-video/nvidia-kernel-1.0.5336-r2</c>
  </li>
  <li>
    a version of baselayout equal to or greater than
    <c>sys-apps/baselayout-1.8.12</c>
  </li>
</ul>

</body>
</section>
<section>
<title>LVM2 Names Disappear</title>
<body>

<p>
When you use <c>udev</c> and LVM2 together, you might notice that your created
volume groups and logical volumes have disappeared. Well, they haven't, but
they
are unfortunately named <path>/dev/dm-#</path> with # being 0, 1, ...
</p>

<p>
To fix this, edit <path>/etc/udev/rules.d/50-udev.rules</path> and uncomment
the
following line:
</p>

<pre caption="Uncomment this line from /etc/udev/rules.d/50-udev.rules">
KERNEL="dm-[0-9]*",     PROGRAM="/sbin/devmap_name %M %m", NAME="%k",
SYMLINK="%c"
</pre>

<p>
Next, install <c>sys-fs/multipath-tools</c> which contains the
<c>devmap_name</c> application.
</p>

<pre caption="Installing multipath-tools">
<comment>(At the moment of writing, multipath-tools is only available in the
testing branch:)</comment>
# <i>echo "=sys-fs/multipath-tools-0.4.2 ~x86" &gt;&gt;
/etc/portage/package.keywords</i>
# <i>emerge multipath-tools</i>
</pre>

</body>
</section>
<section>
<title>No Consistent Naming between DevFS and udev</title>
<body>

<p>
Even though our intention is to have a consistent naming scheme between both
dynamical device management solutions, sometimes naming differences do occur.
</p>

<p>
One reported clash is with a HP Smart Array 5i RAID controller (more precisely
the <c>cciss</c> kernel module). With udev, the devices are named
<path>/dev/cciss/cXdYpZ</path> with X, Y and Z regular numbers. With devfs,
the
devices are <path>/dev/hostX/targetY/partZ</path> or symlinked from
<path>/dev/cciss/cXdY</path>.
</p>

<p>
If this is the case, don't forget to update your <path>/etc/fstab</path> and
bootloader configuration files accordingly.
</p>

<p>
The same happens with all-round symlinks that used to exist in
<path>/dev</path>, such as <path>/dev/mouse</path>, which <c>udev</c> doesn't
create anymore. Be certain to check your X configuration file and see if the
Device rule for your mouse points to an existing device file.
</p>

</body>
</section>
<section>
<title>Other issues</title>
<body>

<p>
If device nodes are not created when a module is loaded from
<path>/etc/modules.autoload.d/kernel-2.6</path> but they appear when you load
the module manually with modprobe then you should try upgrading to
<c>sys-apps/baselayout-1.8.12</c> or later.
</p>

<p>
Support for the framebuffer devices (<path>/dev/fb/*</path>) comes with the
kernel starting from version 2.6.6-rc2.
</p>

<p>
For kernels older than 2.6.4 you have to explicitly include support for the
<path>/dev/pts</path> filesystem.
</p>

<pre caption="Enabling the /dev/pts filesystem">
File systems ---&gt;
  Pseudo filesystems ---&gt;
    [*] /dev/pts file system for Unix98 PTYs
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Resources &amp; Acknowledgements</title>
<section>
<body>

<p>
The udev talk on the Linux Symposium (Ottawa, Ontario Canada - 2003) given by
Greg Kroah-Hartman (IBM Corporation) provided a solid understanding on the
udev
application.
</p>

<p>
<uri
link="http://webpages.charter.net/decibelshelp/LinuxHelp_UDEVPrimer.html">
Decibel's
UDEV Primer</uri> is an in-depth document about udev and Gentoo.
</p>

<p>
<uri link="http://www.reactivated.net/udevrules.php">Writing udev rules</uri> by
fellow Gentoo developer Daniel Drake is an excellent document to learn how to
customize your udev installation.
</p>

</body>
</section>
</chapter>

</guide>
