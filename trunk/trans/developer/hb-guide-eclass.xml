<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/eclass-howto.xml :: R1.17.
-->

<sections>
  <section>
    <title>Wprowadzenie do eklas</title>

    <subsection>
      <title>Do czego służą eklasy?</title>
      <body>
	
	<p>Eklasy to moduły, które zawierają współdzielony kod. Są napisane w
	bashu i posiadają tę samą składnię, co zwykłe pliki ebuild. Są
	odczytywane ('dziedziczone') przez pliki ebuild i inne eklasy,
	dostarczając tę samą funkcjonalność i domyślne ustawienia w wielu
	ebuildach.</p>
	<p>Dzięki temu możemy w największym stopniu wykorzystać ponownie kod w
	podobnych plikach ebuild.</p>
	<p>W niniejszym rozdziale w skrócie zademonstrujemy jak napisać eklasę,
	wykorzystując standardowe techniki z już istniejących eklas. W drugim
	rozdziale omówimy eklasy kde, zaś trzeci ukaże nam jak napisać ebuild
	KDE, wykorzystując eklasy z grupy kde.</p>

      </body>
    </subsection>

    <subsection>
      <title>Przykład nieskomplikowanej eklasy</title>
      <body>

	<p>Oto fikcyjna eklasa o nazwie sourceforge.eclass, która ma za zadanie
	dostarczyć informacje o stronie domowej projektów FIXME hostowanych na
	sourceforge.net, oraz miejsca, z których można je pobrać:</p>

	<pre caption = "Przykład: eklasa sourceforge.eclass">
# Copyright 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License, v2 or later
# Author Dan Armak &lt;danarmak@gentoo.org&gt;
# &#36;Header: &#36;
ECLASS=sourceforge
INHERITED="${INHERITED $ECLASS}"
# This eclass sets ${HOMEPAGE} and ${SRC_URI} to the standard values for
# sourceforge.net - hosted projects.

HOMEPAGE=&quot;http://${PN}.sourceforge.net/&quot;
SRC_URI=&quot;http://download.sourceforge.net/${PN}/${P}.tar.gz&quot;</pre>
	<note>Linijki ECLASS= i INHERITED= są wykorzystywane przez Portage do
	obsługi podręcznego buforowania zależności eklas. Linie te muszą
	znajdować się w każdym pliku eclass, inaczej będą występować błędy.
	Zmienną ${ECLASS} wykorzystuje także funkcja EXPORT_FUNCTIONS(). Należy
	jednak mieć na uwadze, że zmienne te mogą wkrótce stać się przestarzałe
	i będą ustawiane automatycznie przez funkcję inherit().</note> 
	<p>Pierwsze cztery linijki to nagłówki, identyczne jak w każdym pliku
	ebuild. Kolejne dwie FIXME (pod ECLASS I INHERITED?) to krótki opis
	eklasy. Właściwą pracę -- ustawianie zmiennych SRC_URI i HOMEPAGE --
	wykonują następne linie kodu.</p> 
	<p>Większość eklas robi więcej niż tylko ustawianie zmiennych i
	dostarczanie funkcji pomocniczych. Zawierają domyślne implementacje
	specjalnych funkcji używanych przez ebuildy (src_unpack, src_compile
	itd). Przed napisaniem domyślnej funkcji w eklasie powinniśmy znać
	funkcje już zawarte w pliku ebuild.sh. To one są wykonywane w naszych
	plikach ebuild jeśli nie umieścimy ich tam sami (nawet poprzez eklasy).
	Często wykorzystuje się domyślną funkcję src_unpack(). Powinniśmy
	przyjrzeć się funkcjom z pliku ebuild.sh, jeśli jeszcze tego nie
	uczyniliśy.</p>
	
	<p>To wszystko, co powinniśmy wiedzieć, aby pisać eklasy. Umieśćmy nasz
	nowy plik eclass w katalogu <path>${PORTDIR}/eclass/</path> i dodajmy
	poniższą linijkę na początku naszego pliku ebuild:</p>
	<pre caption ="Dziedziczenie eklas w plikach ebuild">
inherit sourceforge</pre>
	<p>W tym miejscu pliku ebuild zostanie przeczytana zawartość naszej
	eklasy. Należy pamiętać, że jakiekolwiek zmienne zdefiniowane w eklasie
	mogą zostać nadpisane w pliku ebuild, gdyż jego kod jest wykonywany po
	kodzie eklasy. Dlatego powinniśmy umieszczać jak najwięcej domyślnych
	ustawień i wspólnego kodu właśnie w eklasach. Wszystkie niestandarowe
	ustawienia i modyfikacje możemy zamieszczać w pliku ebuild.</p>
	<p>Możemy także dziedziczyć wiele eklas jednocześnie, używając
	składni:</p>
	<pre caption = "Dziedziczenie wielu eklas">
inherit eclass1 eclass2 [...]</pre>
	<p>...uważajmy jednak na ich kolejność! Musimy pamiętać, że jedne eklasy
	mogą dziedziczyć inne i nadpisywać nawzajem swoje ustawienia. Z tego
	względu należy być ostrożnym przy posługiwaniu się jednocześnie wieloma
	eklasami, które mogą wpływać wzajemnie na siebie.</p>

	<p>Zanim przejdziemy do prawdziwych eklas z Portage, najpierw omówimy
	wszystkie sztuczki przydatne przy ich pisaniu.</p> 

      </body>
    </subsection>

    <subsection>
      <title>Funkcja inherit()</title>
      <body>

	<p>Funkcja ta jest zdefiniowana w pliku ebuild.sh i obsługuje
	dziedziczenie (odczytywanie) eklas. Wywoływana jest z listą nazw eklas
	jako parametrami: inherit &lt;eclass1&gt; [eclass2 eclass3...].</p>
	<p>Oprócz czytania pliku z eklasami ustawia też zmienne ECLASS i
	INHERITED, które są wykorzystywane przez Portage do buforowania czasów
	modyfikacji plików eclass. Ponadto zmienna INHERITED przydaje się
	podczas pisania nowych eklas, ponieważ zawiera listę wszystkich
	przeczytanych (odziedziczonych) do tej pory, w kolejności ich
	dziedziczenia. Dzięki temu jedna eklasa może w prosty sposób sprawdzić,
	czy została wywołana z innej eklasy.</p>

      </body>
    </subsection>

    <subsection>
      <title>Makro EXPORT_FUNCTIONS</title>
      <body>

	<p>Predefiniowane funkcje dobrze napisanej eklasy zwykle można używać
	od razu, bez żadnych modyfikacji. Plik ebuild będzie wówczas zawierał
	bardzo mało kodu, co jest pożądane. Czasem jednak funkcje danej eklasy
	nie będą robiły wszystkiego, czego byśmy od nich oczekiwali. Jednym
	wyjściem jest napisanie samemu nowej funkcji w pliku ebuild, nadpisując
	funkcję z eklasy. W ten sposób jednak rezygnujemy z pożytecznej
	możliwości ponownego wykorzystania już istniejącego kodu. Zamiast tego
	lepiej jest 'rozszerzyć' funkcjonalność funkcji z eklasy.</p>
	<p>Przypuśćmy, że chcemy rozszerzyć funkcję src_compile(). Moglibyśmy
	napisać definicję tej funkcji w naszym pliku ebuild, w której znalazłyby
	się tylko te linie kodu, których nie było w definicji zamieszczonej w
	eklasie. Następnie z naszej funkcji wywołalibyśmy funkcję src_compile()
	z eklasy.</p>
	<p>Jednakże jeśli stworzymy nową funkcję o nazwie src_compile(), bash
	nie będzie już pamiętał o poprzedniej, a więc nie będzie możliwe jej
	wywołanie! W tej sytuacji przydaje się makro EXPORT_FUNCTIONS.</p>

	<p>Przez chwilę przyjrzyjmy się innemu problemowi. Załóżmy, że dwie
	eklasy, coś.eclass i tam.eclass, jednocześnie definiują funkcję
	src_compile(). Jeśli odziedziczymy obie, to dostaniemy inną funkcję
	src_compile(), w zależności od kolejności dziedziczenia tych eklas. W
	porządku, to jest normalne, ponieważ powinniśmy śledzić kolejność
	dziedziczenia. Jednak czasem możemy chcieć wywołać konkretnie jedną z
	tych funkcji.</p>
	<p>Z tego względu każda eklasa dodaje do definiowanych przez siebie
	funkcji przedrostek. Na przykład eklasa coś.eclass zdefiniuje funkcję
	coś_src_compile(), zaś eklasa tam.eclass zdefiniuje funkcję
	tam_src_compile(). W ten sposób w pliku ebuild zawsze możemy wywołać
	dowolną z nich.</p>
	<p>Jednak dobrze by było mieć domyślną funkcję o nazwie src_compile(), w
	przeciwnym wypadku koniecznym stałoby się zdefiniowanie jej w pliku
	ebuild. Makro EXPORT_FUNCTIONS rozwiązuje zarówno ten problem, jak i
	przedstawiony powyżej.</p>

	<pre caption = "Makro EXPORT_FUNCTIONS() (z pliku ebuild.sh)">
EXPORT_FUNCTIONS() {
	while [ &quot;$1&quot; ]; do
		eval &quot;$1() { ${ECLASS}_$1 ; }&quot; &gt; /dev/null
		shift
	done
}</pre>

	<p>Funkcja inherit() przed odczytaniem każdej eklasy przypisuje zmiennej
	${ECLASS} jej nazwę. Na samym końcu eklasy wywoływane jest makro
	EXPORT_FUNCTIONS(), któremu przekazywane są jako parametry domyślne
	funkcje, których dostarcza eklasa. Przykładowo, jeśli wywołamy:</p>
	<pre caption="Przykład wywołania makra EXPORT_FUNCTIONS">
EXPORT_FUNCTIONS src_compile src_install</pre>
	<p>wówczas makro EXPORT_FUNCTIONS wywoła funkcję eval() na poniższych
	danych:</p>

	<pre caption="Wynik działania makra EXPORT_FUNCTIONS">
src_compile() { coś_src_compile() ; }
src_install() { tam_src_install() ; }</pre>

	<p>W ten sposób eklasa odziedziczona jako ostatnia zdefiniuje domyślną
	funkcję src_compile(), jednak wciąż w pliku ebuild można w razie
	potrzeby odwołać się bezpośrednio do obu funkcji.</p>
	<p>Możemy także rozszerzyć domyślną funkcję src_compile() poprzez
	wywołanie funkcji z eklasy z wnętrza naszej własnej funkcji. Wówczas
	należy posłużyć się pełną nazwą domyślnej funkcji, czyli
	coś_src_compile. Przykładowo:</p>

	<pre caption="Rozszerzanie domyślnych funkcji z eklas w naszych plikach
	ebuild">
#w pliku cos.eclass:
cos_src_compile() {
	[domyślny kod funkcji]
}

EXPORT_FUNCTIONS src_compile
#tu kończy się kod eklasy

#w pliku ebuild
inherit cos

src_compile() {
	[nasz kod]
	cos_src_compile
	[więcej naszego kodu]
}</pre>

      </body>
    </subsection>

    <subsection>
      <title>Sekcje funkcji</title>
      <body>

	<p>Czasem rozszerzanie domyślnych funkcji przez wywoływanie własnego
	kodu przed i po ich wywołaniu nie daje nam wystarczającej elastyczności.
	Gdy mamy do czynienia z długimi, skomplikowanymi funkcjami, czasem
	chcielibyśmy umieścić nasz kod gdzieś w ich środku.</p>
	<p>Potrzebną tu większą elastyczność zapewniają nam sekcje funkcji.
	Dzięki nim możliwe jest podzielenie funkcji na fragmenty i wykonywanie
	kodu z dowolnego z nich.</p>

	<p>Implementacja jest bardzo prosta. Przyjrzyjmy się funkcji
	src_compile() z eklasy base.eclass. (Uwaga: FIXME (czy może funkcja?)
	eklasa ta już nie istnieje, ale wciąż jest dobrym przykładem :) Wygląda
	ona tak:</p>

	<pre caption = "Przykład z eklasy base.eclass">
base_src_compile() {
    ./configure || die
    emake || die
}</pre>

	<p>Oto ta sama funkcja, lecz podzielona na sekcje:</p>
	<pre caption = "Ta sama funkcja podzielona na sekcje.">
base_src_compile() {
 
    [ -z &quot;$1&quot; ] &amp;&amp; base_src_compile all
 
    while [ &quot;$1&quot; ]; do
        case $1 in
            configure)
                ./configure || die;;
            make)
                emake || die;;
            all)
                base_src_compile configure make;;
        esac
    shift
    done
 
}</pre>
			
	<p>Kod podzielono na dwie sekcje: <c>configure</c> i <c>make</c>. W
	naszym prostym przykładzie odpowiadają one dwóm komendom z pierwotnej
	funkcji.</p>
	<p>Sercem nowej funkcji jest blok instrukcji
	while;case...esac;shift;done. Porównuje on parametry przekazane funkcji
	z nazwami sekcji i wywołuje odpowiadające im linie kodu.</p>
	<p>Specjalny parametr <c>all</c> wywołuje rekursywnie tę samą funkcję z
	wszystkimi parametrami po kolei. Autor eklasy odpowiada za poprawność
	tej listy.</p>
	<p>Linia kodu poprzedzająca powyższy blok instrukcji mówi nam, że
	wywołanie bez parametrów powinno być traktowane tak samo jak wywołanie
	tylko z parametrem <c>all</c>. Nietrudno zauważyć, że funkcja często
	wywołuje sama siebie. Zwróćmy również uwagę, że wywołanie
	<c>base_src_compile configure all make</c> również jest poprawne.
	Wówczas właściwe wywołanie będzie wyglądało tak: <c>base_src_compile
	configure configure make make</c>.</p>

	<p>W naszym ebuildzie (lub eklasie), które dziedziczą z eklasy
	base.eclass będziemy mogli użyć zalążka funkcji o nazwie src_compile(),
	który wywołuje funkcję base_src_compile bez parametrów. Co odpowiada
	wywołaniu jej z parametrem <e>all</e>, a więc wywołując wszystkie jej
	sekcje. Możemy używać tej funkcji w obecnej postaci lub
	rozszerzyć ją, definiując nową funkcję src_compile i w niej wywoływać
	pojedyncze sekcje z base_src_compile:</p>
	<pre caption = "Używanie sekcji w funkcji src_compile()">
src_compile() {
    nasz_kod1
    base_src_compile configure
    nasz_kod2
    base_src_compile make
    nasz_kod3
}</pre>
	<p>Jak widać, sekcje funkcji dają nam większą elastyczność, gdyż możemy
	umieszczać nasz kod pomiędzy sekcjami, wywoływać sekcje w
	dowolnej kolejności, a także pomijać niektóre z nich. Łatwiej w ten
	sposób ponownie wykorzystywać kod.</p>

      </body>
    </subsection>

    <subsection>
      <title>Funkcje debug-print-*</title>
      <body>

	<p>Są to kolejne funkcje, które dostarcza nam plik ebuild.sh.
	Umożliwiają one eklasom wypisywanie komunikatów diagnostycznych, dzięki
	którym łatwiej jest śledzić ich wykonywanie, nie musząc czytać długich
	wydruków z trybu debug powłoki bash. Wszystkie moje eklasy często
	wykorzystują te funkcje.</p>

	<p>Funkcja debug-print() wypisuje po prostu wszystkie podane jej
	parametry z przedroskiem 'debug:'. Używa się jej gdy tylko trafi się coś
	wartego umieszczenia w logu diagnostycznym.</p>
	<p>Funkcja debug-print-function() wypisuje komunikat 'debug: entering
	function $1, parameters: $2 [$3 ....]'. Wywołuje się ją na początku
	funkcji.</p>
	<p>Funkcja debug-print-section() wypisuje 'debug: now in section $1'.
	Wywołuje się ją na początku sekcji funkcji.</p>

	<p>Zwykle komunikaty diagnostyczne zapisywane są do pliku
	${T}/eclass-debug.log. Możemy podać alternatywny plik za pomocą zmiennej
	środowiskowej ECLASS_DEBUG_OUTPUT (w pliku make.globals/conf lub
	bezpośrednio w środowisku), dzięki czemu komunikaty trafią również tam.
	Ewentualnie możemy przypisać tej zmiennej specjalną wartość 'on', co
	spowoduje wypisywanie komunikatów diagnostycznych na standardowe
	wyjście, razem z pozostałymi komunikatami emerge.</p>

	<p>Dodajmy do naszej przykładowej funkcji możliwość wypisywania
	komunikatów diagnostycznych:</p>
	<pre caption = "Dodawanie komunikatów diagnostycznych">
base_src_compile() {
 
    debug-print-function
    [ -z &quot;$1&quot; ] &amp;&amp; base_src_compile all
 
    while [ &quot;$1&quot; ]; do
        case $1 in
            configure)
                debug-print-section configure
                ./configure || die;;
            make)
                debug-print-section make
                make || die;;
            all)
                debug-print-section all
                base_src_compile configure make;;
        esac
    shift
    done
 
    debug-print &quot;${FUNCNAME}: result is ${RESULT}&quot;
}</pre>
	<p>Zmienna ${FUNCNAME} to zmienna wbudowana w powłokę bash, w której
	znajduje się nazwa aktualnie uruchomionej funkcji.</p>

      </body>
    </subsection>
<!--
    <subsection>
      <title>newdepend()</title>
      <body>

	<p>This ebuild.sh function simply adds all its parameters to
	both DEPEND and RDEPEND, saving you the trouble of writing and
	maintaining two lists of dependencies.</p>

	<p>If called with a special parameter, it adds predefined
	dependencies. I don't think this is very elegant (anymore), I
	rather prefer explicit dependancies now; so you can consider
	this slightly deprecated ;-)</p>
	<p>These special parameters exist as of now:</p>
	<p>newdepend /autotools: add sys-devel/autoconf
	sys-devel/automake sys-devel/make to DEPEND (but not
	RDEPEND).</p>
	<p>newdepend /c: add virtual/glibc sys-devel/ld.so to both
	DEPEND and RDEPEND. Also, add sys-devel/gcc to DEPEND.</p>

      </body>
    </subsection>
-->
  </section>

  <section>
    <title>Istniejące eklasy</title>
    
    <subsection>
      <title>Wprowadzenie</title>
      <body>

	<p>Większość eklas jest raczej nieskomplikowana i wystarczy je
	przeczytać i ewentualnie przejrzeć kilka ebuildów, które z nich
	korzystają, aby zapoznać się z ich działaniem. W prawie wszystkich
	znajdziemy również bogate komentarze.</p>
	<p>Zadaniem niniejszego rozdziału jest przedstawić ogólne powiązania
	pomiędzy eklasami z grupy kde*.</p>

      </body>
    </subsection>

    <subsection>
      <title>base.eclass</title>
      <body>

	<p>W tej klasie zdefiniowane są zmienne i funkcje podobne do zawartych
	domyślnie w tych ebuildach, które nie dziedziczą żadnych klas (są one
	zdefiniowane w pliku ebuild.sh). Najprawdopodobniej nie będziemy
	zainteresowani korzystaniem z nich bezpośrednio, lecz poprzez jedną z
	eklas kde, które je dziedziczą.</p>
	<p>Jedną z interesujących funkcjonalności, które dostarcza ta eklasa
	jest możliwość automatycznego nakładania łatek. Jeśli w zmiennej
	PATCHES umieścimy listę plików z ebuilda, do których rozpakowania nada
	się funkcja base_src_unpack() (lub kde_src_unpack()), to na źródła
	zostaną nałożone łatki z tych plików. Musimy zadbać, aby polecenie patch
	zadziałało z parametrem -p0 z katalogu ${S}.</p>
	<p>Zwróćmy uwagę, że możemy ustawić zmienną PATCHES bez definiowania
	własnej funkcji src_unpack() w naszym ebuildzie. Właśnie po to ona
	jest.</p>
	<p>Nowsza funkcja epatch() z eklasy eutils.eclass jest znacznie bardziej
	rozbudowana -- obsługuje skompresowane pliki łatek, katalogi i FIXME
	serie łatek i automatyczne wykrywanie poziomu łatki -- dlatego któregoś
	dnia planuję zmodyfikować powyższy mechanizm automatycznego nakładania
	poprawek, aby z niej korzystał.</p>
	<p>Należy zwrócić uwagę, że używanie sekcji <c>patch</c> funkcji
	base_src_unpack() jest niezalecane wkrótce zostanie ona usunięta. 
	
	Note that the <c>patch</c> section in base_src_unpack() is
	deprecated and will be removed soon. If you see an ebuild
	using it, it needs to be converted to the <c>autopatch</c>
	style.</p>

      </body>
    </subsection>

    <subsection>
      <title>cvs.eclass</title>
      <body>
	
	<p>This eclass provides the functionality needed to create
	'live' cvs ebuilds. Such ebuilds fetch sources from a
	specified cvs server at unpack time, thus always getting the
	latest bugs and fixes from upstream.</p>
	<p>However, the necessary (versioning etc.) support for live
	cvs ebuilds has not yet been added to portage. They can work
	with this eclass, but it is inconvinient in many
	respects. Think twice before creating a live cvs ebuild;
	perhaps a regular cvs snapshot would be better. If you intend
	to add such an ebuild to portage, be aware of the cvs ebuild
	guidelines in the developer's guide.</p>
	
	<p>Before inheriting cvs.eclass, set any non-default settings
	you want (at least the server address and module name). See
	the list of configurable settings and default values at the
	beginning of cvs.eclass, marked as 'ebuild-configurable
	settings'.</p>
	<p>After that, things are mostly automatic. A cvs_src_unpack()
	(no sections) is provided. If you wish to know more, read the
	eclass itself.</p>
	
      </body>
    </subsection>

    <subsection>
      <title>kde-functions.eclass</title>
      <body>

	<p>This eclass contains all KDE-related helper functions. Some
	of them you should never need to use directly in an ebuild;
	these are not mentioned here, and should be well-commented in
	the source.</p>
	<p>Note that by 'helper functions' I mean any functions that
	aren't special ebuild functions (src_unpack() etc.). All kde
	eclasses containing such 'special' functions inherit
	kde-functions.</p>
	<p>The only code outside any functions in kde-functions.eclass
	(which thus runs on sourcing) is a block that determines
	whether or not the current ebuild is one from kde-base. If it
	is, KDEBASE=true is set. This variable is used in various
	logic tests elsewhere and it is comfortable to have one
	centralized test for it.</p>

	<p><b>The current multi-kdedir scheme</b></p>
	<p>A short explanation about the way Gentoo manages multiple
	KDE versions:</p>
	<p>A KDE (that is, things from kde-base) live in
	/usr/kde/${major-version}.${minor-version}. So, fex., KDE
	3.1.x lives in /usr/kde/3.1. However, this scheme was
	established after the KDE 3.0 release, and so older versions
	live in nonstandard locations: KDE 3.0.x lives in /usr/kde/3
	(and not /usr/kde/3.0), and KDE 2.2.2 (the only 2.x version we
	have) lives in /usr/kde/2. The cvs ebuilds I maintain install
	into /usr/kde/cvs.</p>
	<p>Any number of KDEs with different minor versions can thus
	coexist. kde-base packages have a SLOT of major.minor
	(e.g. 3.0, 3.1).</p>
	<p>Since QT versions are supposed to be fully backward
	compatible across minor versions, we have only one of each
	major version installed and with a different slot; they live
	in /usr/qt/$major.</p>
	<p>A non-kde-base ebuild always installs in /usr. The kde-env
	package puts KDEDIRS=/usr in env.d, allowing these apps to run
	properly. The app compiles and links against the latest KDE
	libraries found; the eclass checks the standard locations in
	descending order - /usr/kde/cvs, then /usr/kde/3.1, then
	/usr/kde/3. (kde-base ebuilds will always link against the
	kdelibs of their own version.) This of course also depends on
	the parameter given to need-kde() (see below).</p>
	
	<p>There are several special variables you can set to change
	the default settings of this system. Their prime usage is to
	compile an ebuild against a specific KDE you have installed
	for testing, but you can also use them to install a KDE in a
	nonstandard location, and so have, fex., both KDE 3.0.1 and
	3.0.2 installed side-by-side. This, again, is most useful for
	testing and development.</p>
	<p>All KDE apps (base and non-base) will install into
	${KDEPREFIX}, if set. It overrides all other logic in the
	eclasses.</p>
	<p>A KDE app (even if it is a kde-base one) will try to link
	against the kdelibs installed in ${KDELIBSDIR}, if set. If it
	fails, it will fall back to the default logic of locating the
	latest kdelibs (or the proper version for kde-base
	version).</p>

	<p><b>need-kde(), need-qt(), set-kdedir(), set-qtdir()</b></p>
	<p>kde-functions.eclass provides two pairs of functions:
	need-kde(), need-qt() and set-kdedir(), set-qtdir(). These
	functions handle the details of multiple KDEs and QTs
	setup.</p>

	<p>The need-kde() function is called with a parameter which is
	the minimal version number of kdelibs required. It adds the
	proper dependencies to DEPEND, RDEPEND and call the
	set-kdedir() function. If no parameter is passed, a version
	number of 0 (zero) is used, meaning that any version will
	satisfy the dependency. need-kde() also calls need-autoconf()
	and need-automake() with the correct parameters for this KDE
	version.</p>
	<p>The set-kdedir() function then determines the installation
	prefix and kdelibsdir location your ebuild should use. These
	are passed to you in ${PREFIX} and ${KDEDIR}, respectively (and
	are handled automatically in kde.eclass). Note that no ebuild
	should ever address ${KDEPREFIX} or ${KDELIBSDIR} directly!</p>
	<p>need-kde() also looks up the minimal version of QT required
	for this version of kdelibs from a table. It then calls
	need-qt() with this version. A qt-only (i.e. non-kde) app's
	ebuild usually calls need-qt directly, bypassing need-kde.</p>
	
	<p>The need-qt() function adds the equired QT verision to
	DEPEND, RDEPEND and calls set-qtdir() with it. The set-qtdir()
	function sets QTDIR to be the default location of this version
	of QT. Unlike set-kdedir(), set-qtdir() doesn't actually check
	if there's a QT installed there.</p>

	<p>need-kde() (or need-qt()) needs to be called from the main
	part of the ebuild (i.e. not from a function), so that any
	changes to DEPEND and RDEPEND affect emerge.</p>

	<p><b>need-autoconf(), need-automake()</b></p>
	
	<p>These functions set the necessary environment variables to
	make the requested version of autoconf or automake run. They
	also unset all previously set variables of this kind. For
	example, calling 'need-automake 1.4' will set
	NEED_AUTOMAKE_1_4=1 and unset all other WANT_AUTOMAKE*
	variables. For more info see the functions' code and the
	comments at the beginning of /usr/bin/auto{conf,make} (on a
	Gentoo system).</p>
	
	<p><b>kde_sandbox_patch()</b></p>
	<p>Some KDE makefiles are broken. They chmod or chown files in
	PREFIX when installing, but do not respect DESTDIR
	(${D}). I.e. when installing, they correctly copy a file to
	${DESTDIR}/${PREFIX}/path/foo, but then try to chmod +x the file
	${PREFIX}/path/foo on the live filesystem which may not even
	exist. And if it does exist, the sandbox prevents this
	operation.</p>
	<p>This function runs a generic sed on makefiles which fixes
	all known cases of the problem. It is called with the
	directories to be processed as parameters, and processes
	Makefile, Makefile.in and Makefile.am in those
	directories. For example:</p>
	<pre caption = "Processing">
src_unpack() {
    base_src_unpack
    kde_sandbox_patch ${S}/dir1 ${S}/dir2/dir3
}</pre>

	<p><b>kde_remove_flag()</b></p>
	<p>This is used to weed out compiler flags that are known to
	break packages. You call it after unpacking with the
	subdirectory of ${S} in which to work as the first parameter,
	and the name of the flag to remove as the second. Note that it
	is not recursive. Example: "kde_remove_flag foodir/barfoo
	-fomit-frame-pointer".</p>
	
	<p><b>kde_remove_dir() and ${KDE_REMOVE_DIR}</b></p>
	<p>This function removes the specified subdir from
	complation. It deletes it and removes all mention of it from
	the subdirs file, configure and the makefiles. Note that it
	only works on subdirs of ${S} for now, not on 2nd level
	subdirs. You can call it with a list of subdirs to remove; it
	works on each parameter in turn.</p>
	<p>You can call it directly, but to avoid having to define a
	custom src_unpack() just to do that, you can set
	KDE_REMOVE_DIR to a list of subdirs to
	remove. kde_src_unpack() will call 'kde_remove_dir
	${KDE_REMOVE_DIR}' after unpacking. As you can see, I go to some
	lengths to avoid having to define an extra function in an
	ebuild, because this makes the ebuilds much cleaner and more
	readable.</p>
	
      </body>
    </subsection>

    <subsection>
      <title>kde.eclass</title>
      <body>

	<p>This is the main, central KDE eclass. It contains most of
	the KDE-related code. All KDE ebuilds inherit it, one way or
	another. The kde eclass inherits base and kde-functions.</p>
	<p>As with the other eclasses, read it to find out what it
	does. Most of it should be self-obvious. Here is a short
	summary:</p>
	
	<p>The eclass's global section (i.e. the one that's executed
	when you inherit it) adds the correct deps on kde-env,
	automake, autoconf, make and perl (the last is used by
	standard configure scripts for fast makefile generation). It
	also sets the default SLOT="0".</p>
	
	<p>kde_src_unpack() basically just calls base_src_unpack(),
	passing on any parameters (e.g. sections to execute). After
	that, it adds kde-specific items. It touches all .ui files in
	the unpacked sources to regenerate any stale .cpp,.h files. It
	also calls kde_remove_dir() with ${KDE_REMOVE_DIR} if this
	variable is set (see above in the section on
	kde-functions).</p>
	
	<p>kde_src_compile() also has several fixes. One is exporting
	kde_widgetdir="${KDEDIR}/lib/kde3/plugins/designer" to get
	around a bug in older kde acinclude.m4.in's. Another is
	setting HOME="${T}/fakehome", so that any accesses to ${HOME}/.kde
	and ${HOME}/.qt aren't stopped by the sandbox, and don't affect
	the user's home directory. It is a bug (or shortcoming) of uic
	that it always tries to access config files in these
	locations.</p>
	<p>kde_src_compile() has several sections. <c>myconf</c> adds
	to ${myconf} the default kde configure script parameters, such
	as --prefix=${PREFIX} (remember, ${PREFIX} is set by
	set-kdedir()). You can add your own values to ${myconf} either
	before or after this section; just remember never to overwrite
	old values, because users can expect to set ${myconf} in the
	shell and in this way add something to the configure
	parameters used by the ebuild.</p>
	<p>The <c>configure</c> section runs the configure script in
	${S}, passing ${myconf} to it. If the configure script does not
	exist, it tries to generate it by running make -f Makefile.cvs
	or make -f admin/Makefile.common. Thus, this stage of
	compilation (which is needed for cvs snapshots, or ebuilds
	that patch files like configure.in) is also done
	automatically.</p>
	<p>The <c>make</c> section simply runs emake || die. Finally,
	there is an <c>all</c> section which runs all of the
	above.</p>

	<p>Finally, kde_src_install() has a <c>make</c> section which
	runs make install, and a <c>dodoc</c> section which runs dodoc
	on some standard doc names in ${S}, such as README and
	COPYING.</p>
	
      </body>
    </subsection>
    
    <subsection>
      <title>kde-base.eclass</title>
      <body>
        <p>
	This eclass is now deprecated, ebuilds should "inherit kde"
	instead.
	</p>
      </body>
    </subsection>
   
    <subsection>
      <title>kde-dist.eclass</title>
      <body>

	<p>This eclass is for the core kde distribution packages in
	kde-base/*. It inherits kde.</p>
	<p>It sets the correct DESCRIPTION and HOMEPAGE and calls
	need-kde ${PV}. The simpler, smaller kde-base/ packages
	(e.g. kdetoys) don't need to make any changes to it; most of
	those that do only add deps and patches.</p>

      </body>
    </subsection>
   
    <subsection>
      <title>kde-i18n.eclass</title>
      <body>

	<p>This eclass is for the kde-i18n-* packages. In fact, all
	kde-i18n ebuilds are completely identical and so all they have
	to do is inherit from this eclass. Their ${P}, ${P}, ${PV} variables
	do the rest.</p>

      </body>
    </subsection>

    <subsection>
      <title>kde.org.eclass</title>
      <body>
        <p>
	This eclass is also deprecated, and all the code has been moved
	to kde-dist.eclass.
	</p>
      </body>
    </subsection>

    <subsection>
      <title>koffice-i18n.eclass</title>
      <body>

	<p>This eclass is meant for the koffice-i18n-* packages and is
	very similar to kde-i18n.eclass. Again, all kde-i18n ebuilds
	are completely identical and so all they have to do is inherit
	from this eclass.</p>

      </body>
    </subsection>
   
    <subsection>
      <title>kde-source.eclass</title>
      <body>

	<p>This eclass works on top of cvs.eclass, adding some
	kde-specific functionality. For example, it automatically
	fetches the admin/ dir from the kde-common module of kde
	cvs. Read the eclass to find out more, including
	kde-cvs-specific settings you can pass to it.</p>
	
      </body>
    </subsection>
  </section>

  <section>
    <title>Writing KDE ebuilds</title>
    
    <subsection>
      <title>Introduction</title>
      <body>
	
	<p>This chapter explains how to write standard KDE
	ebuilds. All that is said here is mostly a rehashing of the
	information about eclasses above. When in doubt, look at other
	ebuilds, at the eclasses, or ask.</p>
	
      </body>
    </subsection>
    
    <subsection>
      <title>A typical KDE ebuild</title>
      <body>

	<p>The code below should be obvious after reading this howto:</p>
	<pre caption = "A simple KDE ebuild, #1">
&lt;Header goes here...&gt;
inherit kde</pre>
	<p>Some ebuilds end right here. Others need some customization.</p>

	<p>The next stage is to add any extra deps. Remember: *always*
	extend variables, never override!</p>
	<p>Because our goal is to avoid defining custom ebuild
	functions unless we have to, we set all the settings we can,
	and call all the helper functions we can, directly from the
	ebuild's main section. Remember though that there are
	limitations on code in the main section; for example, it must
	not produce any output (debug-print() output probably doesn't
	count though).</p>
	<pre caption = "A simple KDE ebuild, #2: adding extra dependencies" >
DEPEND=&quot;foo/bar&quot;
RDEPEND=&quot;bar/foo&quot;</pre>

	<p>We also want to add some extra arguments to myconf, which
	are then passed to configure (assuming that we use
	kde_src_compile's configure section):</p>
	<pre caption = "A simple KDE ebuild, #4: passing arguments to configure" >
myconf=&quot;$myconf --with-foobar&quot;</pre>

	<p>We also have a patch to add. If it can be applied using -p0
	in ${S}, we can use base_src_unpack's <c>autopatch</c>
	section. Remember, kde_src_unpack() calls base_src_unpack()
	passing on any parameters you gave it.</p>
	<pre caption = "A simple KDE ebuild, #5: autopatching" >
PATCHES=&quot;$FILESDIR/$P-myfix.diff&quot;</pre>

	<p>Finally, we want an extend src_install() to put in place
	some documentation:</p>
	<pre caption = "A simple KDE ebuild, #6: extending src_install()" >
src_unpack() {
    kde_src_install
    dodoc $S/doc/*
}</pre>

	<p>Let's look at the ebuild we have created in this
	example:</p>
	<pre caption = "A simple KDE ebuild - complete listing" >
&lt;Header goes here...&gt;
inherit kde

# add deps
DEPEND=&quot;foo/bar&quot;
RDEPEND=&quot;bar/foo&quot;

# always enable foobar
myconf=&quot;${myconf} --with-foobar&quot;

# fix terrible bug
PATCHES=&quot;${FILESDIR}/${P}-myfix.diff&quot;

src_unpack() {
    kde_src_install
	# install some extra docs not included in make install's targets
    dodoc ${S}/doc/*
}</pre>

      </body>
    </subsection>

    <subsection>
      <title>A typical ebuild with optional KDE functionality</title>
      <body>

	<p>When adding kde (eclass) functionality to an existing
	ebuild, you should simply prefix each kde-specific line
	with <c>use kde &amp;&amp;</c> , or create whole <c>if [ -n
	"`use kde`" ]; then; fi</c> blocks.</p>
	<p>To the general section, add the following (only if USE kde
	is set, of course):</p>

	<pre caption = "Optional KDE support - main ebuild section" >
inherit kde-functions

# This will add kdelibs, kde-env to your dep strings and set ${KDEDIR}
# to the correct value:

need-kde ${version} # minimal version of kde your app needs

# Add anything else you need for kde support:
use kde &amp;&amp; myconf=&quot;${myconf} --with-my-parameter&quot;</pre>

	<p>Then, tell your app to look for KDE in the ${KDEDIR} setting
	that is available after calling need-kde(). If you do not want
	the kdelibs dep to be added, call set-kdedir() instead of
	need-kde().</p>

      </body>
    </subsection>
  </section>
</sections>
