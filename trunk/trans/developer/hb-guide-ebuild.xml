<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/gentoo-howto.xml :: R1.50.
-->

<sections>

<date>2005-07-02</date>

<section>
<title>Drzewo Portage</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Drzewo Portage zwykle znajduje się w katalogu <path>/usr/portage</path> i jest
ułożone w hierarchicznej strukturze, składającej się z katalogów kategorii, w
których znajdują się katalogi paczek. Oto przykład: plik 
<path>util-linux-2.11y.ebuild</path> można znaleźć w katalogu 
<path>/usr/portage/sys-apps/util-linux</path>. W tym samym katalogu może
znajdować się kilka innych wersji <c>util-linux</c> razem z wersją 
<path>util-linux-2.11y.ebuild</path>. Jest tak, ponieważ <e>wszystkie pliki
ebuild danej paczki (niezależnie od wersji)</e> mają wspólny katalog 
<path>kategoria/paczka</path> w głównym katalogu <path>/usr/portage</path>.
</p>

</body>
</subsection>

<subsection>
<title>Pobieranie drzewa Portage z CVS</title>
<body>

<p>
W razie jakichkolwiek wątpliwości co do systemu CVS należy przeczytać
dokument <uri link="http://www.gentoo.org/doc/pl/cvs-tutorial.xml">Praca z
CVS w Gentoo</uri>, gdzie znajdziemy więcej informacji.
</p>

<p>
Drzewo Portage można znaleźć w module <c>gentoo-x86</c> drzewa systemu Gentoo
Linux. Aby pobrać moduł (około 350 megabajtów) najpierw należy skonfigurować CVS
za pomocą powyższego samouczka, a następnie pobrać moduł <c>gentoo-x86</c>
komendą checkout.
</p>

</body>
</subsection>

<subsection>
<title>Co umieszczać (a czego nie) w drzewie Portage</title>
<body>

<p>
Przed napisaniem jakiegokolwiek ebuilda powinniśmy przejrzeć <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> w poszukiwaniu
niezamieszczonego jeszcze w drzewie Portage pliku ebuild do paczki, do której
sami chcieliśmy go pisać. W tym celu należy wejść na stronę <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri>, wybrać "query", jako
produkt (product) wybrać <e>Gentoo Linux</e>, jako składnik (component)
<e>ebuilds</e>. W polu tekstowym powinniśmy wpisać nazwę ebuilda, a jako status
wybrać "NEW", "ASSIGNED", "REOPENED" i "RESOLVED" (to ostatnie jest ważne), a
następnie zatwierdzić zapytanie. Leniwi niech po prostu klikną <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">tutaj</uri>.
</p>

<p>
Drzewo Portage powinno przede wszytkim być używane do przechowywania plików
<path>.ebuild</path>, a także wszelkich względnie małych plików
pomocniczych, takich jak łatki lub przykładowe pliki konfiguracyjne. Pliki
pomocniczne powinny być umieszczane w katalogu
<path>/usr/portage/kategoria/paczka/files</path>, aby nie zaśmiecać głównego
katalogu <path>kategoria/paczka</path>. Wyjątkiem od tej reguły są większe 
pliki łatek (zalecamy przyjąć granicę przy 20KB), które powinny zostać
umieszczone na serwerach lustrzanych Gentoo, aby użytkownicy nie marnowali
przepustowości ani przestrzeni dyskowej. Odradzamy też deweloperom umieszczanie
w CVS plików binarnych (nie-ASCII). Jeśli jednak jest to konieczne (gdybyśmy na
przykład chcieli zamieścić niewielki plik graficzny PNG), należy dodać go do CVS
przy użyciu opcji <c>-kb</c>, tak jak poniżej:
</p>

<pre caption="Dodawanie pliku binarnego do CVS">
# <i>cvs add -kb mojobrazek.png</i>
</pre>

<p>
Opcja <c>-kb</c> instruuje CVS, iż plik <path>mojobrazek.png</path> to plik
binarny i powinien być specjalnie traktowany. Nie powinno się na przykład z
oczywistych względów pozwolić na łączenie różnic między dwiema wersjami tego
pliku. Skoro już mowa o łączeniu zmian, pliki poprawek zamieszczane w Portage
nie powinny być kompresowane. Dzięki temu system CVS będzie mógł łączyć zmiany i
poprawnie informować deweloperów o konfliktach.
</p>

<p>
Należy pamiętać, iż paczki, które wysy³amy jako stabilne muszą być <e>gotowe</e>
do <e>natychmiastowego użycia</e> przez końcowych użytkowników.  Musimy upewnić
się, że posiadamy dobry zestaw domyślnych ustawień, który zadowoli większość
systemów i użytkowników naszej paczki. Jeśli zaś nasza paczka nie działa i nie
mamy pomysłu jak sprawić, by działała, warto spojrzeæ jak poradzili sobie z nią
deweloperzy innych dystrybucji. Przykładów możemy szukać choćby w repozytoriach
<uri link="http://cvs.mandriva.com/cgi-bin/cvsweb.cgi/SPECS/">Mandrivy</uri>,
<uri link="http://www.debian.org/distrib/packages">Debiana</uri> lub <uri
link="http://cvs.fedora.redhat.com/">Fedory</uri>.
</p>

<p>
Wysy³aj±c pliki ebuild do CVS wszyscy deweloperzy
powinni używać polecenia <c>repoman commit</c> zamiast <c>cvs commit</c>. Przed
samym zamieszczeniem należy wykonać polecenie <c>repoman full</c>, aby upewnić
się, że o niczym nie zapominamy.
</p>

</body>
</subsection>

<subsection>
<title>Polityka wysy³ania do CVS</title>
<body>

<ul>
<li>Zawsze należy wykonać polecenie <c>repoman scan</c> przed wys³aniem.</li>
<li>Zawsze należy wykonać polecenie <c>repoman full</c> przed wys³aniem.</li>
<li>
Zawsze powinniśmy sprawdzić poprawność pliku <path>package.mask</path> przed
jego wys³aniem przez wykonanie <c>emerge --pretend mypkg</c> i sprawdzenie czy
nie zawiera konfliktów.
</li> 
<li>Zawsze należy uaktualnić plik <path>ChangeLog</path> przed wys³aniem.</li> 
<li>
Zawsze powinniśmy wys³aæ uaktualniony plik <path>package.mask</path> przed
uaktualnioną paczką, w razie gdyby wystąpiły konflikty podczas wysy³ania pliku
<path>package.mask</path>.
</li> 
<li>
Zawsze powinniśmy wykonywać wysy³anie atomowe; jeśli wysy³amy paczkę z nową
licencją albo taką, która jest zamaskowana, najpierw należy wys³aæ uaktualniony
plik <path>package.mask</path> i/lub licencję, następnie plik ebuild,
<path>ChangeLog</path>, łatki i plik <uri
link="?part=2&amp;chap=4">metadata.xml</uri> wszystkie za jednym razem, aby
uniknąć uszkodzenia systemów użytkowników.
</li>
</ul>

</body>
</subsection>

<subsection>
<title>Katalog files</title>
<body>

<p>
Jak wspomniano wcześniej, w każdym podkatalogu paczki znajduje się podkatalog
<path>files/</path>. W nim należy umieszczać wszelkie łatki, pliki
konfiguracyjne lub inne pliki pomocnicze; pliki większe niż około 20KB powinny
być zamieszczane na serwerach lustrzanych, aby zmniejszyć ilość (niepotrzebnych)
plików, które nasi użytkownicy będą musieli ściągnąć. Warto rozważyć takie
nazywanie tworzonych przez siebie poprawek, dzięki którym paczka w ogóle się
zbuduje, aby uwzględnia³y wersję w nazwie, na przykład
<path>paczka-1.0-gentoo.diff</path>, lub pro¶ciej, <path>1.0-gentoo.diff</path>.
Przy okazji człon <path>gentoo</path> informuje że poprawka ta została stworzona
przez nas, deweloperów Gentoo, a nie pobrana z listy dyskusyjnej albo innego
miejsca. Raz jeszcze: nie należy kompresować tych plików, ponieważ CVS nie radzi
sobie dobrze z plikami binarnymi.
</p>

<p>
Warto rozważyć dodawanie przedrostka lub przyrostka (na przykład
<path>mypkg-1.0</path>) do wszystkich plików, które umieszczamy w katalogu
<path>files/</path> aby pliki wykorzystywane z konkretną wersją ebuilda można
było łatwo odróżnić od siebie, co powoduje też widoczność zmian pomiędzy każdą
poprawką. Ogólnie jest to dobry pomysł. :) Możemy użyć innego przyrostka, jeśli
chcemy aby nazwa pliku łatki przekazywała więcej informacji.
</p>

<p>
Jeśli w katalogu <path>files/</path> chcemy umieścić więcej plików, warto
stworzyć podkatalogi, na przykład <path>files/1.0/</path> i umieszczać
odpowiednie pliki w swoich własnych podkatalogach. Gdy używamy tej metody, nie
jest już konieczne dodawanie informacji o wersji do nazw plików. Często jest to
więc bardziej wygodne.
</p>

</body>
</subsection>
</section>

<section>
<title>Skrypty ebuild</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Skrypty ebuild są podstawą całego systemu Portage. Zawierają one wszelkie
informacje potrzebne do pobrania, rozpakowania, skompilowania i instalacji
zestawu źródeł, a także wykonania ewentualnych czynności poprzedzających i/lub
następujących po instalacji i/lub deinstalacji. Pomimo iż większość Portage
napisana jest w języku Python, same skrypty ebuild napisane są w bashu, ponieważ
wykorzystanie języka skryptowego powłoki pozwala nam na wykonywanie komend tak
samo jak z wiersza poleceń. Jednym z najważniejszych założeń projektowych
skryptów ebuild jest nazwanie zawartych w nim poleceń analogicznie do tych,
które wypisywalibyśmy, instalując paczkę ręcznie poprzez wiersz poleceń. Również
z tego względu użycie składni basha jest bardzo wskazane.
</p>

<p>
Skrypty ebuild są interpretowane przez komendy <c>ebuild</c> i <c>emerge</c>.
Wyobraźmy sobie polecenie <c>ebuild</c> jako niskopoziomowe narzędzie, służące
do budowania. Potrafi zbudować i zainstalować pojedynczy ebuild, ale nic poza
tym. Sprawdzi czy zależności są spełnione, ale nie będzie próbować ich
automatycznie spełnić. Z drugiej strony polecenie <c>emerge</c> jest
wysokopoziomowym "silnikiem" dla polecenia <c>ebuild</c> i potrafi w razie
potrzeby automatycznie zainstalować zależności, wykonać instalacje symulowane
<e>pretend</e>, aby użytkownik mógł dowiedzieć się jakie paczki zostaną
zainstalowane i dużo więcej. Ogólnie polecenie <c>emerge</c> jest lepsze od
<c>ebuild</c> pod każdym względem oprócz jednego. Za pomocą <c>ebuild</c> możemy
stopniowo i pojedynczo wykonywać poszczególne fazy instalacji paczki (pobieranie
źródeł, rozpakowanie, kompilacja, instalacja i integracja paczki z systemem).
Jest to nieocenione narzędzie do debugowania dla deweloperów, ponieważ umożliwia
zawężenie problemu z ebuildem do konkretnego fragmentu skryptu ebuild.
</p>

</body>
</subsection>
<subsection>
<title>Nazewnictwo plików ebuild</title>
<body>

<p>Nazwa pliku ebuild składa się z czterech logicznych podsekcji:</p>

<p><c>pkg-ver{_suf{#}}{-r#}.ebuild</c></p>

<note>
Nawiasy klamrowe (<c>{}</c>) otaczają opcjonalne pola i same nie występują w
nazwie paczki. Znak "<c>#</c>" oznacza dowolną dodatnią liczbę różną od zera.
</note>

<p>
Pierwsza podsekcja, <c>pkg</c> oznacza nazwę paczki. Powinna ona zawierać
jedynie małe litery, cyfry od 0 do 9 oraz dowolną liczbę pojedynczych znaków
minus (<c>-</c>), podkreślenia (<c>_</c>) lub plus (<c>+</c>).
Przykłady: <c>util-linux</c>, <c>sysklogd</c> i <c>gtk+</c>. W Portage można
znaleźć kilka paczek, które nie spełniają tych wymogów, ale <e>nasze</e> paczki
muszą je spełniać.
</p>

<p>
Druga podsekcja, <c>ver</c> oznacza wersję paczki, która zwykle powinna
odpowiadać wersji głównego archiwum ze źródłami. Najczęściej wersja składa się z
dwóch lub trzech (czasem więcej) liczb oddzielonych kropkami, na przykład w ten
sposób: <c>1.2</c> lub <c>4.5.2</c>. Czasem bezpośrednio za ostatnią liczbą może
pojawić się pojedyncza litera, na przykład <c>1.4b</c> lub <c>2.6h</c>. Wersja
paczki połączona jest myślnikiem z nazwą paczki. Przykładowo: <c>coś-1.0</c>,
<c>bla-2.4.6</c>.
</p>

<impo>
Chcąc użyć litery poprzedzającej numer wersji należy mieć na uwadze, że <e>nie
powinna</e> ona oznaczać statusu alpha lub beta paczki, ponieważ alpha i beta to
<e>wersje zapoznawcze</e> (ang. prerelease), natomiast wersje z literą na
początku to <e>nowsze wersje</e>. To istotne rozróżnienie, ponieważ Portage
używa numeru wersji ebuilda do określenia czy jest on nowszy czy starszy od
pozostałych paczek o tej samej nazwie w tej samej kategorii. Jest więc bardzo
ważne aby numery wersji wiernie odzwierciedlały wersję paczki i Portage
właściwie wykonywał sprawdzanie zależności.
</impo>

<p>
Trzecia podsekcja, <c>{_suf{#}}</c> jest opcjonalna i może zawierać jeden z
następujących przyrostków, wymienionych w kolejności od oznaczających najstarsze
wydanie po najnowsze:
</p>

<table>
 <tr><th>Przyrostek</th><th>Znaczenie</th></tr>
 <tr><ti><c>_alpha</c></ti><ti>Wydanie alpha</ti></tr>
 <tr><ti><c>_beta</c></ti><ti>Wydanie beta</ti></tr>
 <tr><ti><c>_pre</c></ti><ti>Wersja zapoznawcza (prerelease)</ti></tr>
 <tr><ti><c>_rc</c></ti><ti>Kadynat do wydania oficjalnego (Release
 candidate)</ti></tr>
 <tr><ti>(none)</ti><ti>Oficjalne wydanie</ti></tr>
 <tr><ti><c>_p</c></ti><ti>Etap poprawek (patch level) (zwykle za
 przyrostkiem występuje liczba całkowita)</ti></tr>
</table>

<p> 
Po każdym z tych przyrostków może zostać dodana dodatnia liczba całkowita różna
od zera, na przykład <c>linux-2.4.0_pre10</c>. Zakładając identyczne wersje,
przyrostki są ułożone następująco (mniejszy oznacza starszy): <c>_alpha</c> &lt;
<c>_beta</c> &lt; <c>_pre</c> &lt; <c>_rc</c> &lt; (brak przyrostka) &lt;
<c>_p</c>.
</p>
       
<p>
Podczas porównywania liczb poprzedzonych identycznymi przyrostkami za nowszą
zostanie uznana większa liczba całkowita. Przykład: <c>bla-1.0_alpha4</c>
jest nowsza niż <c>bla-1.0_alpha3</c>.
</p>

<p>
Czwarta podsekcja nazwy paczki oznacza wewnętrzny numer rewizji 
specyficznej dla systemu Gentoo Linux. Jest on opcjonalny, podobnie jak
przyrostek. Znak <c>#</c> jest dodatnią liczbą całkowitą różną od zera, na
przykład <c>paczka-4.5.3-r3</c>.
</p>

<p>
Numer rewizji jest niezależny od wersji archiwum źródłowego i informuje, iż
dostępna jest nowa i poprawiona wersja danej paczki, specyficzna dla systemu
Gentoo Linux. Pierwsze wydania paczek nie mają numeru rewizji, co oznacza, że
paczkę <c>package-4.5.3</c> Portage potraktuje jak mającą zerowy numer rewizji.
Oznacza to, że paczki zliczane będą w następującej kolejności: <c>1.0</c> (wersja
początkowa), <c>1.0-r1</c>, <c>1.0-r2</c>, itd. 
</p>

<p>
Dokonując niebanalnych zmian w istniejącym pliku ebuild powinniśmy skopiować go
do nowego pliku z numerem rewizji zwiększonym o 1. Należy pamiętać, aby zawsze
odnotowywać zmiany <e>zarówno</e> w pliku <path>ChangeLog</path>, jak i w komunikacie
wysy³ania; pominięcie choć jednego jest wbrew regułom.
</p>

<p>
...w zasadzie to mamy też <e>piątą</e> sekcję nazwy pliku ebuild -- samo
rozszerzenie <c>.ebuild</c>.
</p>

</body>
</subsection>
<subsection>
<title>Zawartość pliku ebuild</title>
<body>

<p>
W tej części zajmiemy się wprowadzeniem do plików ebuild. Aby zobaczyć listę
wszystkiego, co można w nich zrobić, warto przeczytać stronę podręcznika
systemowego man, gdzie są informacje na temat formatu skryptów ebuild, ich
zmiennych i funkcji: <c>man 5 ebuild</c>.
</p>

<p><b>Nagłówki</b></p>

<p>
Nagłówek wysy³anego pliku ebuild powinien być <e>dokładnie</e> taki sam jak ten
w pliku <path>/usr/portage/header.txt</path>. Nie należy modyfikować go w żaden
sposób, a przede wszytkim nale¿y upewnić się, że linia zawierająca napis
<c>&#36;Header: &#36;</c> jest nienaruszona.
</p>

<p>
Pierwsze trzy linie powinny wyglądać mniej-więcej tak:
</p>

<pre caption="Poprawny nagłówek">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# &#36;Header: &#36;
</pre>

<p><b>Zmienne</b></p>

<p>
Pierwsza część każdego pliku ebuild składa się z kilku zmiennych. Dzielą się one
na trzy kategorie wymienione poniżej:
</p>

<ul>
<li>READ: zmiennych tych możemy użyć, ale <e>nie wolno</e> ich ustawiać</li>
<li>MUST: zmienne, które <e>koniecznie należy ustawić</e></li>
<li>OPT: zmienne, które powinniśmy ustawić</li>
</ul>

<table>
<tr>
  <th>Zmienna</th>
  <th>Kategoria</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Nazwa i wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Nazwa paczki.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>Wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer rewizji lub <c>r0</c>, jeśli paczka nie posiada tego
  numeru.</ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer wersji razem z numerem rewizji.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Zawiera pełną nazwę paczki <c>${PN}-${PVR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Rozdzielona spacjami lista nazw plików z <c>SRC_URI</c>. Nie uwzględnia
    ścieżek URL, tylko same nazwy plików.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do katalogu <path>distfiles</path>, w którym zwykle są
    przechowywane wszystkie pobrane pliki ze ¼ród³ami paczek. Zwykle jest to
    ścieżka <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do podkatalogu <path>files</path> z katalogu danej paczki w
    drzewie Portage. Nie wolno modyfikować tej zmiennej.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny katalogu roboczego danego ebuilda. Nic nie powinno być
    budowane na zewnątrz tego katalogu.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Katalog źródłowy naszej paczki; zwykle jest to <c>${WORKDIR}/${P}</c>.
    Portage przyjmie tę wartość jako domyślną, nie trzeba jej więc ustawiać
    samemu.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog tymczasowy na naszą paczkę. Jest on używany jako wirtualny katalog
    <path>/tmp</path> podczas przetwarzania skryptu ebuild.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny, do którego paczka zostanie zainstalowana. Należy traktować
    go jako wirtualny katalog <path>/</path>.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage obsługuje instalowanie jednocześnie różnych wersji tego samego
    programu. Na przykład jeśli chcielibyśmy zainstalować jednocześnie GCC 2.95
    i GCC 3.2, należałoby ustawić zmienną <c>SLOT</c> w każdym pliku ebuild. W
    tym przypadku dla GCC 2.95 ustawilibyśmy zmienną <c>SLOT</c> na <c>2</c>, a
    dla GCC 3.2 na <c>3</c>.
    <br/>
    <b>Uwaga</b>: Podanie <c>0</c> jako wartość zmiennej <c>SLOT</c> oznacza, że
    dana paczka ma tylko jedno możliwe ustawienie <c>SLOT</c> (innymi słowy, nie
    da się jej "SLOTować").
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta określa jaką licencją objęty jest program, na przykład GPL-2,
    BSD, itp... Zawartością tej zmiennej musi być poprawna licencja (jest nią
    dowolna licencja z pliku <path>/usr/portage/license/</path>). Jesli danej
    licencji nie ma w tym pliku, musi zostać tam dodana zanim plik ebuild będzie
    mógł być dodany do drzewa Portage. Jeśli licencja nie zezwala na
    redystrybucję programu, należy dodać <c>RESTRICT</c>="nomirror" do pliku
    ebuild.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta pełni teraz kilka funkcji. Przede wszystkim określa na jakie
    architektury sprzętowe przeznaczony jest dany ebuild. Przykładowe wartości
    to: <e>x86, ppc, sparc, mips, alpha, arm, hppa, amd64 i ia64</e>. Więcej
    szczegółów można znaleźć w pliku profiles/arch.list. Jak nietrudno się
    domyślić, zmienną tę ustawiamy zgodnie z architekturą docelowej maszyny.
    Portage nie zezwoli maszynie x86 budować paczek innych niż x86, zgodnie z
    tym, co jest podane w zmiennej <c>KEYWORDS</c>. Paczki, które nie wspierają
    architektury danego komputera są automatycznie maskowane przez Portage.
    Jeśli flaga <c>KEYWORDS</c> posiada przedrostek <e>~</e>, oznacza to, że
    dany ebuild działa, ale powinien zostać przetestowany w kilku środowiskach,
    zanim może zostać uznany za stabilny. Jeśli zaś przed flagą <c>KEYWORDS</c>
    występuje znak <e>-</e>, dana paczka nie będzie działać na danej
    architekturze. Paczka jest uznawana za stabilną, jeśli nic nie poprzedza
    zmiennych zawartych w <c>KEYWORDS</c>. Ustawiając odpowiednio zmienną
    <c>ACCEPT_KEYWORDS</c> w pliku <path>make.conf</path> definiujemy którym z
    powyższych typów paczek zezwalamy na instalację.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti><e>Krótki</e>, mieszczący się w jednej linii opis paczki.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    URL-e każdego pliku ze źródłami paczki, rozdzielone białym znakiem. W
    zmiennych SRC_URI i S nie powinno się umieszczać numerów wersji. Powinniśmy
    zawsze stosować zmienne ${PV} lub ${P}, a jeśli numer wersji nie pokrywa się z nazwą
    pliku zawierającego źródła, należy stworzyć zmienną ${MY_P} i użyć jej
    zamiast dwóch poprzednich.
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    Strona domowa paczki. Jeśli nie możemy znaleźć oficjalnej strony, można
    podać odnośnik z <uri link="http://freshmeat.net/">freshmeat.net</uri>, lub
    podobnej strony z bazą danych programów. Nigdy nie należy odnosić się do
    innej zmiennej wewnątrz tej; musi ona zawierać tylko czysty tekst.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    W zmiennej tej zamieszczamy zmienne <c>USE</c>, z jakich korzysta nasza
    paczka. Należy pamiętać, że nie wolno tutaj umieścić <c>KEYWORDS</c>!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do zbudowania paczki. Więcej
    informacji na temat składni znajdziemy w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do uruchomienia programu z paczki. Jak
    wspomniano wyżej, więcej szczegółów można znaleźć w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
</table>

<p><b>Funkcje</b></p>

<p>
W plikach ebuild można zdefiniować wiele różnych funkcji, które kontrolują
proces budowania i instalacji naszej paczki.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Funkcja ta służy do wykonywania wszelkich wstępnych czynności. Może to
    obejmować sprawdzenie czy istnieje już plik konfiguracyjny. Jeśli w tym
    miejscu konieczne jest dodanie użytkowników, należy również sprawdzić to 
    w funkcji <c>pkg_preinst()</c> zanim paczka zostanie zainstalowana.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    W tym miejscu informujemy użytkownika o tym, co musi zrobić, jeśli z
    jakiegoś powodu (na przykład licencji) źródła nie mogą zostać automatycznie
    pobrane przez Portage. Jednocześnie należy ustawić zmienną
    <c>RESTRICT=&quot;fetch&quot;</c>. W niniejszej funkcji wolno nam jedynie
    wyświetlać komunikaty, nie należy wywoływać polecenia <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Tej funkcji należy użyć, aby rozpakować źródła naszej paczki, nałożyć
    poprawki i uruchomić zewnętrzne programy, na przykład autotools. Domyślnie
    funkcja ta rozpakuje pliki wymienione w zmiennej <c>A</c>. Początkowy
    katalog roboczy definiuje zmienna <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Za pomocą tej funkcji konfigurujemy i budujemy paczkę. Początkowy
    katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Tej funkcji użyjemy, aby zainstalować paczkę w katalogu określonym przez
    zmienną <c>D</c>. Jesli nasza paczka korzysta z automake, możemy tego łatwo
    dokonać poprzez <c>make DESTDIR=${D} install</c>. <e>Należy upewnić się, że
    paczka wszystkie swoje pliki zainstaluje używając <c>D</c> jako katalogu
    głównego!</e> Początkowy katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_test</c></ti>
  <ti>
    Funkcja ta jest wykonywana tylko wtedy, gdy zmienna
    <c>FEATURES="maketest"</c> jest ustawiona, a zmienna
    <c>RESTRICT="maketest"</c> nie jest ustawiona. Domyślnie wywołuje 
    dostępną funkcję testującą z plików Makefile, znajdujących się w
    katalogu zdefiniowanym przez zmienną <c>${S}</c>, uruchamiając albo "make
    test" albo "make check", w zależności od tego, co jest dostępne. Funkcję tę
    można nadpisać i zaimplementować własną metodę testowania paczki.
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed
    zintegrowaniem</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po
    zintegrowaniu</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed 
    odinstalowaniem</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po 
    odinstalowaniu</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Za pomocą tej funkcji możemy przygotować początkową konfigurację paczki tuż
    po jej instalacji. Wszystkie ścieżki w obrębie tej funkcji powinny być
    poprzedzone zmienną <c>ROOT</c>, wskazującą podany przez użytkownika
    katalog instalacji, który niekoniecznie musi być katalogiem <path>/</path>.
    Funkcja ta wykonywana jest <e>tylko i wyłącznie</e> wtedy, gdy użytkownik
    wyda polecenie: <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze</b></p>

<p>
W naszych skryptach ebuild mo¿emy u¿yæ tak¿e nastêpuj±cych funkcji pomocniczych.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Sprawdza czy jedna lub wiêcej flag USE s± zdefiniowane. Je¶li tak, funkcja
    ta wypisze te flagi zawarte w zmiennej <c>USE</c>. Zachowanie to jednak ma
    siê wkrótce zmieniæ i funkcja <c>use</c> nie bêdzie nic wypisywaæ, za to
    bêdzie to robiæ funkcja <c>usev</c>. Aby sprawdziæ istnienie flagi USE,
    nale¿y u¿yæ <c>use blabla</c>.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Zwraca 1 je¶li w systemie jest ¿±dana wersja danej paczki. Na przyk³ad
    <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Zwraca <path>kategoria/paczka-wersja</path> danej paczki, podanej w formacie
    <path>kategoria/paczka</path>. Na przyk³ad <c>best_version
    x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Funkcja ta sprawdza czy flaga USE zosta³a zdefiniowana i zwraca odpowiednio
    &quot;--with-foobar&quot; lub &quot;--without-foobar&quot;. Je¶li podamy
    funkcji tylko jeden argument, oznacza to, ¿e jest on zarówno flag± USE, jak
    i tekstem with/without. Podaj±c za¶ dwa, pierwszy z nich jest flag± USE, a
    drugi tekstem with/without. Na przyk³ad <c>use_with truetype freetype</c>
    wypisze &quot;--with-freetype&quot;, je¶li zmienna <c>USE</c> zawiera
    truetype. 
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Tak samo jak przypadku <c>use_with</c>, lecz zwraca odpowiednio 
    &quot;--enable-blabla&quot; lub &quot;--disable-blabla&quot;.
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Sprawdza czy Portage zna wersjê j±dra. Je¶li nie, wypisze komunikat b³êdu i
    zakoñczy dzia³anie niepowodzeniem. Je¶li w naszym skrypcie potrzebujemy
    wersji j±dra, nale¿y u¿yæ zmiennej <c>KV</c>, która jest automatycznie
    definiowana przez Portage. W systemie dzia³aj±cym na j±drze
    gentoo-sources-2.4.20-r6, zmienna <c>KV</c> bêdzie mia³a warto¶æ
    &quot;2.4.20&quot;.
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Tworzy (je¶li jest to konieczne) plik <path>.keep</path> w danym katalogu,
    aby katalog ten nie zosta³ automatycznie usuniêty. <e>Nigdy</e> nie nale¿y
    tworzyæ pliku <path>.keep</path> rêcznie. Je¶li zasada dzia³ania funkcji
    <c>keepdir</c> zmieni siê w Portage, samodzielne tworzenie tego pliku
    popsuje paczkê.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Wykonuje polecenie <c>./configure</c> z wszelkimi niezbêdnymi zmianami 
    w ¶cie¿kach (prefix, host, mandir, infodir, datadir, sysconfdir,
    localstatedir). Mo¿emy opcjonalnie przekazaæ dodatkowe argumenty do
    <c>./configure</c>, przekazuj±c je funkcji <c>econf</c> przy wywo³aniu, za¶
    u¿ytkownicy w razie potrzeby mog± ustawiæ zmienn± ¶rodowiskow±
    <c>EXTRA_ECONF</c>. Opcje przekazane skryptowi configure przejmuj±
    pierwszeñstwo w odwrotnej kolejno¶ci ni¿ jak zosta³y podane. Innymi s³owy,
    pierwszy przekazany argument zostanie zawsze zast±piony ostatnim.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Wykonuje polecenie <c>make install</c> z wszystkimi niezbêdnymi zmianami w
    ¶cie¿kach (prefix, datadir, mandir, infodir, datadir, sysconfdir,
    localstatedir). Jak wy¿ej, mo¿na przekazaæ dodatkowe argumenty do komendy
    make, przekazuj±c je funkcji <c>einstall</c> przy jej wywo³aniu. Zauwa¿my
    jednak, ¿e preferowanym sposobem zainstalowania paczki jest wywo³anie
    komendy <c>make install DESTDIR=${D}</c>, a nie za pomoc± <c>einstall</c>.
    Komenda ta u¿ywana jest tylko zastêpczo w przypadku popsutych plików make.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Powoduje przerwanie aktualnego procesu. Poinformuje u¿ytkownika o przyczynie
    problemu, wypisuj±c podane argumenty. Przekazanie argumentów funkcji
    <c>die</c> jest wysoce wskazane, je¶li mamy wiêcej ni¿ jedno jej wywo³anie w
    danej funkcji. O wiele trudniej jest wy¶ledziæ problemy, je¶li nie wiemy 
    <e>gdzie</e> problem wyst±pi³.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Informuje u¿ytkownika o czym¶ istotnym. Argument przekazany funkcji
    <c>einfo</c> bêdzie komunikatem, który zobaczy u¿ytkownik. Nie nale¿y u¿ywaæ
    tej funkcji aby wypisywaæ nag³ówki w rodzaju
    &quot;*************************************&quot;. Sam fakt, ¿e zosta³a
    u¿yta funkcja <c>einfo</c> wystarczy, aby przyci±gn±æ uwagê u¿ytkownika.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze dostarczone przez eutils.eclass</b></p>

<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "eutils". Nale¿y upewniæ siê, ¿e u¿yli¶my instrukcji
<c>inherit eutils</c>, inaczej funkcje te nie bêd± dzia³aæ.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>epatch</c></ti>
  <ti>
    Funkcja ta jest bardziej przyjazn± wersj± polecenia <c>patch</c>. Dzia³a ona
    nie tylko z ³atkami w plikach tekstowych, ale te¿ w plikach typu .bz2, .gz 
    i .zip. Nie trzeba podawaæ opcji "-p", za¶ opcje, które nale¿y podaæ powinny
    byæ ustawione w zmiennej <c>EPATCH_OPTS</c>. Funkcja oczekuje pliku lub
    katalogu jako argumentu. Je¶li podamy katalog, wszystkie ³atki w postaci
    "??${ARCH}_..." zostan± na³o¿one. Aby poprawka mog³a byæ na³o¿ona, musi
    pasowaæ do naszej architektury, mieæ napis "_all_" w nazwie pliku, lub
    zmienna <c>EPATCH_FORCE</c> musi byæ ustawiona na "yes".
  </ti>
</tr>
<tr>
  <ti><c>gen_usr_ldscript</c></ti>
  <ti>
    Funkcja ta tworzy w katalogu /usr/lib skrypty linkera dla dynamicznych
    bibliotek z katalogu /lib. Naprawia to problemy z linkowaniem gdy plik .so
    znajduje siê w katalogu /lib, podczas gdy plik .a znajduje siê w katalogu
    /usr/lib.
  </ti>
</tr>
<tr>
  <ti><c>have_NPTL</c></ti>
  <ti>
    Zwraca 0 je¶li system u¿ywa NPTL jako implementacji PThreads. 
  </ti>
</tr>
<tr>
  <ti><c>get_number_of_jobs</c></ti>
  <ti>
    Funkcja ta sprawdza ile jest procesorów w systemie, a nastêpnie ustawia
    prawid³ow± opcjê -jX w zmiennej <c>MAKEOPTS</c>.
  </ti>
</tr>
<tr>
  <ti><c>mymktemp</c></ti>
  <ti>
    Funkcja ta pe³ni rolê interfejsu dla mktemp, je¶li ten istnieje, lub
    zastêpuje go, je¶li nie istnieje.
  </ti>
</tr>
<tr>
  <ti><c>edos2unix</c></ti>
  <ti>
    Funkcja ta robi dok³adnie to samo co program <c>dos2unix</c>.
  </ti>
</tr>
<tr>
  <ti><c>egetent</c></ti>
  <ti>
    Funkcja egetent pe³ni rolê interfejsu dla <c>getnet</c> pod Linuksem lub dla
    <c>nidump</c> pod Mac OS X (R).
  </ti>
</tr>
<tr>
  <ti><c>enewuser</c></ti>
  <ti>
    Tworzy nowego u¿ytkownika. Funkcja oczekuje wymaganego parametru z nazw±
    u¿ytkownika i szeregu opcjonalnych argumentów: <c>$2</c> zawiera UID, za¶
    gdy przeka¿emy -1 u¿yty zostanie nastêpny dostêpny; <c>$3</c> zawiera
    pow³okê systemow±, domy¶lnie bêdzie to <path>/bin/false</path>; <c>$4</c> to
    katalog domowy, domy¶lnie <path>/dev/null</path>, <c>$5</c> zawiera grupy,
    do których u¿ytkownik powinien zostaæ dodany (domy¶lnie ¿adne), za¶
    <c>$6</c> zawiera komentarz - domy¶lnie "added by portage for <c>${PN}</c>".
  </ti>
</tr>
<tr>
  <ti><c>enewgroup</c></ti>
  <ti>
    Dodaje now± grupê. Funkcja oczekuje wymaganego parametru z nazw± grupy -
    opcjonalny drugi argument to konkretny GID.
  </ti>
</tr>
<tr>
  <ti><c>make_desktop_entry</c></ti>
  <ti>
    Tworzy wpis desktop wg standardu freedesktop.org. Pierwszy argument
    zawiera ¶cie¿kê do pliku binarnego z programem. Dodatkowo drugi zawiera
    nazwê pliku ikony - domy¶lna warto¶æ to <c>${PN}</c>; trzeci mo¿e zawieraæ
    ¶cie¿kê do pliku ikony - wzglêdn± do ¶cie¿ki <path>/usr/share/pixmaps</path>
    lub pe³n± ¶cie¿kê. Warto¶æ domy¶lna to <c>${PN}</c>.png; czwarty mo¿e
    zawieraæ <uri
    link="http://standards.freedesktop.org/menu-spec/latest/apa.html">kategoriê
    aplikacji</uri>, za¶ pi±ty argument zawiera opcjonaln± ¶cie¿kê pocz±tkow±
    dla aplikacji.
  </ti>
</tr>
<tr>
  <ti><c>check_license</c></ti>
  <ti>
    Wy¶wietla licencjê aby u¿ytkownik móg³ j± przeczytaæ i zaakceptowaæ. Je¶li
    nie podano argumentów, u¿yta zostanie licencja okre¶lona przez zmienn±
    <c>${LICENSE}</c>.
  </ti>
</tr>
<tr>
  <ti><c>unpack_pdv</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez pdv, przy czym pierwszy argument
    musi zawieraæ nazwê pliku archiwum, drugi za¶ warto¶æ "off_t", któr± nale¿y
    wygenerowaæ rêcznie: <c>strace -elseek ${plik}</c>, za¶ dla przyk³adowego
    wywo³ania takiego jak to: "lseek(3, -4, SEEK_END)"  przekazaliby¶my warto¶æ
    "4". 
  </ti>
</tr>
<tr>
  <ti><c>unpack_makeself</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez makeself, wymaga nazwy pliku do
    rozpakowania jako argumentu.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_get_cds</c></ti>
  <ti>
    Prosi u¿ytkownika o w³o¿enie p³yty CD do czytnika. Rozpoznaje czy p³yta jest
    w³a¶ciwa sprawdzaj±c, czy znajduje siê na niej plik o nazwie podanej jako
    argument funkcji. U¿ytkownik bêdzie kolejno proszony o w³o¿enie tylu p³yt,
    ile podamy argumentów. Miejsce zamontowania p³yty zostanie ustawione w
    zmiennej <c>${CDROM_ROOT}</c>.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_load_next_cd</c></ti>
  <ti>
    £aduje nastêpn± p³ytê CD gdy ju¿ skoñczyli¶my z poprzedni±. Je¶li funkcja
    zwróci warto¶æ, zmienna <c>${CDROM_ROOT}</c> wska¿e nastêpn± p³ytê CD.
  </ti>
</tr>
<tr>
  <ti><c>strip-linguas</c></ti>
  <ti>
    Zadaniem tej funkcji jest upewnienie siê, ¿e zmienna LINGUAS zawiera tylko
    obs³ugiwane przez paczkê jêzyki, podawane jako argumenty dla funkcji. Je¶li
    pierwszym argumentem jest -i, tworzona jest lista plików .po w okre¶lonych
    katalogach i u¿yta jest czê¶æ wspólna list. Je¶li za¶ pierwszym
    argumentem jest -u, tworzona jest lista plików .po w okre¶lonych katalogach
    i u¿yta jest suma list.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze dostarczone przez flag-o-matic.eclass</b></p>

<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "flag-o-matic". Nale¿y upewniæ siê, ¿e u¿yli¶my
instrukcji <c>inherit flag-o-matic</c>, inaczej funkcje te nie bêd± dzia³aæ.
Nigdy nie nale¿y rêcznie modyfikowaæ ustawieñ kompilatora, zamiast tego
powinni¶my u¿yæ funkcji z eklasy flag-o-matic do czynno¶ci typu odfiltrowanie
sprawiaj±cych k³opoty flag.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>filter-flags</c></ti>
  <ti>
    Funkcja ta usuwa konkretne flagi ze zmiennych <c>C[XX]FLAGS</c> - usuwane s±
    tylko flagi, których nazwy w ca³o¶ci pasuj± do nazw tych, które chcemy usun±æ.
  </ti>
</tr>
<tr>
  <ti><c>append-flags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniej±cych zmiennych
    <c>C[XX]FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>replace-flags</c></ti>
  <ti>
    Zamienia w zmiennych <c>C[XX]FLAGS</c> flagê podan± jako pierwszy argument
    na flagê podan± jako drugi.
  </ti>
</tr>
<tr>
  <ti><c>replace-cpu-flags</c></ti>
  <ti>
    Zamienia flagi -march=... lub -mcpu=... zawieraj±ce drugi argument
    funkcji flagami z pierwszego argumentu.
  </ti>
</tr>
<tr>
  <ti><c>replace-sparc64-flags</c></ti>
  <ti>
    Ta flaga ustawia -mcpu=... na v8 SPARC i u¿ywa pierwotn± warto¶æ tej flagi
    jako -mtune, o ile ta nie zosta³a ju¿ podana.
  </ti>
</tr>
<tr>
  <ti><c>strip-flags</c></ti>
  <ti>
    Usuwa wszystkie flagi z wyj±tkiem tych podanych w zmiennej
    <c>ALLOWED_FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>strip-unsupported-flags</c></ti>
  <ti>
    Usuwa ze zmiennych <c>C[XX]FLAGS</c> wszystkie flagi, których nie obs³uguje
    aktualnie dzia³aj±ca wersja kompilatora GCC.
  </ti>
</tr>
<tr>
  <ti><c>get-flag</c></ti>
  <ti>
    Znajduje flagê i wypisuje jej warto¶æ.
  </ti>
</tr>
<tr>
  <ti><c>is-flag</c></ti>
  <ti>
    Funkcja ta zwraca warto¶æ true je¶li dana flaga jest aktualnie ustawiona w
    zmiennych <c>C[XX]FLAGS</c>; nazwy flag musz± siê zgadzaæ w ca³o¶ci, aby
    zosta³y dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>append-ldflags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniej±cej zmiennej <c>LDFLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>filter-ldflags</c></ti>
  <ti>
    Usuwa podane flagi ze zmiennej <c>LDFLAGS</c>, przy czym nazwy flag musz±
    siê zgadzaæ w ca³o¶ci, aby zosta³y dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>fstack-flags</c></ti>
  <ti>
    Dodaje flagê -fno-stack-protector, która znosi flagi -fstack-protector i
    -fstack-protector-all.
  </ti>
</tr>
</table>



<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "toolchain-funcs". Nale¿y upewniæ siê, ¿e u¿yli¶my
instrukcji <c>inherit toolchain-funcs</c>, inaczej funkcje te nie bêd± dzia³aæ.
Nigdy nie nale¿y rêcznie modyfikowaæ ustawieñ kompilatora lub binutils, zamiast tego
powinni¶my u¿yæ funkcji z eklasy flag-o-matic aby okre¶laæ kompilatory i
binutils.
</p>
<p>
Poni¿sze funkcje stosuje siê, aby wspieraæ kompilacjê skro¶n± i kompilator icc.
Powinny byæ one u¿ywane gdy paczka wprost u¿ywa gcc, g++, ld, ranlib lub
jakichkolwiek poni¿szych narzêdzi. Na ogó³ paczki, które u¿ywaj± narzêdzi do
autokonfiguracji wykrywaj± kompilacjê skro¶n± automatycznie i nie potrzebuj±
poni¿szych funkcji.
</p>
  <table>
    <tr>
      <th>Funkcja</th>
      <th>Zastosowanie</th>
    </tr>
    <tr>
      <ti>
        <c>tc-getAR</c>
      </ti>
      <ti>Zwraca nazwê archiwizatora.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getAS</c>
      </ti>
      <ti>Zwraca nazwê asemblera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCC</c>
      </ti>
      <ti>Zwraca nazwê kompilatora C.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCXX</c>
      </ti>
      <ti>Zwraca nazwê kompilatora C++.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>Zwraca nazwê linkera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getNM</c>
      </ti>
      <ti>Zwraca nazwê narzêdzia do inspekcji symboli/obiektów.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getRANLIB</c>
      </ti>
      <ti>Zwraca nazwê programu indeksuj±cego archiwa</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getF77</c>
      </ti>
      <ti>Zwraca nazwê kompilatora fortrana.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>Zwraca nazwê linkera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getGCJ</c>
      </ti>
      <ti>Zwraca nazwê kompilatora javy.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getBUILD_CC</c>
      </ti>
      <ti>Zwraca nazwê kompilatora C do budowania.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-is-cross-compiler</c>
      </ti>
      <ti>Prosty sposób na sprawdzenie czy u¿ywamy kompilatora skro¶nego.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-fullversion</c>
      </ti>
      <ti>Zwraca wersjê tak samo jak polecenie $($CC -dumpversion)</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-version</c>
      </ti>
      <ti>Zwraca tylko postaæ &lt;major>.&lt;minor> wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-major-version</c>
      </ti>
      <ti>Zwraca czê¶æ Major wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-minor-version</c>
      </ti>
      <ti>Zwraca czê¶æ Minor wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-micro-version</c>
      </ti>
      <ti>Zwraca czê¶æ Micro wersji.</ti>
    </tr>
  </table>


</body>
</subsection>

<subsection>
<title>Zasady pisania plików ebuild</title>
<body>

<p>
Pliki ebuild s± tak naprawdê skryptami pow³oki, powinni¶my wiêc przy ich edycji
u¿ywaæ trybu edycji skryptów pow³oki naszego edytora. Nale¿y stosowaæ
odpowiednie wciêcia, wy³±cznie przy pomocy znaków tabulacji -- <e>¿adnych
spacji</e>. Nale¿y siê upewniæ, ¿e rozmiar tabulacji w naszym edytorze wynosi 4
spacje. Zawsze powinni¶my stosowaæ nawiasy klamrowe wokó³ zmiennych
¶rodowiskowych, czyli <c>${P}</c> zamiast <c>$P</c>.
</p>

<p>
D³ugie linie zawijamy za pomoc± znaku ' \':
</p>

<pre caption="Zawijanie wierszy w plikach ebuild">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Wiêcej szczegó³ów znajdziemy w pliku <path>skel.ebuild</path> (zwykle znajduje
siê on w katalogu <path>/usr/portage</path>).
</p>

<p>
Warto zwróciæ uwagê na domy¶lny plik vimrc w Gentoo je¶li u¿ywamy programu Vim
do edycji plików ebuild/eclass. Znajduje siê on w katalogu
<path>/etc/vim/vimrc</path> i zawiera poprawne ustawienia wciêæ i typów plików
dla plików ebuild i eclass. Jeszcze wiêcej mo¿liwo¶ci, w tym specjalne
pod¶wietlanie sk³adni w plikach ebuild uzyskamy instaluj±c
app-vim/gentoo-syntax.
</p>

<p>
Na systemach innych ni¿ Gentoo podobne ustawienia zyskamy, dopisuj±c poni¿sze
linijki do naszego pliku vimrc, albo jeszcze lepiej, instaluj±c skrypty <uri
link="https://developer.berlios.de/projects/gentoo-syntax/">gentoo-syntax</uri>.
</p>

<pre caption="Konfiguracja vimrc do edycji plików ebuild">
au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh
au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab
</pre>

<p>
Je¶li u¿ywamy edytora Emacs mo¿my dodaæ nastêpuj±cy fragment do pliku .emacsrc
(w GNU Emacs) lub init.el (w XEmacs) aby upewniæ siê, ¿e u¿ywamy poprawnych
ustawieñ przy edycji plików Gentoo.
</p>

<pre caption="Konfiguracja emacsrc do edycji plików ebuild">
(defun ebuild-mode ()
  (shell-script-mode)
  (sh-set-shell "bash")
  (make-local-variable 'tab-width)
  (setq tab-width 4))
(setq auto-mode-alist (cons '("\\.ebuild$" . ebuild-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.eclass$" . ebuild-mode) auto-mode-alist))
</pre>

<p>
Je¶li za¶ u¿ywamy edytora nano, szczê¶liwie oszczêdzono nam pracy. Wystarczy
tylko odkomentowaæ sekcjê dotycz±c± ebuildów w pliku <path>/etc/nanorc</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zmienne USE</title>
<body>

<p>
Dziêki zmiennym USE mo¿liwe jest skonfigurowanie Portage aby globalnie i
automatycznie w³±cza³ lub wy³±cza³ pewne <e>opcjonalne, ustawiane przy
budowaniu</e> funkcje programów. Oto przyk³ad. Za³ó¿my, ¿e jeste¶my fanami
¶rodowiska GNOME i chcieliby¶my, aby ka¿dy ebuild, który daje mo¿liwo¶æ
wkompilowania opcjonalnej obs³ugi tego ¶rodowiska zrobi³ to. W tym przypadku
nale¿y dodaæ <c>gnome</c> do zmiennej <c>USE</c> w pliku
<path>/etc/make.conf</path>, a Portage automatycznie bêdzie dodawa³ opcjonaln±
funkcjonalno¶æ GNOME do paczek, je¶li jest ona dostêpna. Podobnie, je¶li nie
chcemy funkcji GNOME w naszych ebuildach, wystarczy upewniæ siê, ¿e <c>gnome</c>
nie jest dodane do zmiennej <c>USE</c> w pliku <path>/etc/make.conf</path>.
System Gentoo Linux ma niemal przyt³aczaj±c± ilo¶æ opcji USE, dziêki czemu
mo¿emy skonfigurowaæ go dok³adnie tak jak chcemy.
</p>

<note>
Je¶li wy³±czymy flagê USE (na przyk³ad usuwaj±c <c>gnome</c> ze zmiennej
<c>USE</c>), poinstruuje to jedynie Portage aby wy³±czyæ <e>opcjonalne</e>
wsparcie dla GNOME w czasie budowania. Jednak¿e je¶li instalujemy za pomoc±
narzêdzia <c>emerge</c> ebuild, którzy <e>wymaga</e> GNOME, paczka ta oczywi¶cie
bêdzie zawieraæ obs³ugê tego ¶rodowiska. Oznacza to tak¿e, ¿e GNOME zostanie
automatycznie zainstalowane (jako zale¿no¶æ), je¶li wcze¶niej nie by³o go w
systemie. W³a¶nie dlatego dobrze jest u¿yæ polecenia <c>emerge --pretend</c>
zanim uruchomimy &quot;prawdziwy&quot; <c>emerge</c>; w ten sposób zawsze
bêdziemy wiedzieæ co siê zainstaluje.
</note>

<p>
W naszych skryptach ebuild mo¿emy sprawdzaæ czy dana zmienna USE jest ustawiona
za pomoc± polecenia <c>use &lt;zmienna&gt;</c>. Komenda <c>use</c> wypisuje
<c>&lt;zmienn±&gt;</c> je¶li jest ona obecna w zmiennej <c>USE</c> u¿ytkownika.
Najczê¶ciej u¿yjemy tego polecenia analogicznie jak poni¿ej:
</p>

<pre caption="Sprawdzanie czy flaga USE jest ustawiona">
if use X; then
  # Komendy specyficzne dla X...
fi
</pre>

<p>
Zmiennych USE mo¿na równie¿ u¿ywaæ w celu ustawiania zale¿no¶ci. Na przyk³ad
chcieliby¶my aby pewna paczka by³a wymagana tylko je¶li ustawiona jest pewna
zmienna USE. Mo¿emy tego dokonaæ za pomoc± sk³adni <c>flaga? ( kategoria/paczka
)</c> w zmiennej <c>DEPEND</c> naszego pliku ebuild. W tym przypadku
<c>kategoria/paczka</c> bêdzie wymagana jedynie wtedy, gdy <c>flaga</c> bêdzie
obecna w zmiennej <c>USE</c>. Mo¿liwe jest tak¿e okre¶lenie jaka zale¿no¶æ ma
zostaæ u¿yta je¶li pewna flaga USE <e>jest</e> ustawiona, a jaka ma zostaæ
u¿yta, je¶li <e>nie jest</e> ustawiona: <c>flaga? ( kategoria/paczka )</c> i
<c>!flaga? ( innakategoria/innapaczka )</c>. W tym przypadku je¶li <c>flaga</c>
nie jest ustawiona, u¿yta zostanie <c>innakategoria/innapaczka</c> zamiast
<c>kategoria/paczka</c>. Nale¿y upewniæ siê, ¿e nasze ebuildy u¿ywaj± powy¿szej
sk³adni, a nie instrukcji warunkowych IF pow³oki bash. Instrukcje warunkowe
basha nie wspó³pracuj± z cache'owaniem zale¿no¶ci przez Portage, wiêc u¿ywanie
ich popsuje nasz ebuild.
</p>

<p>
Oto wa¿na wskazówka jak u¿ywaæ zmiennej <c>USE</c>. Najczê¶ciej paczki posiadaj±
skrypt <c>./configure</c>, za pomoc± którego dokonuje siê ich konfiguracji.
Zwykle je¶li nasz ebuild u¿ywa <c>./configure</c>, wszelka opcjonalna
funkcjonalno¶æ zostanie w³±czona lub wy³±czona przy budowaniu przez przekazanie
odpowiednich parametrów do polecenia <c>./configure</c>. Oto najlepszy sposób na
obs³u¿enie tego:
</p>

<pre caption="Wyra¿enia warunkowe oparte na ustawieniach USE">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 )
!apache2? ( =net-www/apache-1* )"

src_compile() {
  econf \
    $(use_enable X x11) \
    $(use_enable mysql) \
    || die "Error: econf failed!"
  emake || die "Error: emake failed!"
}
</pre>

<p>
Takie podej¶cie daje dobre wyniki. Nie musimy martwiæ siê jakie s± domy¶lne
ustawienia mysql albo X (w³±czone/wy³±czone), przekazujemy wprost funkcji
<c>econf</c> co ma zrobiæ w oparciu o zmienn± <c>USE</c>. Nie wspominaj±c ju¿ 
o przejrzysto¶ci takiego kodu. :)
</p>

<p>
Pod <uri link="http://www.gentoo.org/dyn/use-index.xml">tym adresem</uri> mo¿emy
obejrzeæ stale uaktualnian± tabelê zmiennych USE.
</p>

</body>
</subsection>
</section>
<section>
<title>Po³o¿enia w systemie plików</title>
<subsection>
<title>Wprowadzenie do FHS</title>
<body>

<p>
Standard rozmieszczenia katalogów w systemie plików ¶ci¶le odpowiada FHS, czyli
<e>File system Hierarchy Standard</e> (standard hierarchii systemu plików).
Uproszczony opis standardu podajemy poni¿ej; kompletn± specyfikacjê mo¿na
znale¼æ pod adresem <uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
Katalog <path>/opt</path> omówiony jest w czê¶ci 3.12 standardu FHS. Czê¶æ 4.4
traktuje o katalogu <path>/usr/X11R6</path>. ¦rodowiska KDE i GNOME nie s±
omówione, a dok³adniej nie ma o nich nawet wzmianki w aktualnej wersji FHS.
</note>

</body>
</subsection>
<subsection>
<title>Jak umieszczaæ paczki w systemie plików</title>
<body>

<p>
Je¶li paczka u¿ywa autoconf i automake, domy¶lne katalogi docelowe przy
instalacji zwykle bêd± poprawne, z kilkoma wyj±tkami:
</p>

<ul>
<li>
Je¶li instalujemy program w katalogu <path>/bin</path>, <path>/sbin</path>,
<path>/usr/bin</path> lub <path>/usr/sbin</path>, dokumentacja man programu
powinna zostaæ zainstalowana w katalogu <path>/usr/share/man</path>. Zwykle
mo¿na to osi±gn±æ pisz±c w skrypcie ebuild <c>./configure
--mandir=/usr/share/man</c>.
</li>
<li>
Pliki dokumentacji GNU info zawsze powinny byæ instalowane w katalogu
<path>/usr/share/info</path>, <e>nawet je¶li dokumentacja nale¿y do programów
specyficznych dla X11, GNOME lub KDE</e>. Zwróæmy uwagê: katalog
<path>/usr/share/info</path> jest <e>jedynym</e> oficjalnym miejscem na pliki
GNU info. Czêsto skrypty <c>./configure</c> domy¶lnie instaluj± pliki GNU info w
katalogu <c>/usr/info</c>. W tej sytuacji nale¿y przekazaæ <c>./configure</c>
parametr <c>--infodir=/usr/share/info</c>.
</li>
<li>
Pliki dokumentacji s± instalowane w katalogu <path>/usr/share/doc</path>, do
podkatalogu, na którego nazwê sk³ada siê nazwa, wersja i rewizja danego
programu. Dotyczy to wszystkich programów: GNOME, KDE, X11 i konsolowych.
Niektóre programy jednak mog± dla swoich potrzeb instalowaæ dodatkow±
dokumentacjê i pliki pomocnicze w hierarchii <path>/usr/share</path>. 
</li>
<li>
Programy i biblioteki specyficzne dla X11 zawsze powinny byæ instalowane w
katalogu <path>/usr</path>, a nie bezpo¶rednio w <path>/usr/X11R6</path>. Tê
hierarchiê katalogów rezerwujemy dla <e>samego</e> Systemu X Window w Wersji 11,
Wydaniu 6. Jest to byæ mo¿e bardziej dos³owna interpretacja standardu FHS ni¿ w
przypadku wielu innych dystrybucji.
</li>
<li>
Podobnie programy GNOME i KDE powinny byæ zawsze instalowane w katalogu
<path>/usr</path>.
</li>
</ul>

<impo>
Niektóre dystrybucje instaluj± GNOME i KDE w katalogu <path>/opt</path>. Nie
istnieje standard, który definiowa³by gdzie nale¿y umieszczaæ pliki tych
¶rodowisk graficznych. W imiê prostoty i spójno¶ci zdecydowali¶my umieszczaæ
wszystkie paczki KDE i GNOME w hierarchii katalogów <path>/usr</path>.
</impo>

<p>
Ogólnie nasze ebuildy powinny instalowaæ pliki w katalogu <path>/usr</path>.
<e>Niektóre</e> programy mog± byæ kompilowane i linkowane z bibliotekami GNOME,
KDE oraz X11, lub bez nich, co mo¿e powodowaæ zamieszanie. Rozwi±zanie, jakie
proponujemy to instalowanie wszystkiego w katalogu <path>/usr</path>, dziêki
czemu autorzy skryptów ebuild unikn± niejednoznacznych sytuacji i niepotrzebnych
komplikacji. Miejsce, w którym bêdziemy instalowaæ pliki programu <e>nie
mo¿e</e> zale¿eæ od obecno¶ci lub nieobecno¶ci jakich¶ zmiennych <c>USE</c>.
Dlatego ebuildy w drzewie Portage <e>praktycznie zawsze</e> instaluj± swoje
pliki wy³±cznie w hierarchii katalogów <path>/usr</path>. 
</p>

<note>
Katalog <path>/opt</path> jest w systemie Gentoo Linux zarezerwowany dla paczek
binarnych, na przyk³ad mozilla-bin, acroread, netscape i realplayer. Najczê¶ciej
paczki instalowane w tym katalogu wymagaj± dodatkowego pliku
<path>/etc/env.d/co¶</path>. S³u¿y on do w³±czenia ¶cie¿ek i dodatkowych
zmiennych do ¶rodowiska. Wiêcej informacji na temat katalogu
<path>/etc/env.d</path> mo¿na znale¼æ w <uri
link="/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=5">tym</uri> dokumencie.
</note>

</body>
</subsection>
</section>
<section>
<title>Skrypty i narzêdzia Portage</title>
<subsection>
<title>Skrypty publiczne</title>
<body>

<p>
S± to skrypty u¿ywane przez administratora systemu do instalacji 
i deinstalacji paczek, a tak¿e przy opiekowaniu siê baz± danych paczek.
</p>

<p>
Skrypt <c>ebuild</c> jest g³ównym "silnikiem" systemu Portage; za jego pomoc±
wykonujemy wszystkie g³ówne zadania, na przyk³ad rozpakowanie, kompilacja,
instalacja, integracja z systemem i deinstalacja paczek. U¿ywa siê go w
nastêpuj±cy sposób: <c>ebuild ¶cie¿ka/do/paczki.ebuild komenda</c>. Oto dostêpne
komendy:
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Opis</th>
  <th>Spokrewniona funkcja ze skryptów <c>ebuild</c></th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Wykonuje ró¿norakie komendy, których uruchomienie wymagane jest zanim
    rozpocznie siê w³a¶ciwe budowanie.
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Wy¶wietla zale¿no¶ci niezbêdne do zbudowania paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Rozpakowuje, kompiluje, instaluje i integruje paczkê z systemem plików.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Integruje paczkê z systemem plików, zak³adaj±c, ¿e etapy rozpakowania,
    kompilacji i instalacji ju¿ zosta³y wykonane.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Rozpakowuje archiwa z kodem ¼ród³owym w katalogu roboczym.
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Kompiluje paczkê.</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Tworzy pakiet RPM z paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Creates a Gentoo <c>tbz2</c> package</ti>
  <ti>Tworzy pakiet Gentoo w formacie <c>tbz2</c>.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Wykonuje etap przed usuniêciem paczki.</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Wykonuje etap po usuniêciu paczki.</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Wykonuje etap przed zainstalowaniem paczki.</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Wykonuje etap po zainstalowaniu paczki.</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Przygotowuje domy¶ln± konfiguracjê gdy paczka zosta³a zainstalowana w
  systemie plików.</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Uaktualnia czasy modyfikacji ka¿dego archiwum ¼ród³owego paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Czy¶ci katalog roboczy paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Pobiera pliki ze ¼ród³ami paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Tworzy plik digest paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>test</c>*</ti>
  <ti>Uruchamia funkcjê autotestu paczki.</ti>
  <ti><c>src_test</c></ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Instaluje paczkê w katalogu obrazu.</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Usuwa paczkê z systemu plików.</ti>
  <ti>Nie dotyczy</ti>
</tr>
</table>

<note>
Komendy oznaczone gwiazdk± (*) zwykle u¿ywane s± tylko przez deweloperów.
</note>

<p>
Narzêdzie <c>emerge</c> rekursywnie instaluje paczkê i wszystkie jej zale¿no¶ci
w systemie plików. Komenda ta ma wiele opcji, których listê mo¿emy zobaczyæ,
wydaj±c polecenie <c>emerge --help</c>.
</p>

<p>
Narzêdzie <c>env-update</c> uaktualnia pliki konfiguracyjne (w tym
<path>/etc/ld.so.conf</path> i <path>/etc/profile.env</path>), aby uwzglêdnia³y
zmiany wprowadzone przez zainstalowane paczki.
</p>

</body>
</subsection>
<subsection>
<title>Prywatne skrypty i komendy</title>
<body>

<p>
Skryptów tych mo¿emy u¿yæ w naszych skryptach ebuild do wykonywania typowych
zadañ.
</p>

<p>
Je¶li kto¶ lubi grzebaæ w kodzie, mo¿e przyjrzeæ siê poni¿szym skryptom,
zagl±daj±c do katalogu <path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Warto¶æ domy¶lna</th>
  <th>Opis</th>
  <th>Przyk³ad</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Ustawia opcje gdy uruchamiamy skrypt <c>dodir</c>.</ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Instaluje podane pliki binarne w katalogu <path>DESTTREE/bin</path>.</ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Ustawia wzglêdny podkatalog (<e>DOCDESTTREE</e>) dla skryptu <c>dodoc</c>.
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy katalog, automatycznie uwzglêdniaj±c katalog ${D}.</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu z dokumentacj± paczki
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>)  (zob. <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <e>EXEOPTIONS</e> (zob.
    <c>exeopts</c>) w katalogu <path>EXEDESTTREE</path> (zob. <c>exeinto</c>).
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy dowi±zanie twarde, automatycznie uwzglêdniaj±c katalog ${D}.</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki i katalogi w katalogu
    <path>/usr/share/doc/${PF}/html</path>. 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu /usr/share/info, a nastêpnie kompresuje
    je programem gzip.
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <c>INSOPTIONS</c> (zob.
    <c>insopts</c>) w katalogu <path>INSDESTTREE</path> (zob. <c>insinto</c>).
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki w katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki w katalogu <path>/usr/share/man/manX</path> na
    podstawie przyrostka nazwy pliku (plik.1 zostanie zainstalowany w katalogu
    <path>man1</path>).
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje pliki w katalogu <path>DESTTREE/sbin</path>, upewniaj±c siê, ¿e
    uprawnienia zezwalaj± na ich wykonywanie.
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy dowi±zanie symboliczne, automatycznie uwzglêdniaj±c katalog
  ${D}.</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia make z argumentami <c>MAKEOPTS</c>. Niektórych paczek nie mo¿na
    kompilowaæ równolegle; wówczas powinni¶my u¿yæ <c>emake -j1</c>. Je¶li
    musimy przekazaæ jeszcze dodatkowe parametry do make, wystarczy przekazaæ je
    do polecenia emake jako parametry. U¿ytkownicy mog± ustawiæ zmienn±
    ¶rodowiskow± <c>EXTRA_EMAKE</c> aby przekazywaæ dodatkowe flagi poleceniu
    emake.
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Ustawia katalog g³ówny (<e>EXEDESTTREE</e>) dla polecenia
  <c>doexe</c>.</ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>doexe</c>.</ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Nadaje podanemu plikowi podanego w³a¶ciciela poprzez komendê chown,
    automatycznie uwzglêdniaj±c katalog ${D}.
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Nadaje podanemu plikowi podane uprawnienia poprzez komendê chmod,
    automatycznie uwzglêdniaj±c katalog ${D}.    
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Ustawia katalog g³ówny (<e>INSDESTTREE</e>) dla polecenia
  <c>doins</c>.</ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>doins</c>.</ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Ustawia katalog docelowy (<path>DESTTREE</path>) dla wszystkich poleceñ
    zaczynaj±cych siê od 'do' (czyli <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>,
    <c>dolib.so</c>, <c>domo</c>, <c>dosbin</c>).
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Ustawia opcje do uruchomienia polecenia <c>dolib</c>.</ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dobin</c>, instaluj±cy podany plik binarny,
    automatycznie zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dodoc</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doexe</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doins</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doman</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dosbin</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia komendy <c>prepallman</c>, <c>prepallinfo</c> 
    i <c>prepallstrip</c>. Upewnia siê tak¿e, ¿e uprawnienia wszystkich bibliotek
    w katalogach <path>/opt/*/lib</path>, <path>/lib</path>,
    <path>/usr/lib</path> i <path>/usr/X11R6/lib</path> pozwalaj± na ich
    wykonywanie. Dodatkowo przemieszcza wszelkie zb³±kane makra aclocal do
    katalogu <path>/usr/share/aclocal</path>.
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji z katalogu
    <path>/usr/share/doc</path> za pomoc± narzêdzia gzip, automatycznie
    poprawiaj±c wszelkie dowi±zania symboliczne.
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Rekursywnie kompresuje wszystkie pliki dokumentacji info w katalogu
  <path>/usr/share/info</path>.</ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji man w katalogach
    <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>,
    <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path>,
    automatycznie poprawiaj±c wszelkie dowi±zania symboliczne.
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</subsection>
</section>
<section>
<title>Zależności paczki</title>
<subsection>
<title>Dlaczego zale¿no¶ci s± wa¿ne</title>
<body>

<p>
Portage to co¶ wiêcej ni¿ wygodny skrypt pozwalaj±cy w ujednolicony sposób
budowaæ oprogramowanie (program, bibliotekê) ze ¼róde³. Potrafi on tak¿e pobraæ
i zainstalowaæ wszelkie potrzebne zale¿no¶ci, je¶li tylko podamy je w naszym
skrypcie ebuild.
</p>

<p>
W oficjalnych ebuildach wszystkie zale¿no¶ci zosta³y ju¿ okre¶lone, wiêc gdy
wydamy komendê <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage dopilnuje by
wszystkie zale¿no¶ci niezbêdne do zbudowania i uruchomienia Mozilli zosta³y
zainstalowane zanim zacznie kompilowaæ sam± Mozillê.
</p>

<p>
Portage rozró¿nia nawet miêdzy zale¿no¶ciami potrzebnymi do zbudowania i do
uruchomienia (Niestety, w tej chwili Portage jedynie instaluje wszystkie
zale¿no¶ci potrzebne do budowania i uruchomienia. W przysz³o¶ci jednak bêdzie
mo¿liwe automatyczne odchudzenie systemu, aby pozosta³y w nim tylko zale¿no¶ci
potrzebne do uruchamiania programów.
</p>

</body>
</subsection>
<subsection>
<title>Jak definiowaæ zale¿no¶ci w naszych skryptach ebuild (czyli atomy
DEPEND)</title>
<body>

<p>
Zmienna <c>DEPEND</c> w naszym pliku <path>bla-x.y.z.ebuild</path> mówi Portage
jakie paczki s± potrzebne, aby zbudowaæ program <path>bla</path>. Zmienna
<c>RDEPEND</c> okre¶la za¶ jakie paczki s± potrzebne, aby uruchomiæ
<path>bla</path>. Musimy podawaæ zmienn± <c>RDEPEND</c> jedynie wtedy, gdy
zale¿no¶ci potrzebne do uruchomienia ró¿ni± siê od tych podanych w zmiennej
<c>DEPEND</c>; je¶li zmienna <c>RDEPEND</c> nie zostanie okre¶lona, przyjmie ona
domy¶lnie warto¶æ zmiennej <c>DEPEND</c>. <b>Nigdy</c> nie nale¿y samemu
przypisywaæ zmiennej <c>RDEPEND</c> warto¶ci zmiennej <c>DEPEND</c>.
</p>

<pre caption="Przyk³ad zale¿no¶ci">
DEPEND="virtual/libc
        sys-libs/zlib"
RDEPEND="virtual/libc"
</pre>

<p>
Ten przyk³ad informuje Portage o fakcie, ¿e aby zbudowaæ paczkê
<path>bla-x.y.z</path> potrzebne bêd± paczki <path>virtual/libc</path> (wiêcej o
kategoriach wirtualnych wkrótce) i <path>sys-libs/zlib</path>. Nie jest podane
jakie wersje glibc i zlib s± potrzebne, co oznacza, ¿e dobre bêd± wszystkie.
</p>

<p>
Rzecz jasna, "dobre bêd± wszystkie" w wiêkszo¶ci wypadków nie wystarczy.
Jedynie w przypadku g³ównych bibliotek takich jak glibc jest to
wystarczaj±ce, poniewa¿ jego autorzy bardzo siê staraj± aby by³ on zawsze w stu
procentach binarnie kompatybilny. W przypadku innych bibliotek mo¿emy oczywi¶cie
podaæ wersje zale¿no¶ci.
</p>

<pre caption="Przyk³ad wersji">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
Znaki &gt;= i = oznaczaj± to, czego mo¿emy siê po nich spodziewaæ; wersja 1.2
lub nowsza programu sys-apps/bar bêdzie siê nadawaæ (oznacza to, ¿e równie¿ 
wersja 2.0 sys-apps/bar te¿ bêdzie odpowiednia), za¶ wersja 1.0 programu
sys-apps/baz bêdzie jedyn± odpowiedni±. Wiêcej informacji na temat wzorca wersji
paczek mo¿na znale¼æ wy¿ej w rozdziale <uri link="#doc_chap2_sect2">Nazewnictwo plików ebuild</uri>.
</p>

<p>
Oto inne sposoby na podawanie wersji zale¿no¶ci:
</p>

<pre caption="Podawanie wersji zale¿no¶ci">
~sys-apps/qux-1.0
=sys-apps/bla-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 wybierze najnowsz± rewizjê programu qux-1.0 w Portage.
</p>

<p>
=sys-apps/bla-1.2* wybierze najnowsze wersje spo¶ród ga³êzi 1.2, ale zignoruje
1.3 i wcze¶niejsze/pó¼niejsze ga³êzie. Tak wiêc bla-1.2.3 i bla-1.2.0 bêd±
odpowiednie, za¶ bla-1.3.3, bla-1.3.0 i bla-1.1.0 ju¿ nie.
</p>

<p>
!sys-libs/gdbm uniemo¿liwi instalacjê tej paczki je¶li gdbm jest zainstalowane.
</p>

</body>
</subsection>

<subsection>
<title>Wa¿ne uwagi</title>
<body>

<p>
Przy konfiguracji zmiennych DEPEND i RDEPEND mo¿na pope³niæ wiele b³êdów. Oto
kilka porad, dziêki którym mo¿emy ich unikn±æ.
</p>

<ul>
  <li>
    <e>Zawsze nale¿y podaæ kategoriê.</e><br />
    Na przyk³ad powinni¶my napisaæ <c>&gt;=x11-libs/gtk+-2</c> zamiast tylko
    <c>&gt;=gtk+-2</c>.
  </li>
  <li>
    <e>Nie powinni¶my stawiaæ znaku gwiazdki (*) przy zale¿no¶ciach typu 
    &gt;=.</e><br />
    Prawid³owo powinni¶my napisaæ <c>&gt;=x11-libs/gtk+-2</c> zamiast
    <c>&gt;=x11-libs/gtk+-2*</c>.
  </li>
  <li>
    <e>Nie wolno definiowaæ meta-paczki jako zale¿no¶ci.</e><br />
    Nie powinni¶my wiêc okre¶liæ zale¿no¶ci od gnome-base/gnome, zamiast tego
    u¿yjmy konkretnej biblioteki, na przyk³ad libgnome.
  </li>
  <li>
    <e>Podajemy jedn± zale¿no¶æ na liniê.</e><br />
    Definiowanie wiêcej ni¿ jednej zale¿no¶ci w jednej linii sprawia, ¿e kod
    jest brzydki i trudny do zrozumienia.
  </li>
  <li>
    <e>GTK: Zawsze nale¿y u¿yæ zale¿no¶ci =x11-libs/gtk+-1.2* przy aplikacjach
    GTK+1.</e>
  </li>
</ul>

<p>
Ponadto powinni¶my siê upewniæ, ¿e podali¶my wszystkie zale¿no¶ci naszej paczki:
</p>

<ul>
  <li>
    <e>Zajrzyjmy do plików configure.in lub configure.ac</e><br />
    Poszukajmy w nich sprawdzania obecno¶ci paczek. Warto zwróciæ uwagê na
    sprawdzenia pkg-config lub funkcje AM_*, które szukaj± konkretnej wersji.
  </li>
  <li>
    <e>Mo¿emy przyjrzeæ siê do³±czonym plikom .spec</e><br />
    Zwykle do³±czone pliki .spec mog± byæ ¼ród³em informacji o zale¿no¶ciach.
    Nie nale¿y jednak traktowaæ ich jako jedynego ¼ród³a.
  </li>
  <li>
    <e>Poszukajmy strony internetowej aplikacji/biblioteki</e><br />
    Autor czêsto sugeruje na oficjalnej stronie jakich zale¿no¶ci wymaga jego
    program.
  </li>
  <li>
    <e>Warto przeczytaæ pliki README i INSTALL do³±czone do paczki</e><br />
    Zwykle zawieraj± one informacje przydatne przy budowaniu i instalowaniu
    paczek.
  </li>
  <li>
    <e>Nale¿y pamiêtaæ o zale¿no¶ciach innych ni¿ binarne, takie jak pkg-config,
    programy do generacji dokumentacji, itd.</e><br />
    Proces budowania zwykle wymaga zale¿no¶ci takich jak intltool, libtool,
    pkg-config, doxygen, scrollkeeper, gtk-doc itp. Upewnijmy siê, ¿e zosta³y
    one podane.
  </li>
</ul>

<p>
Aby zapoznaæ siê z najnowszymi informacjami o atomach DEPEND, nale¿y przeczytaæ
5 sekcjê dokumentacji systemowej man: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Testowanie i wdro¿enie</title>
<subsection>
<title>Plik ChangeLog</title>
<body>

<p>
Za ka¿dym razem gdy uaktualniamy (lub piszemy nowy) skrypt ebuild, musimy tak¿e
uaktualniæ (lub utworzyæ) jego Changelog. Plik <path>skel.ChangeLog</path>
zawiera przyk³adow± tre¶æ i mo¿e zostaæ potraktowany jako wzór.
</p>

<p>
Funkcj± pliku Changelog jest udokumentowanie <e>co</e> zosta³o zrobione,
<e>czemu</e> zosta³o to zrobione i <e>kto</e> tego dokona³. Dziêki temu zarówno
deweloperzy jak i u¿ytkownicy mog± w ³atwy sposób prze¶ledziæ zmiany.
</p>

<p>
Changelog jest g³ównie przeznaczony dla u¿ytkowników, nale¿y wiêc pisaæ krótko,
na temat i unikaæ zbêdnych technicznych szczegó³ów.
</p>

</body>
</subsection>

<subsection>
<title>Przechowywanie plików ebuild lokalnie</title>
<body>

<p>
Aby mo¿liwe by³o testowanie skryptów ebuild oraz poinformowanie Portage o ich
istnieniu, musimy umie¶ciæ je w okre¶lonym katalogu. Portage u¿ywa w tym celu
zmiennej <c>PORTDIR_OVERLAY</c>, definiowanej przez u¿ytkownika w pliku
<path>/etc/make.conf</path>. Powinni¶my u¿yæ tej zmiennej aby podaæ katalog, w
którym bêdziemy trzymaæ nasze ebuildy (mo¿e to byæ na przyk³ad
<path>/usr/local/portage</path>).
</p>

<p>
W katalogu tym nale¿y u¿ywaæ tej samej struktury (i tych samych kategorii) co w
katalogu <path>/usr/portage</path>.
</p>

<p>
Gdy u¿ywamy <c>PORTDIR_OVERLAY</c> nasze ebuildy pozostan± w systemie i bêd±
wci±¿ rozpoznawane przez Portage nawet gdy wykonamy polecenie <c>emerge sync</c>.
</p>

</body>
</subsection>

<subsection>
<title>Testowanie paczki</title>
<body>

<p>
Zastanówmy siê w jaki sposób przetestowaæ czy nasza paczka dzia³a. Czasem
deweloperzy od razu do³±czyli polecenia <c>make test</c> lub
<c>make check</c>, które sprawdz± podstawowe funkcje paczki. Je¶li tak, to
uruchomienie <c>env FEATURES=maketest ebuild <path>bla-x.y.z.ebuild</path>
test</c> wykona je. Je¶li polecenia te nie dzia³aj± poprawnie, spróbujmy je
naprawiæ (i wys³aæ ³atki autorom programu). 
</p>

<p>
Je¶li takich poleceñ nie ma, nale¿y rozwa¿yæ dodanie funkcji <c>src_test</c>  do
naszego skryptu ebuild. Jest ona wykonywana przed funkcj± <c>src_install</c> i
mo¿e byæ bardzo pomocna przy testowaniu dzia³ania programu na ró¿nych
architekturach. Deweloperzy innych architektur bêd± nam wdziêczni je¶li dodamy
tê funkcjê, dziêki czemu nie bêd± musieli zag³êbiaæ siê w funkcjonowanie paczki.
</p>

<p>
Nale¿y jednak pamiêtaæ o ogólnej zasadzie dzia³ania plików ebuild. Funkcja
<c>src_test</c> nie mo¿e byæ interaktywna. Je¶li wymaga ona innych paczek,
nale¿y u¿yæ flagi USE <c>maketest</c> w celu podania dodatkowych zale¿no¶ci
kompilacji w zmiennej <c>DEPEND</c>. We¼my te¿ pod uwagê, ¿e funkcje
<c>src_test</c> nie s± zalecane przy graficznych aplikacjach korzystaj±cych z X,
poniewa¿ u¿ytkownik korzystaj±cy z Portage niekoniecznie bêdzie mia³ mo¿liwo¶æ
uruchomienia ich.
</p>

</body>
</subsection>

<subsection>
<title>Przydatne narzêdzia testuj±ce</title>
<body>

<p>
Istnieje kilka przydatnych narzêdzi, które pomog± nam w pisaniu i opiekowaniu
siê naszymi ebuildami.
</p>

<table>
<tr>
  <th>Narzêdzie</th>
  <th>Paczka</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Narzêdzie tylko dla deweloperów, wspomagaj±ce funkcjê checkin z CVS.
    Wykonuje ona wiele typowych zadañ QA (zapewniania jako¶ci) i upewnia siê, ¿e
    dodawane do CVS pliki nie uszkodz± drzewa Portage.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Narzêdzie to zachowuje przetworzone pliki robocze, aby <e>znacznie</e>
    przyspieszyæ kompilacjê. Pamiêtajmy aby dodaæ <c>ccache</c> do zmiennej
    <c>FEATURES</c> w pliku <path>/etc/make.conf</path>!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Uruchamia pow³okê, która tworzy ¶rodowisko sandbox. Przydatne je¶li chcemy
    dostaæ siê do tego samego ¶rodowiska, w którym Portage buduje paczki, a
    tak¿e je¶li chcemy co¶ rêcznie debugowaæ.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>Mo¿e utworzyæ nowy plik Changelog lub dodaæ wpis do ju¿ istniej±cego pliku.</ti>
</tr>
</table>

</body>
</subsection>
</section>
</sections>
