<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/gentoo-howto.xml :: R1.50.
-->

<sections>

<date>2005-07-02</date>

<section>
<title>Drzewo Portage</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Drzewo Portage zwykle znajduje się w katalogu <path>/usr/portage</path> i jest
ułożone w hierarchicznej strukturze, składającej się z katalogów kategorii, w
których znajdują się katalogi paczek. Oto przykład: plik 
<path>util-linux-2.11y.ebuild</path> można znaleźć w katalogu 
<path>/usr/portage/sys-apps/util-linux</path>. W tym samym katalogu może
znajdować się kilka innych wersji <c>util-linux</c> razem z wersją 
<path>util-linux-2.11y.ebuild</path>. Jest tak ponieważ <e>wszystkie pliki
ebuild danej paczki (niezależnie od wersji)</e> mają wspólny katalog 
<path>kategoria/paczka</path> w głównym katalogu <path>/usr/portage</path>.
</p>

</body>
</subsection>

<subsection>
<title>Pobieranie drzewa Portage z CVS</title>
<body>

<p>
W razie jakichkolwiek wątpliwości co do systemu CVS, należy przeczytać <uri 
link="http://www.gentoo.org/doc/en/cvs-tutorial.xml">Samouczek CVS</uri>, gdzie
znajdziemy więcej informacji.
</p>

<p>
Drzewo Portage można znaleźć w module <c>gentoo-x86</c> drzewa systemu Gentoo
Linux. Aby pobrać moduł (około 350 megabajtów) najpierw należy skonfigurować CVS
za pomocą powyższego samouczka, a następnie pobrać moduł <c>gentoo-x86</c>
komendą checkout.
</p>

</body>
</subsection>

<subsection>
<title>Co umieszczać (a czego nie) w drzewie Portage</title>
<body>

<p>
Przed napisaniem jakiegokolwiek ebuilda powinniśmy przejrzeć <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> w poszukiwaniu
niezamieszczonego jeszcze w drzewie Portage pliku ebuild do paczki, do której
sami chcieliśmy go pisać. W tym celu należy wejść na stronę <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri>, wybrać "query", jako
produkt (product) wybrać <e>Gentoo Linux</e>, jako składnik (component)
<e>ebuilds</e>. W polu tekstowym powinniśmy wpisać nazwę ebuilda, a jako status
wybrać "NEW", "ASSIGNED", "REOPENED" i "RESOLVED" (to ostatnie jest ważne), a
następnie zatwierdzić zapytanie. Leniwi niech po prostu klikną <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">tutaj</uri>.
</p>

<p>
Drzewo Portage powinno przede wszytkim być używane do przechowywania plików
<path>.ebuild</path>, a także wszelkich względnie małych plików
pomocniczych, takich jak łatki lub przykładowe pliki konfiguracyjne. Pliki
pomocniczne powinny być umieszczane w katalogu
<path>/usr/portage/kategoria/paczka/files</path>, aby nie zaśmiecać głównego
katalogu <path>kategoria/paczka</path>. Wyjątkiem od tej reguły są większe 
pliki łatek (zalecamy przyjąć granicę przy 20KB), które powinny zostać
umieszczone na serwerach lustrzanych Gentoo, aby użytkownicy nie marnowali
przepustowości ani przestrzeni dyskowej. Odradzamy też deweloperom umieszczanie
w CVS plików binarnych (nie-ASCII). Jeśli jednak jest to konieczne (gdybyśmy na
przykład chcieli zamieścić niewielki plik graficzny PNG), należy dodać go do CVS
przy użyciu opcji <c>-kb</c>, tak jak poniżej:
</p>

<pre caption="Dodawanie pliku binarnego do CVS">
# <i>cvs add -kb mojobrazek.png</i>
</pre>

<p>
Opcja <c>-kb</c> instruuje CVS, iż plik <path>mojobrazek.png</path> to plik
binarny i powinien być specjalnie traktowany. Nie powinno się na przykład z
oczywistych względów pozwolić na łączenie różnic między dwiema wersjami tego
pliku. Skoro już mowa o łączeniu zmian, pliki poprawek zamieszczane w Portage
nie powinny być kompresowane. Dzięki temu system CVS będzie mógł łączyć zmiany i
poprawnie informować deweloperów o konfliktach.
</p>

<p>
Należy pamiętać, iż paczki, które FIXME (zatwierdzamy?) wrzucamy muszą być
<e>gotowe</e> do <e>natychmiastowego użycia</e> przez końcowych użytkowników,
jeśli zgłaszamy je jako stabilne. Musimy upewnić się, że posiadamy dobry zestaw
domyślnych ustawień, który zadowoli większość systemów i użytkowników naszej
paczki. Jeśli zaś nasza paczka nie działa i nie mamy pomysłu jak sprawić, by
działała, warto zajrzeć jak poradzili sobie z nią deweloperzy innych
dystrybucji. Przykładów możemy szukać choćby w repozytoriach <uri
link="http://cvs.mandriva.com/cgi-bin/cvsweb.cgi/SPECS/">Mandrivy</uri>, <uri
link="http://www.debian.org/distrib/packages">Debiana</uri> lub <uri
link="http://cvs.fedora.redhat.com/">Fedory</uri>.
</p>

<p>
FIXME (zatwierdzając?) Zamieszczając pliki ebuild w CVS wszyscy deweloperzy
powinni używać polecenia <c>repoman commit</c> zamiast <c>cvs commit</c>. Przed
samym zamieszczeniem należy wykonać polecenie <c>repoman full</c>, aby upewnić
się, że o niczym nie zapominamy.
</p>

</body>
</subsection>

<subsection>
<title>Polityka FIXME (zatwierdzania [commit]?) zamieszczania w CVS</title>
<body>

<ul>
<li>Zawsze należy wykonać polecenie <c>repoman scan</c> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze należy wykonać polecenie <c>repoman full</c> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze powinniśmy sprawdzić poprawność pliku <path>package.mask</path> przez
wykonanie <c>emerge --pretend mypkg</c> przed zatwierdzeniem i sprawdzenie czy
nie zawiera konfliktów.</li>
<li>Zawsze należy uaktualnić plik <path>ChangeLog</path> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze powinniśmy zatwierdzić uaktualniony plik <path>package.mask</path>
przed uaktualnioną paczką, w razie gdyby wystąpiły konflikty podczas
zatwierdzania pliku <path>package.mask</path>.</li>
<li>Zawsze powinniśmy wykonywać zatwierdzenia atomowe; jeśli zatwierdzamy paczkę
z nową licencją albo taką, która jest zamaskowana, najpierw należy zatwierdzić
uaktualniony plik <path>package.mask</path> i/lub licencję, następnie plik
ebuild, <path>ChangeLog</path>, łatki i plik <uri
link="?part=2&amp;chap=4">metadata.xml</uri> wszystkie za jednym razem, aby
uniknąć uszkodzenia użytkownikom systemów.
</ul>

</body>
</subsection>

<subsection>
<title>Katalog files</title>
<body>

<p>
Jak wpomniano wcześniej, w każdym podkatalogu paczki znajduje się podkatalog
<path>files/</path>. W nim należy umieszczać wszelkie łatki, pliki
konfiguracyjne lub inne pliki pomocnicze; pliki większe niż około 20KB powinny
być zamieszczane na serwerach lustrzanych, aby zmniejszyć ilość (niepotrzebnych)
plików, które nasi użytkownicy będą musieli ściągnąć. Warto rozważyć nazywanie
tworzonych przez siebie poprawek, dzięki którym paczka w ogóle się zbuduje,
uwzględniając wersję w nazwie, na przykład <path>paczka-1.0-gentoo.diff</path>,
or more simply, <path>1.0-gentoo.diff</path>. Przy okazji człon
<path>gentoo</path> informuje że poprawka ta została stworzona przez nas,
deweloperów Gentoo, a nie pobrana z listy dyskusyjnej albo innego miejsca. Raz
jeszcze, nie należy kompresować tych plików, ponieważ CVS nie radzi sobie zbyt
dobrze z binarnymi plikami.
</p>

<p>
Warto rozważyć dodawanie przedrostka lub przyrostka (na przykład
<path>mypkg-1.0</path>) do wszystkich plików, które umieszczamy w katalogu
<path>files/</path>, aby pliki wykorzystywane z konkretną wersją ebuilda można
było łatwo odróżnić od siebie, co powoduje też widoczność zmian pomiędzy każdą
poprawką. Ogólnie jest to dobry pomysł. :) Możemy użyć innego przyrostka, jeśli
chcemy, aby nazwa pliku łatki przekazywała więcej informacji.
</p>

<p>
Jeśli w katalogu <path>files/</path> chcemy umieścić więcej plików, warto
stworzyć podkatalogi, na przykład <path>files/1.0/</path> i umieszczać
odpowiednie pliki w swoich własnych katalogach. Gdy używamy tej metody, nie jest
już konieczne dodawanie informacji o wersji do nazw plików. Często jest to
więc bardziej wygodne.
</p>

</body>
</subsection>
</section>

<section>
<title>Skrypty ebuild</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Skrypty ebuild są podstawą całego systemu portage. Zawierają one wszelkie
informacje potrzebne do pobrania, rozpakowania, skompilowania i instalacji
zestawu źródeł, a także wykonania ewentualnych czynności poprzedzających i/lub
następujących po instalacji i/lub deinstalacji. Pomimo iż większość Portage
napisana jest w języku Python, same skrypty ebuild napisane są w bashu, ponieważ
wykorzystanie języka skryptowego powłoki pozwala nam na wykonywanie komend tak
samo jak z wiersza poleceń. Jednym z najważniejszych założeń projektowych
skryptów ebuild jest nazwanie zawartych w nim poleceń analogicznie do tych,
które wypisywalibyśmy, instalując paczkę ręcznie poprzez wiersz poleceń. Również
z tego względu użycie składni basha jest bardzo wskazane.
</p>

<p>
Skrypty ebuild są interpretowane przez komendy <c>ebuild</c> i <c>emerge</c>.
Wyobraźmy sobie polecenie <c>ebuild</c> jako niskopoziomowe narzędzie, służące
do budowania. Potrafi zbudować i zainstalować pojedynczy ebuild, ale nic poza
tym. Sprawdzi czy zależności są spełnione, ale nie będzie próbować ich
automatycznie spełnić. Z drugiej strony polecenie <c>emerge</c> jest
wysokopoziomowym "silnikiem" dla polecenia <c>ebuild</c> i potrafi w razie
potrzeby automatycznie zainstalować zależności, wykonać instalacje symulowane
<e>pretend</e>, aby użytkownik mógł dowiedzieć się jakie paczki zostaną
zainstalowane i dużo więcej. Ogólnie polecenie <c>emerge</c> jest lepsze od
<c>ebuild</c> pod każdym względem oprócz jednego. Za pomocą <c>ebuild</c> możemy
stopniowo i pojedynczo wykonywać poszczególne fazy instalacji paczki (pobieranie
źródeł, rozpakowanie, kompilacja, instalacja i osadzenie paczki w systemie).
Jest to nieocenione narzędzie do debugowania dla deweloperów, ponieważ umożliwia
zawężenie problemu z ebuildem do konkretnego fragmentu pliku ebuild.
</p>

</body>
</subsection>
<subsection>
<title>Nazewnictwo plików ebuild</title>
<body>

<p>Nazwa pliku ebuild składa się z czterech logicznych podsekcji:</p>

<p><c>pkg-ver{_suf{#}}{-r#}.ebuild</c></p>

<note>
FIXME "Wąsy" (<c>{}</c>) otaczają opcjonalne pola i same nie występują w nazwie
paczki. Znak "<c>#</c> oznacza dowolną dodatnią liczbę różną od zera.
</note>

<p>
Pierwsza podsekcja, <c>pkg</c> oznacza nazwę paczki. Powinna ona zawierać
jedynie małe litery, cyfry od 0 do 9 oraz dowolną liczbę pojedynczych znaków
myślnika (<c>-</c>), podkreślenia (<c>_</c>) lub znaku plus (<c>+</c>).
Przykłady: <c>util-linux</c>, <c>sysklogd</c> i <c>gtk+</c>. W Portage można
znaleźć kilka paczek, które nie spełniają tych wymogów, ale FIXME (lepiej:
nowe?) <e>nasze</e> paczki muszą je spełniać.
</p>

<p>
Druga podsekcja, <c>ver</c> oznacza wersję paczki, która zwykle powinna
odpowiadać wersji głównego archiwum ze źródłami. Najczęściej wersja składa się z
dwóch lub trzech (czasem więcej) liczb oddzielonych kropkami, na przykład w ten
sposób: <c>1.2</c> lub <c>4.5.2</c>. Czasem bezpośrednio za ostatnią liczbą może
pojawić się pojedyncza litera, na przykład <c>1.4b</c> lub <c>2.6h</c>. Wersja
paczki połączona jest myślnikiem z nazwą paczki. Przykładowo: <c>coś-1.0</c>,
<c>bla-2.4.6</c>.
</p>

<impo>
Chcąc użyć litery poprzedzającej numer wersji należy mieć na uwadze, że <e>nie
powinna</e> ona oznaczać statusu alpha lub beta paczki, ponieważ alpha i beta to
<e>wersje zapoznawcze</e> (ang. prerelease), natomiast wersje z literą na
początku to <e>nowsze wersje</e>. To istotne rozróżnienie, ponieważ Portage
używa numeru wersji ebuilda do określenia czy jest on nowszy czy starszy od
pozostałych paczek o tej samej nazwie w tej samej kategorii. Jest więc bardzo
ważne, aby numery wersji wiernie odzwierciedlały wersję paczki i Portage
właściwie wykonywał sprawdzanie zależności.
</impo>

<p>
Trzecia podsekcja, <c>{_suf{#}}</c> jest opcjonalna i może zawierać jeden z
następujących przyrostków, wymienionych w kolejności od oznaczających najstarsze
wydanie po najnowsze:
</p>

<table>
 <tr><th>Przyrostek</th><th>Znaczenie</th></tr>
 <tr><ti><c>_alpha</c></ti><ti>Wydanie alpha</ti></tr>
 <tr><ti><c>_beta</c></ti><ti>Wydanie beta</ti></tr>
 <tr><ti><c>_pre</c></ti><ti>Wersja zapoznawcza (prerelase)</ti></tr>
 <tr><ti><c>_rc</c></ti><ti>FIXME Testowe wydanie finalne (Release candidate)</ti></tr>
 <tr><ti>(none)</ti><ti>Oficjalne wydanie</ti></tr>
 <tr><ti><c>_p</c></ti><ti>FIXME (patch level) Etap poprawek (zwykle za
 przyrostkiem występuje liczba całkowita)</ti></tr>
</table>

<p> 
Po każdym z tych przyrostków może zostać dodana dodatnia liczba całkowita różna
od zera, na przykład <c>linux-2.4.0_pre10</c>. Zakładając identyczne wersje,
przyrostki są ułożone następująco (niższy oznacza starszy): <c>_alpha</c> &lt;
<c>_beta</c> &lt; <c>_pre</c> &lt; <c>_rc</c> &lt; (brak przyrostka) &lt;
<c>_p</c>.
</p>
       
<p>
Podczas porównywania liczb poprzedzonych identycznymi przyrostkami za nowszą
zostanie uznana większa liczba całkowita. Przykład: <c>bla-1.0_alpha4</c>
jest nowsza niż <c>bla-1.0_alpha3</c>.
</p>

<p>
Czwarta podsekcja nazwy paczki oznacza wewnętrzny numer rewizji 
specyficznej dla systemu Gentoo Linux. Jest on opcjonalny, podobnie jak
przyrostek. Znak <c>#</c> jest dodatnią liczbą całkowitą różną od zera, na
przykład <c>paczka-4.5.3-r3</c>.
</p>

<p>
Numer rewizji jest niezależny od wersji archiwum źródłowego i informuje, iż
dostępna jest nowa i poprawiona wersja danej paczki, specyficzna dla systemu
Gentoo Linux. Pierwsze wydania paczek nie mają numeru rewizji, co oznacza, że
paczkę <c>package-4.5.3</c> Portage potraktuje jak mającą zerowy numer rewizji.
Oznacza to, że paczki zliczane będą w następującej kolejności: <c>1.0</c> (wersja
początkowa), <c>1.0-r1</c>, <c>1.0-r2</c>, itd. 
</p>

<p>
Dokonując niebanalnych zmian w istniejącym pliku ebuild powinniśmy skopiować go
do nowego pliku z numerem rewizji zwiększonym o 1. Należy pamiętać, aby zawsze
odnotowywać zmiany <e>zarówno</e> w pliku <path>ChangeLog</path>, jak i w komunikacie
zatwierdzenia; pominięcie choć jednego jest wbrew FIXME (policy) regułom.
</p>

<p>
...w zasadzie to mamy też <e>piątą</e> sekcję nazwy pliku ebuild -- samo
rozszerzenie <c>.ebuild</c>.
</p>

</body>
</subsection>
<subsection>
<title>Zawartość pliku ebuild</title>
<body>

<p>
W tej części zajmiemy się wprowadzeniem do plików ebuild. Aby zobaczyć listę
wszystkiego, co można w nich zrobić, warto przeczytać stronę podręcznika
systemowego man, gdzie są informacje na temat formatu skryptów ebuild, ich
zmiennych i funkcji: <c>man 5 ebuild</c>.
</p>

<p><b>Nagłówki</b></p>

<p>
Nagłówek FIXME submitowanego pliku ebuild powinien być <e>dokładnie</e> taki sam
jak ten w pliku <path>/usr/portage/header.txt</path>. Nie należy modyfikować go
w żaden sposób, a przede wszytkim upewnić się, że linia zawierająca napis
<c>&#36;Header: &#36;</c> jest nienaruszona.
</p>

<p>
Pierwsze trzy linie powinny wyglądać mniej-więcej tak:
</p>

<pre caption="Poprawny nagłówek">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# &#36;Header: &#36;
</pre>

<p><b>Zmienne</b></p>

<p>
Pierwsza część każdego pliku ebuild składa się z kilku zmiennych. Dzielą się one
na trzy kategorie wymienione poniżej:
</p>

<ul>
<li>READ: zmiennych tych możemy użyć, ale <e>nie wolno</e> ich ustawiać</li>
<li>MUST: zmienne, które <e>koniecznie należy ustawić</e></li>
<li>OPT: zmienne, które powinniśmy ustawić</li>
</ul>

<table>
<tr>
  <th>Zmienna</th>
  <th>FIXME (Usage) Kateogira</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Nazwa i wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Nazwa paczki.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>Wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer rewizji lub <c>r0</c>, jeśli numeru tego nie ma.</ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer wersji razem z numerem rewizji.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Zawiera pełną nazwę paczki <c>${PN}-${PVR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Rozdzielona spacjami lista nazw plików z <c>SRC_URI</c>. Nie uwzględnia
    ścieżek URL, tylko same nazwy plików.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do katalogu <path>distfiles</path>, w którym zwykle są
    przechowywane wszystkie pobrane pliki paczek. Zwykle jest to ścieżka
    <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
  Zawiera ścieżkę do podkatalogu <path>files</path> z katalogu danej paczki w
  drzewie portage. Nie wolno modyfikować tej zmiennej.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny katalogu roboczego danego ebuilda. Nic nie powinno być
    budowane na zewnątrz tego katalogu.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Katalog źródłowy naszej paczki; zwykle jest to <c>${WORKDIR}/${P}</c>.
    Portage przyjmie tę wartość jako domyślną, nie trzeba jej więc ustawiać
    samemu.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog tymczasowy na naszą paczkę. Jest on używany jako wirtualny katalog
    <path>/tmp</path> podczas przetwarzania skryptu ebuild.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny, do którego paczka zostanie zainstalowana. Należy traktować
    go jako wirtualny katalog <path>/</path>.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage obsługuje instalowanie jednocześnie różnych wersji tego samego
    programu. Na przykład jeśli chcielibyśmy zainstalować jednocześnie GCC 2.95
    i GCC 3.2, należałoby ustawić zmienną <c>SLOT</c> w każdym pliku ebuild. W
    tym przypadku dla GCC 2.95 ustawilibyśmy zmienną <c>SLOT</c> na <c>2</c>, a
    dla GCC 3.2 na <c>3</c>.
    <br/>
    <b>Uwaga</b>: Podanie <c>0</c> jako wartość zmiennej <c>SLOT</c> oznacza, że
    dana paczka ma tylko jedno możliwe ustawienie <c>SLOT</c> (innymi słowy, nie
    da się jej "SLOTować").
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta określa jaką licencją objęty jest program, na przykład GPL-2,
    BSD, itp... Zawartością tej zmiennej musi być poprawna licencja (jest nią
    dowolna licencja z pliku <path>/usr/portage/license/</path>). Jesli danej
    licencji nie ma w tym pliku, musi zostać tam dodana zanim plik ebuild będzie
    mógł być dodany do drzewa portage. Jeśli licencja nie zezwala na
    redystrybucję programu, należy dodać <c>RESTRICT</c>="nomirror" do pliku
    ebuild.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta pełni teraz kilka funkcji. Przede wszystkim określa na jakie
    architektury sprzętowe przeznaczony jest dany ebuild. Przykładowe wartości
    to: <e>x86, ppc, sparc, mips, alpha, arm, hppa, amd64 and ia64</e>. Więcej
    szczegółów można znaleźć w pliku profiles/arch.list. Jak nietrudno się
    domyślić, zmienną tę ustawiamy zgodnie z architekturą docelowej maszyny.
    Portage nie zezwoli maszynie x86 budować paczek innych niż x86, zgodnie z
    tym, co jest podane w zmiennej <c>KEYWORDS</c>. Paczki, które nie wspierają
    FIXME natywnej architektury są automatycznie maskowane przez Portage. Jeśli
    flaga <c>KEYWORDS</c> posiada przedrostek <e>~</e>, oznacza to, że dany
    ebuild działa, ale powinien zostać przetestowany w kilku środowiskach, zanim
    może zostać uznany za stabilny. Jeśli zaś przed flagą <c>KEYWORDS</c>
    występuje znak <e>-</e>, dana paczka nie będzie działać z tym konkretnym
    oznaczeniem. Paczka jest uznawana za stabilną, jeśli nic nie poprzedza
    zmiennych zawartych w <c>KEYWORDS</c>. Ustawiając odpowiednio zmienną
    <c>ACCEPT_KEYWORDS</c> w pliku <path>make.conf</path> definiujemy jakim
    z powyższych typów paczek zezwalamy na instalację.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti><e>Krótki</e>, mieszczący się w jednej linii opis paczki.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    URL-e każdego pliku ze źródłami paczki, rozdzielone białym znakiem. W
    zmiennych SRC_URI i S nie powinno się umieszczać numerów wersji. Powinniśmy
    zawsze stosować zmienne ${PV} lub ${P}, a jeśli numer wersji nie pokrywa się z nazwą
    pliku zawierającego źródła, należy stworzyć zmienną ${MY_P} i użyć jej
    zamiast dwóch poprzednich.
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    Strona domowa paczki. Jeśli nie możemy znaleźć oficjalnej strony, można
    podać odnośnik z <uri link="http://freshmeat.net/">freshmeat.net</uri>, lub
    podobnej strony z bazą danych programów. Nigdy nie należy odnosić się do
    innej zmiennej wewnątrz tej; musi ona zawierać tylko czysty tekst.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    W zmiennej tej zamieszczamy zmienne <c>USE</c>, z jakich korzysta nasza
    paczka. Należy pamiętać, że nie wolno tutaj umieścić <c>KEYWORDS</c>!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do zbudowania paczki. Więcej
    informacji na temat składni znajdziemy w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do uruchomienia programu z paczki. Jak
    wspomnnieliśmy wyżej, więcej szczegółów można znaleźć w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
</table>

<p><b>Funkcje</b></p>

<p>
W plikach ebuild można zdefiniować wiele różnych funkcji, które kontrolują
proces budowania i instalacji naszej paczki.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Funkcja ta służy do wykonywania wszelkich wstępnych czynności. Może to
    obejmować sprawdzenie czy istnieje już plik konfiguracyjny. Jeśli w tym
    miejscu konieczne jest dodanie użytkowników, należy również sprawdzić to 
    w funkcji <c>pkg_preinst()</c> zanim paczka zostanie zainstalowana.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    W tym miejscu informujemy użytkownika o tym, co musi zrobić, jeśli z
    jakiegoś powodu (na przykład licencji) źródła nie mogą zostać automatycznie
    pobrane przez Portage. Jednocześnie należy ustawić zmienną
    <c>RESTRICT=&quot;fetch&quot;</c>. W niniejszej funkcji wolno jedynie
    wyświetlać komunikaty, nie należy wywoływać FIXME polecenia <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Tej funkcji należy użyć, aby rozpakować źródła naszej paczki, nałożyć
    poprawki i uruchomić zewnętrzne programy, na przykład autotools. Domyślnie
    funkcja ta rozpakuje pliki wymienione w zmiennej <c>A</c>. Początkowy
    katalog roboczy definiuje zmienna <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Za pomocą tej funkcji konfigurujemy i budujemy paczkę. Początkowy
    katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Tej funkcji użyjemy, aby zainstalować paczkę w katalogu określonym przez
    zmienną <c>D</c>. Jesli nasza paczka korzysta z automake, możemy tego łatwo
    dokonać poprzez <c>make DESTDIR=${D} install</c>. <e>Należy upewnić się, że
    paczka wszystkie swoje pliki zainstaluje używając <c>D</c> jako katalogu
    głównego!</e> Początkowy katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_test</c></ti>
  <ti>
    Funkcja ta jest wykonywana tylko wtedy, gdy zmienna
    <c>FEATURES="maketest"</c> jest ustawiona, a zmienna
    <c>RESTRICT="maketest"</c> nie jest ustawiona. Domyślnie wywołuje 
    dostępną funkcję testującą z plików Makefile, znajdujących się w
    katalogu zdefiniowanym przez zmienną <c>${S}</c>, uruchamiając albo "make
    test" albo "make check", w zależności od tego, co jest dostępne. Funkcję tę
    można nadpisać i zaimplementować własną metodę testowania paczki.
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed
    zintegrowaniem</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po
    zintegrowaniu</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed 
    odinstalowaniem</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po 
    odinstalowaniu</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Za pomocą tej funkcji możemy przygotować początkową konfigurację paczki tuż
    po jej instalacji. Wszystkie ścieżki w obrębie tej funkcji powinny być
    poprzedzone zmienną <c>ROOT</c>, wskazującą podany przez użytkownika
    katalog instalacji, który niekoniecznie musi być katalogiem <path>/</path>.
    Funkcja ta wykonywana jest <e>tylko i wyłącznie</e> wtedy, gdy użytkownik
    wyda polecenie: <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze</b></p>

<p>
W naszych skryptach ebuild mo¿emy u¿yæ tak¿e nastêpuj±cych funkcji pomocniczych.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Sprawdza czy jedna lub wiêcej flag USE s± zdefiniowane. Je¶li tak, funkcja
    ta wypisze te flagi zawarte w zmiennej <c>USE</c>. Zachwanie to jednak ma
    siê wkrótce zmieniæ i funkcja <c>use</c> nie bêdzie nic wypisywaæ, za to
    bêdzie to robiæ funkcja <c>usev</c>. Aby sprawdziæ istnienie flagi USE,
    nale¿y u¿yæ <c>use blabla</c>.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Zwraca 1 je¶li w systemie jest ¿±dana werjsa danej paczki. Na przyk³ad
    <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Zwraca <path>kategoria/paczka-wersja</path> danej paczki, podanej w formacie
    <path>kategoria/paczka</path>. Na przyk³ad <c>best_version
    x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    Funkcja ta sprawdza czy flaga USE zosta³a zdefiniowana i zwraca odpowiednio
    &quot;--with-foobar&quot; lub &quot;--without-foobar&quot;. Je¶li podamy
    funkcji tylko jeden argument, oznacza to, ¿e jest on zarówno flag± USE, jak
    i tekstem with/without. Podaj±c za¶ dwa pierwszy z nich jest flag± USE, a
    drugi tekstem with/without. Na przyk³ad <c>use_with truetype freetype</c>
    wypisze &quot;--with-freetype&quot;, je¶li zmienna <c>USE</c> zawiera
    truetype. 
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    Tak samo jak przypadku <c>use_with</c>, lecz zwraca odpowiednio 
    &quot;--enable-blabla&quot; lub &quot;--disable-blabla&quot;.
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Sprawdza czy Portage zna wersjê j±dra. Je¶li nie, wypisze komunikat b³êdu i
    zakoñczy dzia³anie niepowodzeniem. Je¶li w naszym skrypcie potrzebujemy
    wersji j±dra, nale¿y u¿yæ zmiennej <c>KV</c>, która jest automatycznie
    definiowana przez Portage. W systemie dzia³aj±cym na j±drze
    gentoo-sources-2.4.20-r6, zmienna <c>KV</c> bêdzie mia³a warto¶æ
    &quot;2.4.20&quot;.
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Tworzy (je¶li jest to konieczne) plik <path>.keep</path> w danym katalogu,
    aby katalog ten nie zosta³ automatycznie usuniêty. <e>Nigdy</e> nie nale¿y
    tworzyæ pliku <path>.keep</path> rêcznie. Je¶li zasada dzia³ania funkcji
    <c>keepdir</c> zmieni siê w Portage, samodzielne tworzenie tego pliku
    popsuje paczkê.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Wykonuje polecenie <c>./configure</c> z wszelkimi niezbêdnymi zmianami 
    w ¶cie¿kach (prefix, host, mandir, infodir, datadir, sysconfdir,
    localstatedir). Mo¿emy opcjonalnie przekazaæ dodatkowe argumenty do
    <c>./configure</c>, przekazuj±c je funkcji <c>econf</c> przy wywo³aniu, za¶
    u¿ytkownicy w razie potrzeby mog± ustawiæ zmienn± ¶rodowiskow±
    <c>EXTRA_ECONF</c>. Opcje przekazane skryptowi configure przejmuj±
    pierwszeñstwo w odwrotnej kolejno¶ci ni¿ jak zosta³y podane. Innymi s³owy,
    pierwszy przekazany argument zostanie zawsze zast±piony ostatnim.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Wykonuje polecenie <c>make install</c> z wszystkimi niezbêdnymi zmianami w
    ¶cie¿kach (prefix, datadir, mandir, infodir, datadir, sysconfdir,
    localstatedir). Jak wy¿ej, mo¿na przekazaæ dodatkowe argumenty do komendy
    make, przekazuj±c je funkcji <c>einstall</c> przy jej wywo³aniu. Zauwa¿my
    jednak, ¿e preferowanym sposobem zainstalowania paczki jest wywo³anie
    komendy <c>make install DESTDIR=${D}</c>, a nie za pomoc± <c>einstall</c>.
    Komenda ta u¿ywana jest tylko zastêpczo, w przypadku popsutych plików make.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Powoduje przerwanie aktualnego procesu. Poinformuje u¿ytkownika o przyczynie
    problemu, wypisuj±c podane argumenty. Przekazanie argumentów funkcji
    <c>die</c> jest wysoce wskazane, je¶li mamy wiêcej ni¿ jedno jej wywo³anie w
    danej funkcji. O wiele trudniej jest wy¶ledziæ problemy, je¶li nie wiemy 
    <e>gdzie</e> problem wyst±pi³.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Informuje u¿ytkownika o czym¶ istotnym. Argument przekazany funkcji
    <c>einfo</c> bêdzie komunikatem, który zobaczy u¿ytkownik. Nie nale¿y u¿ywaæ
    tej funkcji aby wypisywaæ nag³ówki w rodzaju
    &quot;*************************************&quot;. Sam fakt, ¿e zosta³a
    u¿yta funkcja <c>einfo</c> wystarczy, aby przyci±gn±æ uwagê u¿ytkownika.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze dostarczone przez eutils.eclass</b></p>

<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "eutils". Nale¿y upewniæ siê, ¿e u¿yli¶my instrukcji
<c>inherit eutils</c>, inaczej funkcje te nie bêd± dzia³aæ.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>epatch</c></ti>
  <ti>
    Funkcja ta jest bardziej przyjazn± wersj± polecenia <c>patch</c>. Dzia³a ona
    nie tylko z ³atkami w plikach tekstowych, ale te¿ w plikach typu .bz2, .gz 
    i .zip. Nie trzeba podawaæ opcji "-p", za¶ opcje, które nale¿y podaæ powinny
    byæ ustawione w zmiennej <c>EPATCH_OPTS</c>. Funkcja oczekuje pliku lub
    katalogu jako argumentu. Je¶li podamy katalog, wszystkie ³atki w postaci
    "??${ARCH}_..." zostan± na³o¿one. Aby poprawka mog³a byæ na³o¿ona, musi
    pasowaæ do naszej architektury, mieæ napis "_all_" w nazwie pliku, lub
    zmienna <c>EPATCH_FORCE</c> musi byæ ustawiona na "yes".
  </ti>
</tr>
<tr>
  <ti><c>gen_usr_ldscript</c></ti>
  <ti>
    Funkcja ta tworzy w katalogu /usr/lib skrypty linkera dla dynamicznych
    bibliotek z katalogu /lib. Naprawia to problemy z linkowaniem gdy plik .so
    znajduje siê w katalogu /lib, podczas gdy plik .a znajduje siê w katalogu
    /usr/lib.
  </ti>
</tr>
<tr>
  <ti><c>have_NPTL</c></ti>
  <ti>
    Zwraca 0 je¶li system u¿ywa NPTL jako implementacji PThreads. 
  </ti>
</tr>
<tr>
  <ti><c>get_number_of_jobs</c></ti>
  <ti>
    Funkcja ta sprawdza ile jest procesorów w systemie, a nastêpnie ustawia
    prawid³ow± opcjê -jX w zmiennej <c>MAKEOPTS</c>.
  </ti>
</tr>
<tr>
  <ti><c>mymktemp</c></ti>
  <ti>
    Funkcja ta pe³ni rolê interfejsu dla mktemp, je¶li ten istnieje, lub
    zastêpuje go, je¶li nie istnieje.
  </ti>
</tr>
<tr>
  <ti><c>edos2unix</c></ti>
  <ti>
    Funkcja ta robi dok³adnie to samo co program <c>dos2unix</c>.
  </ti>
</tr>
<tr>
  <ti><c>egetent</c></ti>
  <ti>
    Funkcja egetent pe³ni rolê interfejsu dla <c>getnet</c> pod Linuksem lub dla
    <c>nidump</c> pod Mac OS X (R).
  </ti>
</tr>
<tr>
  <ti><c>enewuser</c></ti>
  <ti>
    Tworzy nowego u¿ytkownika. Funkcja oczekuje wymaganego parametru z nazw±
    u¿ytkownika i szeregu opcjonalnych argumentów: <c>$2</c> zawiera UID, za¶
    gdy przeka¿emy -1 u¿yty zostanie nastêpny dostêpny; <c>$3</c> zawiera
    pow³okê systemow±, domy¶lnie bêdzie to <path>/bin/false</path>; <c>$4</c> to
    katalog domowy, domy¶lnie <path>/dev/null</path>, <c>$5</c> zawiera grupy,
    do których u¿ytkownik powinien zostaæ dodany (domy¶lnie ¿adne), za¶
<c>$6</c> zawiera komentarz - domy¶lnie "added by portage for <c>${PN}</c>".
  </ti>
</tr>
<tr>
  <ti><c>enewgroup</c></ti>
  <ti>
    Dodaje now± grupê. Funkcja oczekuje wymaganego parametru z nazw± grupy -
    opcjonalny drugi argument to konkretny GID.
  </ti>
</tr>
<tr>
  <ti><c>make_desktop_entry</c></ti>
  <ti>
    FIXME Tworzy wpis desktop wg standardu freedesktop.org Pierwszyy argument
    zawiera ¶cie¿kê do pliku binarnego z programem. Dodatkowo drugi zawiera
    nazwê pliku ikony - domy¶lna warto¶æ to <c>${PN}</c>; trzeci mo¿e zawieraæ
    ¶cie¿kê do pliku ikony - wzglêdn± do ¶cie¿ki <path>/usr/share/pixmaps</path>
    lub pe³n± ¶cie¿kê. Warto¶æ domy¶lna to <c>${PN}</c>.png; czwarty mo¿e
    zawieraæ <uri
    link="http://standards.freedesktop.org/menu-spec/latest/apa.html">kategoriê
    aplikacji</uri>, za¶ pi±ty argument zawiera opcjonaln± ¶cie¿kê pocz±tkow±
    dla aplikacji.
  </ti>
</tr>
<tr>
  <ti><c>check_license</c></ti>
  <ti>
    Wy¶wietla licencjê aby u¿ytkownik móg³ j± przeczytaæ i zaakceptowaæ. Je¶li
    nie podano argumentów, u¿yta zostanie licencja okre¶lona przez zmienn±
    <c>${LICENSE}</c>.
  </ti>
</tr>
<tr>
  <ti><c>unpack_pdv</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez pdv, przy czym pierwszy argument
    musi zawieraæ nazwê pliku archiwum, drugi za¶ warto¶æ "off_t", któr± nale¿y
    wygenerowaæ rêcznie: <c>strace -elseek ${plik}</c>, za¶ dla przyk³adowego
    wywo³ania takiego jak to: "lseek(3, -4, SEEK_END)"  przekazaliby¶my warto¶æ
    "4". 
  </ti>
</tr>
<tr>
  <ti><c>unpack_makeself</c></ti>
  <ti>
    Rozpakowuje archiwum wygenerowane przez makeself, wymaga nazwy pliku do
    rozpakowania jako argumentu.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_get_cds</c></ti>
  <ti>
    FIXME (wtf?)

    Attempts to get a CD, present with files specified by the
    arguments present on the system and mounted at <c>${CDROM_ROOT}</c>.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_load_next_cd</c></ti>
  <ti>
    £aduje nastêpn± p³ytê CD gdy ju¿ skoñczyli¶my z poprzedni±. Je¶li funkcja
    zwróci warto¶æ, zmienna <c>${CDROM_ROOT}</c> wska¿e nastêpn± p³ytê CD.
  </ti>
</tr>
<tr>
  <ti><c>strip-linguas</c></ti>
  <ti>
    Zadaniem tej funkcji jest upewnienie siê, ¿e zmienna LINGUAS zawiera tylko
    obs³ugiwane przez paczkê jêzyki, podawane jako argumenty dla funkcji. Je¶li
    pierwszym argumentem jest -i, tworzona jest lista plików .po w okre¶lonych
    katalogach i u¿yta jest czê¶æ wspólna list. Je¶li za¶ pierwszym
    argumentem jest -u, tworzona jest lista plików .po w okre¶lonych katalogach
    i u¿yta jest suma list.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze dostarczone przez flag-o-matic.eclass</b></p>

<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "flag-o-matic". Nale¿y upewniæ siê, ¿e u¿yli¶my
instrukcji <c>inherit flag-o-matic</c>, inaczej funkcje te nie bêd± dzia³aæ.
Nigdy nie nale¿y rêcznie modyfikowaæ ustawieñ kompilatora, zamiast tego
powinni¶my u¿yæ funkcji z eklasy flag-o-matic do czynno¶ci typu odfiltrowanie
sprawiaj±cych k³opoty flag.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>filter-flags</c></ti>
  <ti>
    Funkcja ta usuwa konkretne flagi ze zmiennych <c>C[XX]FLAGS</c> - usuwane s±
    tylko flagi, których nazwy w ca³o¶ci pasuj± do nazw tych, które chcemy usun±æ.
  </ti>
</tr>
<tr>
  <ti><c>append-flags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniej±cych zmiennych
    <c>C[XX]FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>replace-flags</c></ti>
  <ti>
    Zamienia w zmiennych <c>C[XX]FLAGS</c> flagê podan± jako pierwszy argument
    na flagê podan± jako drugi.
  </ti>
</tr>
<tr>
  <ti><c>replace-cpu-flags</c></ti>
  <ti>
    Zamienia flagi -march=... lub -mcpu=... zawieraj±ce drugi argument
    funkcji flagami z pierwszego argumentu.
  </ti>
</tr>
<tr>
  <ti><c>replace-sparc64-flags</c></ti>
  <ti>
    Ta flaga ustawia -mcpu=... na v8 SPARC i u¿ywa pierwotn± warto¶æ tej flagi
    jako -mtune, o ile ta nie zosta³a ju¿ podana.
  </ti>
</tr>
<tr>
  <ti><c>strip-flags</c></ti>
  <ti>
    Usuwa wszystkie flagi z wyj±tkiem tych podanych w zmiennej
    <c>ALLOWED_FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>strip-unsupported-flags</c></ti>
  <ti>
    Usuwa ze zmiennych <c>C[XX]FLAGS</c> wszystkie flagi, których nie obs³uguje
    aktualnie dzia³aj±ca wersja kompilatora GCC.
  </ti>
</tr>
<tr>
  <ti><c>get-flag</c></ti>
  <ti>
    Znajduje flagê i wypisuje jej warto¶æ.
  </ti>
</tr>
<tr>
  <ti><c>is-flag</c></ti>
  <ti>
    Funkcja ta zwraca warto¶æ true je¶li dana flaga jest aktualnie ustawiona w
    zmiennych <c>C[XX]FLAGS</c>; nazwy flag musz± siê zgadzaæ w ca³o¶ci, aby
    zosta³y dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>append-ldflags</c></ti>
  <ti>
    Funkcja ta dodaje dodatkowe flagi do istniej±cej zmiennej <c>LDFLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>filter-ldflags</c></ti>
  <ti>
    Usuwa podane flagi ze zmiennej <c>LDFLAGS</c>, przy czym nazwy flag musz±
    siê zgadzaæ w ca³o¶ci, aby zosta³y dopasowane.
  </ti>
</tr>
<tr>
  <ti><c>fstack-flags</c></ti>
  <ti>
    Dodaje flagê -fno-stack-protector, która znosi flagi -fstack-protector i
    -fstack-protector-all.
  </ti>
</tr>
</table>



<p>
Mo¿emy u¿yæ nastêpuj±cych funkcji pomocniczych, które s± dostêpne w naszych
ebuildach poprzez eklasê "toolchain-funcs". Nale¿y upewniæ siê, ¿e u¿yli¶my
instrukcji <c>inherit toolchain-funcs</c>, inaczej funkcje te nie bêd± dzia³aæ.
Nigdy nie nale¿y rêcznie modyfikowaæ ustawieñ kompilatora lub binutils, zamiast tego
powinni¶my u¿yæ funkcji z eklasy flag-o-matic aby okre¶laæ kompilatory i
binutils.
</p>
<p>
Poni¿sze funkcje stosuje siê, aby wspieraæ kompilacjê skro¶n± i kompilator icc.
Powinny byæ one u¿ywane gdy paczka wprost u¿ywa gcc, g++, ld, ranlib lub
jakichkolwiek poni¿szych narzêdzi. Na ogó³ paczki, które u¿ywaj± narzêdzi do
autokonfiguracji wykrywaj± kompilacjê skro¶n± automatycznie i nie potrzebuj±
poni¿szych funkcji.
</p>
  <table>
    <tr>
      <th>Funkcja</th>
      <th>Zastosowanie</th>
    </tr>
    <tr>
      <ti>
        <c>tc-getAR</c>
      </ti>
      <ti>Zwraca nazwê archiwizatora.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getAS</c>
      </ti>
      <ti>Zwraca nazwê asemblera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCC</c>
      </ti>
      <ti>Zwraca nazwê kompilatora C.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCXX</c>
      </ti>
      <ti>Zwraca nazwê kompilatora C++.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>Zwraca nazwê linkera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getNM</c>
      </ti>
      <ti>Zwraca nazwê narzêdzia do inspekcji symboli/obiektów.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getRANLIB</c>
      </ti>
      <ti>Zwraca nazwê FIXME archiver indexer</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getF77</c>
      </ti>
      <ti>Zwraca nazwê kompilatora fortrana.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>FIXME(powtarza siê?) Zwraca nazwê linkera.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getGCJ</c>
      </ti>
      <ti>Zwraca nazwê kompilatora javy.</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getBUILD_CC</c>
      </ti>
      <ti>Returns the name of the C compiler for build</ti>
      <ti>Zwraca nazwê kompilatora C do budowania. (FIXME C comp. for build)</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-is-cross-compiler</c>
      </ti>
      <ti>Prosty sposób na sprawdzenie czy u¿ywamy kompilatora skro¶nego.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-fullversion</c>
      </ti>
      <ti>Zwraca wersjê tak samo jak polecenie $($CC -dumpversion)</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-version</c>
      </ti>
      <ti>Zwraca tylko postaæ &lt;major>.&lt;minor> wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-major-version</c>
      </ti>
      <ti>Zwraca czê¶æ Major wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-minor-version</c>
      </ti>
      <ti>Zwraca czê¶æ Minor wersji.</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-micro-version</c>
      </ti>
      <ti>Zwraca czê¶æ Micro wersji.</ti>
    </tr>
  </table>


</body>
</subsection>

<subsection>
<title>Zasady pisania plików ebuild</title>
<body>

<p>
Pliki ebuild s± tak naprawdê skryptami pow³oki, powinni¶my wiêc przy ich edycji
u¿ywaæ trybu edycji skryptów pow³oki naszego edytora. Nale¿y stosowaæ
odpowiednie wciêcia, wy³±cznie przy pomocy znaków tabulacji -- <e>¿adnych
spacji</e>. Nale¿y siê upewniæ, ¿e rozmiar tabulacji w naszym edytorze wynosi 4
spacje. Zawsze powinni¶my stosowaæ FIXME (braces) w±sy wokó³ zmiennych
¶rodowiskowych, czyli <c>${P}</c> zamiast <c>$P</c>.
</p>

<p>
D³ugie linie zawijamy za pomoc± znaku ' \':
</p>

<pre caption="Zawijanie wierszy w plikach ebuild">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
Wiêcej szczegó³ów znajdziemy w pliku <path>skel.ebuild</path> (zwykle znajduje
siê on w katalogu <path>/usr/portage</path>).
</p>

<p>
Warto zwróciæ uwagê na domy¶lny plik vimrc w Gentoo je¶li u¿ywamy programu Vim
do edycji plików ebuild/eclass. Znajduje siê on w katalogu
<path>/etc/vim/vimrc</path> i zawiera poprawne ustawienia wciêæ i typów plików
dla plików ebuild i eclass. Jeszcze wiêcej mo¿liwo¶ci, w tym specjalne
pod¶wietlanie sk³adni w plikach ebuild uzyskamy instaluj±c
app-vim/gentoo-syntax.
</p>

<p>
Na systemach innych ni¿ Gentoo podobne ustawienia zyskamy, dopisuj±c poni¿sze
linijki do naszego pliku vimrc, albo jeszcze lepiej, instaluj±c skrypty <uri
link="https://developer.berlios.de/projects/gentoo-syntax/">gentoo-syntax</uri>.
</p>

<pre caption="Konfiguracja vimrc do edycji plików ebuild">
au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh
au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab
</pre>

<p>
Je¶li u¿ywamy edytora Emacs mo¿my dodaæ nastêpuj±cy fragment do pliku .emacsrc
(w GNU Emacs) lub init.el (w XEmacs) aby upewniæ siê, ¿e u¿ywamy poprawnych
ustawieñ przy edycji plików Gentoo.
</p>

<pre caption="Konfiguracja emacsrc do edycji plików ebuild">
(defun ebuild-mode ()
  (shell-script-mode)
  (sh-set-shell "bash")
  (make-local-variable 'tab-width)
  (setq tab-width 4))
(setq auto-mode-alist (cons '("\\.ebuild$" . ebuild-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.eclass$" . ebuild-mode) auto-mode-alist))
</pre>

<p>
Je¶li za¶ u¿ywamy edytora nano, szczê¶liwie oszczêdzono nam pracy. Wystarczy
tylko odkomentowaæ sekcjê dotycz±c± ebuildów w pliku <path>/etc/nanorc</path>.
</p>

</body>
</subsection>
<subsection>
<title>Zmienne USE</title>
<body>

<p>
Dziêki zmiennym USE mo¿liwe jest skonfigurowanie Portage aby globalnie i
automatycznie w³±cza³ lub wy³±cza³ pewne <e>opcjonalne, ustawiane przy
budowaniu</e> funkcje programów. Oto przyk³ad. Za³ó¿my, ¿e jeste¶my fanami
¶rodowiska GNOME i chcieliby¶my, aby ka¿dy ebuild, który daje mo¿liwo¶æ
wkompilowania opcjonalnej obs³ugi tego ¶rodowiska zrobi³ to. W tym przypadku
nale¿y dodaæ <c>gnome</c> do zmiennej <c>USE</c> w pliku
<path>/etc/make.conf</path>, a Portage automatycznie bêdzie dodawa³ opcjonaln±
funkcjonalno¶æ GNOME do paczek, je¶li jest ona dostêpna. Podobnie, je¶li nie
chcemy funkcji GNOME w naszych ebuildach, wystarczy upewniæ siê, ¿e <c>gnome</c>
nie jest dodane do zmiennej <c>USE</c> w pliku <path>/etc/make.conf</path>.
System Gentoo Linux ma niemal przyt³aczaj±c± ilo¶æ opcji USE, dziêki czemu
mo¿emy skonfigurowaæ go dok³adnie tak jak chcemy.
</p>

<note>
Je¶li wy³±czymy flagê USE (na przyk³ad usuwaj±c <c>gnome</c> ze zmiennej
<c>USE</c>), poinstruuje to jedynie Portage aby wy³±czyæ <e>opcjonalne</e>
wsparcie dla GNOME w czasie budowania. Jednak¿e je¶li instalujemy za pomoc±
narzêdzia <c>emerge</c> ebuild, którzy <e>wymaga</e> GNOME, paczka ta oczywi¶cie
bêdzie zawieraæ obs³ugê tego ¶rodowiska. Oznacza to tak¿e, ¿e GNOME zostanie
automatycznie zainstalowane (jako zale¿no¶æ), je¶li wcze¶niej nie by³o go w
systemie. W³a¶nie dlatego dobrze jest u¿yæ polecenia <c>emerge --pretend</c>
zanim uruchomimy &quot;prawdziwy&quot; <c>emerge</c>; w ten sposób zawsze
bêdziemy wiedzieæ co siê zainstaluje.
</note>

<p>
W naszych skryptach ebuild mo¿emy sprawdzaæ czy dana zmienna USE jest ustawiona
za pomoc± polecenia <c>use &lt;zmienna&gt;</c>. Komenda <c>use</c> wypisuje
<c>&lt;zmienn±&gt;</c> je¶li jest ona obecna w zmiennej <c>USE</c> u¿ytkownika.
Najczê¶ciej u¿yjemy tego polecenia analogicznie jak poni¿ej:
</p>

<pre caption="Sprawdzanie czy flaga USE jest ustawiona">
if use X; then
  # Komendy specyficzne dla X...
fi
</pre>

<p>
Zmiennych USE mo¿na równie¿ u¿ywaæ w celu ustawiania zale¿no¶ci. Na przyk³ad
chcieliby¶my aby pewna paczka by³a wymagana tylko je¶li ustawiona jest pewna
zmienna USE. Mo¿emy tego dokonaæ za pomoc± sk³adni <c>flaga? ( kategoria/paczka
)</c> w zmiennej <c>DEPEND</c> naszego pliku ebuild. W tym przypadku
<c>kategoria/paczka</c> bêdzie wymagana jedynie wtedy, gdy <c>flaga</c> bêdzie
obecna w zmiennej <c>USE</c>. Mo¿liwe jest tak¿e okre¶lenie jaka zale¿no¶æ ma
zostaæ u¿yta je¶li pewna flaga USE <e>jest</e> ustawiona, a jaka ma zostaæ
u¿yta, je¶li <e>nie jest</e> ustawiona: <c>flaga? ( kategoria/paczka )</c> i
<c>!flaga? ( innakategoria/innapaczka )</c>. W tym przypadku je¶li <c>flaga</c>
nie jest ustawiona, u¿yta zostanie <c>innakategoria/innapaczka</c> zamiast
<c>kategoria/paczka</c>. Nale¿y upewniæ siê, ¿e nasze ebuildy u¿ywaj± powy¿szej
sk³adni, a nie instrukcji warunkowych IF pow³oki bash. Instrukcje warunkowe
basha nie wspó³pracuj± z cache'owaniem zale¿no¶ci przez Portage, wiêc u¿ywanie
ich popsuje nasz ebuild.
</p>

<p>
Oto wa¿na wskazówka jak u¿ywaæ zmiennej <c>USE</c>. Najczê¶ciej paczki posiadaj±
skrypt <c>./configure</c>, za pomoc± którego dokonuje siê ich konfiguracji.
Zwykle je¶li nasz ebuild u¿ywa <c>./configure</c>, wszelka opcjonalna
funkcjonalno¶æ zostanie w³±czona lub wy³±czona przy budowaniu przez przekazanie
odpowiednich parametrów do polecenia <c>./configure</c>. Oto najlepszy sposób na
obs³u¿enie tego:
</p>

<pre caption="Wyra¿enia warunkowe oparte na ustawieniach USE">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 )
!apache2? ( =net-www/apache-1* )"

src_compile() {
  econf \
    $(use_enable X x11) \
    $(use_enable mysql) \
    || die "Error: econf failed!"
  emake || die "Error: emake failed!"
}
</pre>

<p>
Takie podej¶cie daje dobre wyniki. Nie musimy martwiæ siê jakie s± domy¶lne
ustawienia mysql albo X (w³±czone/wy³±czone), przekazujemy wprost funkcji
<c>econf</c> co ma zrobiæ w oparciu o zmienn± <c>USE</c>. Nie wspominaj±c ju¿ 
o przejrzysto¶ci takiego kodu. :)
</p>

<p>
Pod <uri link="http://www.gentoo.org/dyn/use-index.xml">tym adresem</uri> mo¿emy
obejrzeæ stale uaktualnian± tabelê zmiennych USE.
</p>

</body>
</subsection>
</section>
<section>
<title>Po³o¿enia w systemie plików</title>
<subsection>
<title>Wprowadzenie do FHS</title>
<body>

<p>
Standard rozmieszczenia katalogów w systemie plików ¶ci¶le odpowiada FHS, czyli
<e>File system Hierarchy Standard</e> (standard hierarchii systemu plików).
Uproszczony opis standardu podajemy poni¿ej; kompletn± specyfikacjê mo¿na
znale¼æ pod adresem <uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
Katalog <path>/opt</path> omówiony jest w czê¶ci 3.12 standardu FHS. Czê¶æ 4.4
traktuje o katalogu <path>/usr/X11R6</path>. ¦rodowiska KDE i GNOME nie s±
omówione, a dok³adniej nie ma o nich nawet wzmianki w aktualnej wersji FHS.
</note>

</body>
</subsection>
<subsection>
<title>Jak umieszczaæ paczki w systemie plików</title>
<body>

<p>
Je¶li paczka u¿ywa autoconf i automake, domy¶lne katalogi docelowe przy
instalacji zwykle bêd± poprawne, z kilkoma wyj±tkami:
</p>

<ul>
<li>
Je¶li instalujemy program FIXME (w?) do katalogu <path>/bin</path>, <path>/sbin</path>,
<path>/usr/bin</path> lub <path>/usr/sbin</path>, dokumentacja man programu
powinna zostaæ zainstalowana w katalogu <path>/usr/share/man</path>. Zwykle
mo¿na to osi±gn±æ pisz±c w skrypcie ebuild <c>./configure
--mandir=/usr/share/man</c>.
</li>
<li>
Pliki dokumentacji GNU info zawsze powinny byæ instalowane w katalogu
<path>/usr/share/info</path>, <e>nawet je¶li dokumentacja nale¿y do programów
specyficznych dla X11, GNOME lub KDE</e>. Zwróæmy uwagê: katalog
<path>/usr/share/info</path> jest <e>jedynym</e> oficjalnym miejscem na pliki
GNU info. Czêsto skrypty <c>./configure</c> domy¶lnie instaluj± pliki GNU info w
katalogu <c>/usr/info</c>. W tej sytuacji nale¿y przekazaæ <c>./configure</c>
parametr <c>--infodir=/usr/share/info</c>.
</li>
<li>
Pliki dokumentacji s± instalowane w katalogu <path>/usr/share/doc</path>, do
podkatalogu, na którego nazwê sk³ada siê nazwa, wersja i rewizja danego
programu. Dotyczy to wszystkich programów: GNOME, KDE, X11 i konsolowych.
Niektóre programy jednak mog± dla swoich potrzeb instalowaæ dodatkow±
dokumentacjê i pliki pomocnicze w hierarchii <path>/usr/share</path>. 
</li>
<li>
Programy i biblioteki specyficzne dla X11 zawsze powinny byæ instalowane w
katalogu <path>/usr</path>, a nie bezpo¶rednio w <path>/usr/X11R6</path>. Tê
hierarchiê katalogów rezerwujemy dla <e>samego</e> Systemu X Window w Wersji 11,
Wydaniu 6. Jest to byæ mo¿e bardziej dos³owna interpretacja standardu FHS ni¿ w
przypadku wielu innych dystrybucji.
</li>
<li>
Podobnie programy GNOME i KDE powinny byæ zawsze instalowane w katalogu
<path>/usr</path>.
</li>
</ul>

<impo>
Niektóre dystrybucje instaluj± GNOME i KDE w katalogu <path>/opt</path>. Nie
istnieje standard, który definiowa³by gdzie nale¿y umieszczaæ pliki tych
¶rodowisk graficznych. W imiê prostoty i spójno¶ci zdecydowali¶my umieszczaæ
wszystkie paczki KDE i GNOME do hierarchii katalogów <path>/usr</path>.
</impo>

<p>
Ogólnie nasze ebuildy powinny instalowaæ pliki do katalogu <path>/usr</path>.
<e>Niektóre</e> programy mog± byæ kompilowane i linkowane z bibliotekami GNOME,
KDE oraz X11, lub bez nich, co mo¿e powodowaæ zamieszanie. Rozwi±zanie, jakie
proponujemy to instalowanie wszystkiego do katalogu <path>/usr</path>, dziêki
czemu autorzy skryptów ebuild unikn± niejednoznacznych sytuacji i niepotrzebnych
komplikacji. Miejsce, w którym bêdziemy instalowaæ pliki programu <e>nie
mo¿e</e> zale¿eæ od obecno¶ci lub nieobecno¶ci jakich¶ zmiennych <c>USE</c>.
Dlatego ebuildy w drzewie portage <e>praktycznie zawsze</e> instaluj± swoje
pliki wy³±cznie w hierarchii katalogów <path>/usr</path>. 
</p>

<note>
Katalog <path>/opt</path> jest w systemie Gentoo Linux zarezerwowany dla paczek
binarnych, na przyk³ad mozilla-bin, acroread, netscape i realplayer. Najczê¶ciej
paczki instalowane w tym katalogu wymagaj± dodatkowego pliku
<path>/etc/env.d/co¶</path>. S³u¿y on do w³±czenia ¶cie¿ek i dodatkowych
zmiennych do ¶rodowiska. Wiêcej informacji na temat katalogu
<path>/etc/env.d</path> mo¿na znale¼æ w <uri
link="/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=5">tym</uri> dokumencie.
</note>

</body>
</subsection>
</section>
<section>
<title>Skrypty i narzêdzia Portage</title>
<subsection>
<title>Skrypty publiczne</title>
<body>

<p>
S± to skrypty u¿ywane przez administratora systemu do instalacji 
i deinstalacji paczek, a tak¿e przy opiekowaniu siê baz± danych paczek.
</p>

<p>
Skrypt <c>ebuild</c> jest g³ównym "silnikiem" systemu Portage; za jego pomoc±
wykonujemy wszystkie g³ówne zadania, na przyk³ad rozpakowanie, kompilacja,
instalacja, integracja z systemem i deinstalacja paczek. U¿ywa siê go w
nastêpuj±cy sposób: <c>ebuild ¶cie¿ka/do/paczki.ebuild komenda</c>. Oto dostêpne
komendy:
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Opis</th>
  <th>Spokrewniona funkcja ze skryptów <c>ebuild</c></th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Wykonuje ró¿norakie komendy, których uruchomienie wymagane jest zanim
    rozpocznie siê w³a¶ciwe budowanie.
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Wy¶wietla zale¿no¶ci niezbêdne do zbudowania paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Rozpakowuje, kompiluje, instaluje i integruje paczkê z systemem plików.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Integruje paczkê z systemem plików, zak³adaj±c, ¿e etapy rozpakowania,
    kompilacji i instalacji ju¿ zosta³y wykonane.
  </ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Rozpakowuje archiwa z kodem ¼ród³owym do katalogu roboczego.
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Kompiluje paczkê</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Tworzy pakiet RPM z paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Creates a Gentoo <c>tbz2</c> package</ti>
  <ti>Tworzy pakiet Gentoo w formacie <c>tbz2</c>.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Executes the pre-removal stage of the package</ti>
  <ti>FIXME Wykonuje etap przed usuniêciem paczki.</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Executes the post-removal stage of the package</ti>
  <ti>FIXME Wykonuje etap po usuniêciu paczki.</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Executes the pre-installation stage of the package</ti>
  <ti>FIXME Wykonuje etap przed zainstalowaniem paczki.</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Executes the post-installation stage of the package</ti>
  <ti>FIXME Wykonuje etap po zainstalowaniu paczki.</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Przygotowuje domy¶ln± konfiguracjê gdy paczka zosta³a zainstalowana w
  systemie plików.</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Uaktualnia czasy modyfikacji ka¿dego archiwum ¼ród³owego paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Czy¶ci katalog roboczy paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Pobiera pliki ze ¼ród³ami paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Tworzy plik digest paczki.</ti>
  <ti>Nie dotyczy</ti>
</tr>
<tr>
  <ti><c>test</c>*</ti>
  <ti>Uruchamia funkcjê autotestu paczki.</ti>
  <ti><c>src_test</c></ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Instaluje paczkê do katalogu obrazu.</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Usuwa paczkê z systemu plików.</ti>
  <ti>Nie dotyczy</ti>
</tr>
</table>

<note>
Komendy oznaczone gwiazdk± (*) zwykle u¿ywane s± tylko przez deweloperów.
</note>

<p>
Narzêdzie <c>emerge</c> rekursywnie instaluje paczkê i wszystkie jej zale¿no¶ci
w systemie plików. Komenda to ma wiele opcji, których listê mo¿emy zobaczyæ,
wydaj±c polecenie <c>emerge --help</c>.
</p>

<p>
Narzêdzie <c>env-update</c> uaktualnia pliki konfiguracyjne (w tym
<path>/etc/ld.so.conf</path> i <path>/etc/profile.env</path>), aby uwzglêdnia³y
zmiany wprowadzone przez zainstalowane paczki.
</p>

</body>
</subsection>
<subsection>
<title>Prywatne skrypty i komendy</title>
<body>

<p>
Skryptów tych mo¿emy u¿yæ w naszych skryptach ebuild do wykonywania typowych
zadañ.
</p>

<p>
Je¶li kto¶ lubi grzebaæ w kodzie, mo¿e przyjrzeæ siê poni¿szym skryptom,
zagl±daj±c do katalogu <path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Warto¶æ domy¶lna</th>
  <th>Opis</th>
  <th>Przyk³ad</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Ustawia opcje gdy uruchamiamy skrypt <c>dodir</c>.</ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Instaluje podane pliki binarne do katalogu <path>DESTTREE/bin</path>.</ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Ustawia wzglêdny podkatalog (<e>DOCDESTTREE</e>) dla skryptu <c>dodoc</c>.
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy katalog, automatycznie uwzglêdniaj±c katalog ${D}.</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki do katalogu z dokumentacj± paczki
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>)  (zob. <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <e>EXEOPTIONS</e> (zob.
    <c>exeopts</c>) do katalogu <path>EXEDESTTREE</path> (zob. <c>exeinto</c>).
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy dowi±zanie twarde, automatycznie uwzglêdniaj±c katalog ${D}.</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki i katalogi do katalogu
    <path>/usr/share/doc/${PF}/html</path>. 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki do katalogu /usr/share/info, a nastêpnie kompresuje
    je programem gzip.
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki z uprawnieniami <c>INSOPTIONS</c> (zob.
    <c>insopts</c>) do katalogu <path>INSDESTTREE</path> (zob. <c>insinto</c>).
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki do katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki do katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane biblioteki do katalogu <path>DESTTREE/lib</path> z
    uprawnieniami 0644.
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje podane pliki do katalogu <path>/usr/share/man/manX</path> na
    podstawie przyrostka nazwy pliku (plik.1 zostanie zainstalowany w katalogu
    <path>man1</path>).
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Instaluje pliki do katalogu <path>DESTTREE/sbin</path>, upewniaj±c siê, ¿e
    uprawnienia zezwalaj± na ich wykonywanie.
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Tworzy dowi±zanie symboliczne, automatycznie uwzglêdniaj±c katalog
  ${D}.</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia make z argumentami <c>MAKEOPTS</c>. Niektórych paczek nie mo¿na
    kompilowaæ równolegle; wówczas powinni¶my u¿yæ <c>emake -j1</c>. Je¶li
    musimy przekazaæ jeszcze dodatkowe parametry do make, wystarczy przekazaæ je
    do polecenia emake jako parametry. U¿ytkownicy mog± ustawiæ zmienn±
    ¶rodowiskow± <c>EXTRA_EMAKE</c> aby przekazywaæ dodatkowe flagi poleceniu
    emake.
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Ustawia katalog g³ówny (<e>EXEDESTTREE</e>) dla polecenia
  <c>doexe</c>.</ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>FIXME Ustawia opcje do uruchomienia polecenia <c>doexe</c>.</ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    FIXME Nadaje podanemu plikowi podanego w³a¶ciciela poprzez komendê chown,
    automatycznie uwzglêdniaj±c katalog ${D}.
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Nadaje podanemu plikowi podane uprawnienia poprzez komendê chmod,
    automatycznie uwzglêdniaj±c katalog ${D}.    
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Ustawia katalog g³ówny (<e>INSDESTTREE</e>) dla polecenia
  <c>doins</c>.</ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>FIXME Ustawia opcje do uruchomienia polecenia <c>doins</c>.</ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Ustawia katalog docelowy (<path>DESTTREE</path>) dla wszystkich poleceñ 'do'
    (czyli <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>,
    <c>domo</c>, <c>dosbin</c>).
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>FIXME Ustawia opcje do uruchomienia polecenia <c>dolib</c>.</ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dobin</c>, instaluj±cy podany plik binarny,
    automatycznie zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dodoc</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doexe</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doins</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>doman</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Interfejs do polecenia <c>dosbin</c>, instaluj±cy podany plik, automatycznie
    zmieniaj±c jego nazwê na tê podan± w drugim argumencie.
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Uruchamia komendy <c>prepallman</c>, <c>prepallinfo</c> and
    <c>prepallstrip</c>. Upewnia siê tak¿e, ¿e uprawnienia wszystkich bibliotek
    w katalogach <path>/opt/*/lib</path>, <path>/lib</path>,
    <path>/usr/lib</path> i <path>/usr/X11R6/lib</path> pozwalaj± na ich
    wykonywanie. Dodatkowo przemieszcza wszelkie FIXME zb³±kane makra aclocal do
    katalogu <path>/usr/share/aclocal</path>.
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji z katalogu
    <path>/usr/share/doc</path> za pomoc± narzêdzia gzip, automatycznie
    poprawiaj±c wszelkie dowi±zania symboliczne.
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>Rekursywnie kompresuje wszystkie pliki dokumentacji info w katalogu
  <path>/usr/share/info</path>.</ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>Nie dotyczy</ti>
  <ti>
    Rekursywnie kompresuje wszystkie pliki dokumentacji man w katalogach
    <path>/opt/*/man/*</path>, <path>/usr/share/man/*</path>,
    <path>/usr/local/man/*</path>, <path>/usr/X11R6/share/man/*</path>,
    automatycznie poprawiaj±c wszelkie dowi±zania symboliczne.
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</subsection>
</section>
<section>
<title>Zależności paczki</title>
<subsection>
<title>Dlaczego zale¿no¶ci s± wa¿ne</title>
<body>

<p>


Portage is more than just a convenience script that gives you a unified
way to build any one project (program, library) from source.  It will also
fetch and install any necessary dependencies if you take care to specify
these in your ebuild.
</p>

<p>
In the official ebuilds, all dependencies have already been specified,
so when you issue <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage will
insure that all libraries necessary for Mozilla to build and run are
properly installed before Mozilla itself is built.
</p>

<p>
Portage even distinguishes between build-time dependencies and run-time
dependencies. (Caveat: Currently, Portage installs all build-time and run-time
dependencies and leaves it at that. At a later stage, it will be possible to
trim your installation so that only the run-time dependencies are left 
installed).
</p>

</body>
</subsection>
<subsection>
<title>How to Specify Dependencies in Your ebuild Files (a.k.a. DEPEND Atoms)</title>
<body>

<p>
The <c>DEPEND</c> variable inside your <path>foo-x.y.z.ebuild</path> tells 
Portage about which packages are needed to build <path>foo</path>.  The 
<c>RDEPEND</c> variable specifies which packages are needed for <path>foo</path>
to run. You only need to explicitly specify <c>RDEPEND</c>
if the ebuild's runtime dependencies are different than what you specified in
<c>DEPEND</c>; if not specified, <c>RDEPEND</c> will default to your <c>DEPEND</c>
settings. <b>Never</b> set <c>RDEPEND</c> to <c>DEPEND</c> yourself in an ebuild.
</p>

<pre caption="Depend example">
DEPEND="virtual/libc
        sys-libs/zlib"
RDEPEND="virtual/libc"
</pre>

<p>
This tells Portage that to build <path>foo-x.y.z</path>, the packages
<path>virtual/libc</path> (more on  virtuals in a bit) and 
<path>sys-libs/zlib</path> are needed.  It does not say anything about which 
version of glibc or zlib that are needed, which means "anything goes".
</p>

<p>
The "anything goes" is of course a bit scary, and will not work in the general 
case. But for central libraries like glibc, which strives very hard to be 100% 
binary compatible all the time, it actually works. For other libraries, we can 
of course specify version dependencies.
</p>

<pre caption="Version example">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= and = do what you would expect; sys-apps/bar version 1.2 or newer is okay
(this means that sys-apps/bar-2.0 is okay), while sys-apps/baz version 1.0 is 
the only version that is accepted. For more information on the version schema of
packages, see the section above on <uri link="#doc_chap2_sect2">Naming ebuild 
Files</uri>. 
</p>

<p>
Other methods of specifying version dependencies are as follows:
</p>

<pre caption="Specifying version dependencies">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 will select the newest portage revision of qux-1.0.
</p>

<p>
=sys-apps/foo-1.2* will select the newest member of the 1.2 series, but will 
ignore 1.3 and later/earlier series.  That is, foo-1.2.3 and foo-1.2.0 are both
valid, while foo-1.3.3, foo-1.3.0, and foo-1.1.0 are not.
</p>

<p>
!sys-libs/gdbm will prevent this package from being emerged while gdbm is 
already emerged.
</p>

</body>
</subsection>

<subsection>
<title>Important Notes</title>
<body>

<p>
There are many things that go wrong with the DEPEND and RDEPEND
variables. Here are some important points to follow when you write the
dependencies.
</p>

<ul>
  <li>
    <e>Always include the CATEGORY.</e><br />
    For example, use <c>&gt;=x11-libs/gtk+-2</c> and not <c>&gt;=gtk+-2</c>.
  </li>
  <li>
    <e>Do not put an asterisk (*) for &gt;= dependencies.</e><br />
    For example, it should be <c>&gt;=x11-libs/gtk+-2</c> rather than
    <c>&gt;=x11-libs/gtk+-2*</c>.
  </li>
  <li>
    <e>Never depend on a meta-package.</e><br />
    So don't depend on gnome-base/gnome, always depend on the specific
    libraries like libgnome.
  </li>
  <li>
    <e>One dependency per line.</e><br />
    Don't put multiple dependencies on the same line. It makes it ugly to read
    and hard to follow.
  </li>
  <li><e>GTK: Always use =x11-libs/gtk+-1.2* for GTK+1 apps.</e></li>
</ul>

<p>
Additionally, it is important to ensure that all the dependencies are
complete for your package:
</p>

<ul>
  <li>
    <e>Look in configure.in or configure.ac</e><br />
    Look for checks for packages in here. Things to look out for are pkg-config
    checks or AM_* functions that check for a specific version.
  </li>
  <li>
    <e>Look at included .spec files</e><br />
    A good indication of dependencies is to look at the included .spec files
    for relevant deps. However, do not trust them to be the definitive complete
    list of dependencies.
  </li>
  <li>
    <e>Look at the application/library website</e><br />
    Check the application website for possible dependencies that they suggest
    are needed.
  </li>
  <li>
    <e>Read the README and INSTALL for the package</e><br />
    They usually also contain useful information about building and installing
    packages.
  </li>
  <li>
    <e>Remember non-binary dependencies such as pkg-config, doc generation
    programs, etc.</e><br />
    Usually the build process requires some dependencies such as intltool,
    libtool, pkg-config, doxygen, scrollkeeper, gtk-doc, etc. Make sure those
    are clearly stated.
  </li>
</ul>

<p>
For all the latest details about these DEPEND Atoms, please see the section 5 
manpage on ebuilds: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Testing and deploying</title>
<subsection>
<title>ChangeLog</title>
<body>

<p>
Whenever you update (or write a new) an ebuild, you must also update its (or
create a new) ChangeLog.  The <path>skel.ChangeLog</path> contains a sample
ChangeLog that you can use as a basis.
</p>

<p>
The purpose of the ChangeLog is to document <e>what</e> is being done, 
<e>why</e> it is being done, and by <e>whom</e>.  This allows both 
developers and users to trace the changes made in an easy way.
</p>

<p>
The ChangeLog is primarily targeted at users, so be sure to keep your
writing short, to the point, and avoid getting verbose about the internal
technical details.
</p>

</body>
</subsection>

<subsection>
<title>Storing your own ebuilds locally</title>
<body>

<p>
In order to be able to test your ebuilds and let Portage know about them, you 
must place those in a known directory.  Portage will use the 
<c>PORTDIR_OVERLAY</c> variable which you can define in 
<path>/etc/make.conf</path>.  You should set this variable to your directory 
(e.g. <path>/usr/local/portage</path>).
</p>

<p>
In that directory, you must use the same structure (and categories) as in 
<path>/usr/portage</path>. 
</p>

<p>
Using this <c>PORTDIR_OVERLAY</c>, your ebuilds remain on your system, even
after an <c>emerge sync</c>, and they are still known to Portage.
</p>

</body>
</subsection>

<subsection>
<title>Testing the package</title>
<body>

<p>
Have a think about how you will test whether this package
works. Sometimes the developers have already included a <c>make test</c> or
<c>make check</c> routine that will test the basic functionality of the
package. If so, then running <c>env FEATURES=maketest ebuild <path>foo-x.y.z.ebuild</path>
test</c> will execute it. If it is broken try to fix it so that it works
(and submit the patch to the upstream developers).
</p>

<p>
If this is not the case consider adding a <c>src_test</c> routine to
your ebuild. This is executed before the <c>src_install</c> routine
and can be very helpful for testing the program works across various
architectures. The architecture developers will appreciate if you add
a routine here so that they do not require knowledge of the package's
functionality.
</p>

<p>
Please keep in mind the general requirements of an ebuild here. The
<c>src_test</c> routine must not be interactive. If the test routine
depends on other packages use the <c>maketest</c> USE flag to specify the
optional compile time <c>DEPEND</c>ancies. Also, please note that <c>src_test</c>
routines are not recommended for graphical X applications as the
user running portage often cannot run them successfully.
</p>

</body>
</subsection>

<subsection>
<title>Useful testing tools</title>
<body>

<p>
We have a few useful tools to help you with writing and maintaining your 
ebuilds.
</p>

<table>
<tr>
  <th>Tool</th>
  <th>Package</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Developer-only tool to assist with the CVS checkin procedure.  It does a 
    lot of common QA and tries to make sure that files added to cvs will not 
    break the portage tree.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Tool that keeps pre-processed files so that recompilation gets done 
    <e>much</e> faster.  Be sure to add <c>ccache</c> to the <c>FEATURES</c> 
    variable in <path>/etc/make.conf</path>!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Launch a shell that creates a sandbox environment.  Useful for entering the
    same environment that portage builds packages inside of and debugging 
    things by hand.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>Can create a new ChangeLog or add an entry to an existing one.</ti>
</tr>
</table>

</body>
</subsection>
</section>
</sections>
