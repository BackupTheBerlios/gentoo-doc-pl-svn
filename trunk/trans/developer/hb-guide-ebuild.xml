<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- This document was last synched to:
     cvs://gentoo/gentoo/xml/htdocs/doc/en/gentoo-howto.xml :: R1.50.
-->

<sections>

<date>2005-07-02</date>

<section>
<title>Drzewo Portage</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Drzewo Portage zwykle znajduje się w katalogu <path>/usr/portage</path> i jest
ułożone w hierarchicznej strukturze, składającej się z katalogów kategorii, w
których znajdują się katalogi paczek. Oto przykład: plik 
<path>util-linux-2.11y.ebuild</path> można znaleźć w katalogu 
<path>/usr/portage/sys-apps/util-linux</path>. W tym samym katalogu może
znajdować się kilka innych wersji <c>util-linux</c> razem z wersją 
<path>util-linux-2.11y.ebuild</path>. Jest tak ponieważ <e>wszystkie pliki
ebuild danej paczki (niezależnie od wersji)</e> mają wspólny katalog 
<path>kategoria/paczka</path> w głównym katalogu <path>/usr/portage</path>.
</p>

</body>
</subsection>

<subsection>
<title>Pobieranie drzewa Portage z CVS</title>
<body>

<p>
W razie jakichkolwiek wątpliwości co do systemu CVS, należy przeczytać <uri 
link="http://www.gentoo.org/doc/en/cvs-tutorial.xml">Samouczek CVS</uri>, gdzie
znajdziemy więcej informacji.
</p>

<p>
Drzewo Portage można znaleźć w module <c>gentoo-x86</c> drzewa systemu Gentoo
Linux. Aby pobrać moduł (około 350 megabajtów) najpierw należy skonfigurować CVS
za pomocą powyższego samouczka, a następnie pobrać moduł <c>gentoo-x86</c>
komendą checkout.
</p>

</body>
</subsection>

<subsection>
<title>Co umieszczać (a czego nie) w drzewie Portage</title>
<body>

<p>
Przed napisaniem jakiegokolwiek ebuilda powinniśmy przejrzeć <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri> w poszukiwaniu
niezamieszczonego jeszcze w drzewie Portage pliku ebuild do paczki, do której
sami chcieliśmy go pisać. W tym celu należy wejść na stronę <uri
link="http://bugs.gentoo.org/">bugs.gentoo.org</uri>, wybrać "query", jako
produkt (product) wybrać <e>Gentoo Linux</e>, jako składnik (component)
<e>ebuilds</e>. W polu tekstowym powinniśmy wpisać nazwę ebuilda, a jako status
wybrać "NEW", "ASSIGNED", "REOPENED" i "RESOLVED" (to ostatnie jest ważne), a
następnie zatwierdzić zapytanie. Leniwi niech po prostu klikną <uri
link="http://bugs.gentoo.org/query.cgi?product=Gentoo%20Linux&amp;component=Ebuilds&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED">tutaj</uri>.
</p>

<p>
Drzewo Portage powinno przede wszytkim być używane do przechowywania plików
<path>.ebuild</path>, a także wszelkich względnie małych plików
pomocniczych, takich jak łatki lub przykładowe pliki konfiguracyjne. Pliki
pomocniczne powinny być umieszczane w katalogu
<path>/usr/portage/kategoria/paczka/files</path>, aby nie zaśmiecać głównego
katalogu <path>kategoria/paczka</path>. Wyjątkiem od tej reguły są większe 
pliki łatek (zalecamy przyjąć granicę przy 20KB), które powinny zostać
umieszczone na serwerach lustrzanych Gentoo, aby użytkownicy nie marnowali
przepustowości ani przestrzeni dyskowej. Odradzamy też deweloperom umieszczanie
w CVS plików binarnych (nie-ASCII). Jeśli jednak jest to konieczne (gdybyśmy na
przykład chcieli zamieścić niewielki plik graficzny PNG), należy dodać go do CVS
przy użyciu opcji <c>-kb</c>, tak jak poniżej:
</p>

<pre caption="Dodawanie pliku binarnego do CVS">
# <i>cvs add -kb mojobrazek.png</i>
</pre>

<p>
Opcja <c>-kb</c> instruuje CVS, iż plik <path>mojobrazek.png</path> to plik
binarny i powinien być specjalnie traktowany. Nie powinno się na przykład z
oczywistych względów pozwolić na łączenie różnic między dwiema wersjami tego
pliku. Skoro już mowa o łączeniu zmian, pliki poprawek zamieszczane w Portage
nie powinny być kompresowane. Dzięki temu system CVS będzie mógł łączyć zmiany i
poprawnie informować deweloperów o konfliktach.
</p>

<p>
Należy pamiętać, iż paczki, które FIXME (zatwierdzamy?) wrzucamy muszą być
<e>gotowe</e> do <e>natychmiastowego użycia</e> przez końcowych użytkowników,
jeśli zgłaszamy je jako stabilne. Musimy upewnić się, że posiadamy dobry zestaw
domyślnych ustawień, który zadowoli większość systemów i użytkowników naszej
paczki. Jeśli zaś nasza paczka nie działa i nie mamy pomysłu jak sprawić, by
działała, warto zajrzeć jak poradzili sobie z nią deweloperzy innych
dystrybucji. Przykładów możemy szukać choćby w repozytoriach <uri
link="http://cvs.mandriva.com/cgi-bin/cvsweb.cgi/SPECS/">Mandrivy</uri>, <uri
link="http://www.debian.org/distrib/packages">Debiana</uri> lub <uri
link="http://cvs.fedora.redhat.com/">Fedory</uri>.
</p>

<p>
FIXME (zatwierdzając?) Zamieszczając pliki ebuild w CVS wszyscy deweloperzy
powinni używać polecenia <c>repoman commit</c> zamiast <c>cvs commit</c>. Przed
samym zamieszczeniem należy wykonać polecenie <c>repoman full</c>, aby upewnić
się, że o niczym nie zapominamy.
</p>

</body>
</subsection>

<subsection>
<title>Polityka FIXME (zatwierdzania [commit]?) zamieszczania w CVS</title>
<body>

<ul>
<li>Zawsze należy wykonać polecenie <c>repoman scan</c> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze należy wykonać polecenie <c>repoman full</c> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze powinniśmy sprawdzić poprawność pliku <path>package.mask</path> przez
wykonanie <c>emerge --pretend mypkg</c> przed zatwierdzeniem i sprawdzenie czy
nie zawiera konfliktów.</li>
<li>Zawsze należy uaktualnić plik <path>ChangeLog</path> zanim dokonamy
zatwierdzenia.</li>
<li>Zawsze powinniśmy zatwierdzić uaktualniony plik <path>package.mask</path>
przed uaktualnioną paczką, w razie gdyby wystąpiły konflikty podczas
zatwierdzania pliku <path>package.mask</path>.</li>
<li>Zawsze powinniśmy wykonywać zatwierdzenia atomowe; jeśli zatwierdzamy paczkę
z nową licencją albo taką, która jest zamaskowana, najpierw należy zatwierdzić
uaktualniony plik <path>package.mask</path> i/lub licencję, następnie plik
ebuild, <path>ChangeLog</path>, łatki i plik <uri
link="?part=2&amp;chap=4">metadata.xml</uri> wszystkie za jednym razem, aby
uniknąć uszkodzenia użytkownikom systemów.
</ul>

</body>
</subsection>

<subsection>
<title>Katalog files</title>
<body>

<p>
Jak wpomniano wcześniej, w każdym podkatalogu paczki znajduje się podkatalog
<path>files/</path>. W nim należy umieszczać wszelkie łatki, pliki
konfiguracyjne lub inne pliki pomocnicze; pliki większe niż około 20KB powinny
być zamieszczane na serwerach lustrzanych, aby zmniejszyć ilość (niepotrzebnych)
plików, które nasi użytkownicy będą musieli ściągnąć. Warto rozważyć nazywanie
tworzonych przez siebie poprawek, dzięki którym paczka w ogóle się zbuduje,
uwzględniając wersję w nazwie, na przykład <path>paczka-1.0-gentoo.diff</path>,
or more simply, <path>1.0-gentoo.diff</path>. Przy okazji człon
<path>gentoo</path> informuje że poprawka ta została stworzona przez nas,
deweloperów Gentoo, a nie pobrana z listy dyskusyjnej albo innego miejsca. Raz
jeszcze, nie należy kompresować tych plików, ponieważ CVS nie radzi sobie zbyt
dobrze z binarnymi plikami.
</p>

<p>
Warto rozważyć dodawanie przedrostka lub przyrostka (na przykład
<path>mypkg-1.0</path>) do wszystkich plików, które umieszczamy w katalogu
<path>files/</path>, aby pliki wykorzystywane z konkretną wersją ebuilda można
było łatwo odróżnić od siebie, co powoduje też widoczność zmian pomiędzy każdą
poprawką. Ogólnie jest to dobry pomysł. :) Możemy użyć innego przyrostka, jeśli
chcemy, aby nazwa pliku łatki przekazywała więcej informacji.
</p>

<p>
Jeśli w katalogu <path>files/</path> chcemy umieścić więcej plików, warto
stworzyć podkatalogi, na przykład <path>files/1.0/</path> i umieszczać
odpowiednie pliki w swoich własnych katalogach. Gdy używamy tej metody, nie jest
już konieczne dodawanie informacji o wersji do nazw plików. Często jest to
więc bardziej wygodne.
</p>

</body>
</subsection>
</section>

<section>
<title>Skrypty ebuild</title>
<subsection>
<title>Wprowadzenie</title>
<body>

<p>
Skrypty ebuild są podstawą całego systemu portage. Zawierają one wszelkie
informacje potrzebne do pobrania, rozpakowania, skompilowania i instalacji
zestawu źródeł, a także wykonania ewentualnych czynności poprzedzających i/lub
następujących po instalacji i/lub deinstalacji. Pomimo iż większość Portage
napisana jest w języku Python, same skrypty ebuild napisane są w bashu, ponieważ
wykorzystanie języka skryptowego powłoki pozwala nam na wykonywanie komend tak
samo jak z wiersza poleceń. Jednym z najważniejszych założeń projektowych
skryptów ebuild jest nazwanie zawartych w nim poleceń analogicznie do tych,
które wypisywalibyśmy, instalując paczkę ręcznie poprzez wiersz poleceń. Również
z tego względu użycie składni basha jest bardzo wskazane.
</p>

<p>
Skrypty ebuild są interpretowane przez komendy <c>ebuild</c> i <c>emerge</c>.
Wyobraźmy sobie polecenie <c>ebuild</c> jako niskopoziomowe narzędzie, służące
do budowania. Potrafi zbudować i zainstalować pojedynczy ebuild, ale nic poza
tym. Sprawdzi czy zależności są spełnione, ale nie będzie próbować ich
automatycznie spełnić. Z drugiej strony polecenie <c>emerge</c> jest
wysokopoziomowym "silnikiem" dla polecenia <c>ebuild</c> i potrafi w razie
potrzeby automatycznie zainstalować zależności, wykonać instalacje symulowane
<e>pretend</e>, aby użytkownik mógł dowiedzieć się jakie paczki zostaną
zainstalowane i dużo więcej. Ogólnie polecenie <c>emerge</c> jest lepsze od
<c>ebuild</c> pod każdym względem oprócz jednego. Za pomocą <c>ebuild</c> możemy
stopniowo i pojedynczo wykonywać poszczególne fazy instalacji paczki (pobieranie
źródeł, rozpakowanie, kompilacja, instalacja i osadzenie paczki w systemie).
Jest to nieocenione narzędzie do debugowania dla deweloperów, ponieważ umożliwia
zawężenie problemu z ebuildem do konkretnego fragmentu pliku ebuild.
</p>

</body>
</subsection>
<subsection>
<title>Nazewnictwo plików ebuild</title>
<body>

<p>Nazwa pliku ebuild składa się z czterech logicznych podsekcji:</p>

<p><c>pkg-ver{_suf{#}}{-r#}.ebuild</c></p>

<note>
FIXME "Wąsy" (<c>{}</c>) otaczają opcjonalne pola i same nie występują w nazwie
paczki. Znak "<c>#</c> oznacza dowolną dodatnią liczbę różną od zera.
</note>

<p>
Pierwsza podsekcja, <c>pkg</c> oznacza nazwę paczki. Powinna ona zawierać
jedynie małe litery, cyfry od 0 do 9 oraz dowolną liczbę pojedynczych znaków
myślnika (<c>-</c>), podkreślenia (<c>_</c>) lub znaku plus (<c>+</c>).
Przykłady: <c>util-linux</c>, <c>sysklogd</c> i <c>gtk+</c>. W Portage można
znaleźć kilka paczek, które nie spełniają tych wymogów, ale FIXME (lepiej:
nowe?) <e>nasze</e> paczki muszą je spełniać.
</p>

<p>
Druga podsekcja, <c>ver</c> oznacza wersję paczki, która zwykle powinna
odpowiadać wersji głównego archiwum ze źródłami. Najczęściej wersja składa się z
dwóch lub trzech (czasem więcej) liczb oddzielonych kropkami, na przykład w ten
sposób: <c>1.2</c> lub <c>4.5.2</c>. Czasem bezpośrednio za ostatnią liczbą może
pojawić się pojedyncza litera, na przykład <c>1.4b</c> lub <c>2.6h</c>. Wersja
paczki połączona jest myślnikiem z nazwą paczki. Przykładowo: <c>coś-1.0</c>,
<c>bla-2.4.6</c>.
</p>

<impo>
Chcąc użyć litery poprzedzającej numer wersji należy mieć na uwadze, że <e>nie
powinna</e> ona oznaczać statusu alpha lub beta paczki, ponieważ alpha i beta to
<e>wersje zapoznawcze</e> (ang. prerelease), natomiast wersje z literą na
początku to <e>nowsze wersje</e>. To istotne rozróżnienie, ponieważ Portage
używa numeru wersji ebuilda do określenia czy jest on nowszy czy starszy od
pozostałych paczek o tej samej nazwie w tej samej kategorii. Jest więc bardzo
ważne, aby numery wersji wiernie odzwierciedlały wersję paczki i Portage
właściwie wykonywał sprawdzanie zależności.
</impo>

<p>
Trzecia podsekcja, <c>{_suf{#}}</c> jest opcjonalna i może zawierać jeden z
następujących przyrostków, wymienionych w kolejności od oznaczających najstarsze
wydanie po najnowsze:
</p>

<table>
 <tr><th>Przyrostek</th><th>Znaczenie</th></tr>
 <tr><ti><c>_alpha</c></ti><ti>Wydanie alpha</ti></tr>
 <tr><ti><c>_beta</c></ti><ti>Wydanie beta</ti></tr>
 <tr><ti><c>_pre</c></ti><ti>Wersja zapoznawcza (prerelase)</ti></tr>
 <tr><ti><c>_rc</c></ti><ti>FIXME Testowe wydanie finalne (Release candidate)</ti></tr>
 <tr><ti>(none)</ti><ti>Oficjalne wydanie</ti></tr>
 <tr><ti><c>_p</c></ti><ti>FIXME (patch level) Etap poprawek (zwykle za
 przyrostkiem występuje liczba całkowita)</ti></tr>
</table>

<p> 
Po każdym z tych przyrostków może zostać dodana dodatnia liczba całkowita różna
od zera, na przykład <c>linux-2.4.0_pre10</c>. Zakładając identyczne wersje,
przyrostki są ułożone następująco (niższy oznacza starszy): <c>_alpha</c> &lt;
<c>_beta</c> &lt; <c>_pre</c> &lt; <c>_rc</c> &lt; (brak przyrostka) &lt;
<c>_p</c>.
</p>
       
<p>
Podczas porównywania liczb poprzedzonych identycznymi przyrostkami za nowszą
zostanie uznana większa liczba całkowita. Przykład: <c>bla-1.0_alpha4</c>
jest nowsza niż <c>bla-1.0_alpha3</c>.
</p>

<p>
Czwarta podsekcja nazwy paczki oznacza wewnętrzny numer rewizji 
specyficznej dla systemu Gentoo Linux. Jest on opcjonalny, podobnie jak
przyrostek. Znak <c>#</c> jest dodatnią liczbą całkowitą różną od zera, na
przykład <c>paczka-4.5.3-r3</c>.
</p>

<p>
Numer rewizji jest niezależny od wersji archiwum źródłowego i informuje, iż
dostępna jest nowa i poprawiona wersja danej paczki, specyficzna dla systemu
Gentoo Linux. Pierwsze wydania paczek nie mają numeru rewizji, co oznacza, że
paczkę <c>package-4.5.3</c> Portage potraktuje jak mającą zerowy numer rewizji.
Oznacza to, że paczki zliczane będą w następującej kolejności: <c>1.0</c> (wersja
początkowa), <c>1.0-r1</c>, <c>1.0-r2</c>, itd. 
</p>

<p>
Dokonując niebanalnych zmian w istniejącym pliku ebuild powinniśmy skopiować go
do nowego pliku z numerem rewizji zwiększonym o 1. Należy pamiętać, aby zawsze
odnotowywać zmiany <e>zarówno</e> w pliku <path>ChangeLog</path>, jak i w komunikacie
zatwierdzenia; pominięcie choć jednego jest wbrew FIXME (policy) regułom.
</p>

<p>
...w zasadzie to mamy też <e>piątą</e> sekcję nazwy pliku ebuild -- samo
rozszerzenie <c>.ebuild</c>.
</p>

</body>
</subsection>
<subsection>
<title>Zawartość pliku ebuild</title>
<body>

<p>
W tej części zajmiemy się wprowadzeniem do plików ebuild. Aby zobaczyć listę
wszystkiego, co można w nich zrobić, warto przeczytać stronę podręcznika
systemowego man, gdzie są informacje na temat formatu skryptów ebuild, ich
zmiennych i funkcji: <c>man 5 ebuild</c>.
</p>

<p><b>Nagłówki</b></p>

<p>
Nagłówek FIXME submitowanego pliku ebuild powinien być <e>dokładnie</e> taki sam
jak ten w pliku <path>/usr/portage/header.txt</path>. Nie należy modyfikować go
w żaden sposób, a przede wszytkim upewnić się, że linia zawierająca napis
<c>&#36;Header: &#36;</c> jest nienaruszona.
</p>

<p>
Pierwsze trzy linie powinny wyglądać mniej-więcej tak:
</p>

<pre caption="Poprawny nagłówek">
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# &#36;Header: &#36;
</pre>

<p><b>Zmienne</b></p>

<p>
Pierwsza część każdego pliku ebuild składa się z kilku zmiennych. Dzielą się one
na trzy kategorie wymienione poniżej:
</p>

<ul>
<li>READ: zmiennych tych możemy użyć, ale <e>nie wolno</e> ich ustawiać</li>
<li>MUST: zmienne, które <e>koniecznie należy ustawić</e></li>
<li>OPT: zmienne, które powinniśmy ustawić</li>
</ul>

<table>
<tr>
  <th>Zmienna</th>
  <th>FIXME (Usage) Kateogira</th>
  <th>Opis</th>
</tr>
<tr>
  <ti><c>P</c></ti>
  <ti>READ</ti>
  <ti>Nazwa i wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PN</c></ti>
  <ti>READ</ti>
  <ti>Nazwa paczki.</ti>
</tr>
<tr>
  <ti><c>PV</c></ti>
  <ti>READ</ti>
  <ti>Wersja paczki.</ti>
</tr>
<tr>
  <ti><c>PR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer rewizji lub <c>r0</c>, jeśli numeru tego nie ma.</ti>
</tr>
<tr>
  <ti><c>PVR</c></ti>
  <ti>READ</ti>
  <ti>Zawiera numer wersji razem z numerem rewizji.</ti>
</tr>
<tr>
  <ti><c>PF</c></ti>
  <ti>READ</ti>
  <ti>Zawiera pełną nazwę paczki <c>${PN}-${PVR}</c>.</ti>
</tr>
<tr>
  <ti><c>A</c></ti>
  <ti>READ</ti>
  <ti>
    Rozdzielona spacjami lista nazw plików z <c>SRC_URI</c>. Nie uwzględnia
    ścieżek URL, tylko same nazwy plików.
  </ti>
</tr>
<tr>
  <ti><c>DISTDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Zawiera ścieżkę do katalogu <path>distfiles</path>, w którym zwykle są
    przechowywane wszystkie pobrane pliki paczek. Zwykle jest to ścieżka
    <path>/usr/portage/distfiles</path>.
  </ti>
</tr>
<tr>
  <ti><c>FILESDIR</c></ti>
  <ti>READ</ti>
  <ti>
  Zawiera ścieżkę do podkatalogu <path>files</path> z katalogu danej paczki w
  drzewie portage. Nie wolno modyfikować tej zmiennej.
  </ti>
</tr>
<tr>
  <ti><c>WORKDIR</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny katalogu roboczego danego ebuilda. Nic nie powinno być
    budowane na zewnątrz tego katalogu.
  </ti>
</tr>
<tr>
  <ti><c>S</c></ti>
  <ti>OPT</ti>
  <ti>
    Katalog źródłowy naszej paczki; zwykle jest to <c>${WORKDIR}/${P}</c>.
    Portage przyjmie tę wartość jako domyślną, nie trzeba jej więc ustawiać
    samemu.
  </ti>
</tr>
<tr>
  <ti><c>T</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog tymczasowy na naszą paczkę. Jest on używany jako wirtualny katalog
    <path>/tmp</path> podczas przetwarzania skryptu ebuild.
  </ti>
</tr>
<tr>
  <ti><c>D</c></ti>
  <ti>READ</ti>
  <ti>
    Katalog główny, do którego paczka zostanie zainstalowana. Należy traktować
    go jako wirtualny katalog <path>/</path>.
  </ti>
</tr>
<tr>
  <ti><c>SLOT</c></ti>
  <ti>MUST</ti>
  <ti>
    Portage obsługuje instalowanie jednocześnie różnych wersji tego samego
    programu. Na przykład jeśli chcielibyśmy zainstalować jednocześnie GCC 2.95
    i GCC 3.2, należałoby ustawić zmienną <c>SLOT</c> w każdym pliku ebuild. W
    tym przypadku dla GCC 2.95 ustawilibyśmy zmienną <c>SLOT</c> na <c>2</c>, a
    dla GCC 3.2 na <c>3</c>.
    <br/>
    <b>Uwaga</b>: Podanie <c>0</c> jako wartość zmiennej <c>SLOT</c> oznacza, że
    dana paczka ma tylko jedno możliwe ustawienie <c>SLOT</c> (innymi słowy, nie
    da się jej "SLOTować").
  </ti>
</tr>
<tr>
  <ti><c>LICENSE</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta określa jaką licencją objęty jest program, na przykład GPL-2,
    BSD, itp... Zawartością tej zmiennej musi być poprawna licencja (jest nią
    dowolna licencja z pliku <path>/usr/portage/license/</path>). Jesli danej
    licencji nie ma w tym pliku, musi zostać tam dodana zanim plik ebuild będzie
    mógł być dodany do drzewa portage. Jeśli licencja nie zezwala na
    redystrybucję programu, należy dodać <c>RESTRICT</c>="nomirror" do pliku
    ebuild.
  </ti>
</tr>
<tr>
  <ti><c>KEYWORDS</c></ti>
  <ti>MUST</ti>
  <ti>
    Zmienna ta pełni teraz kilka funkcji. Przede wszystkim określa na jakie
    architektury sprzętowe przeznaczony jest dany ebuild. Przykładowe wartości
    to: <e>x86, ppc, sparc, mips, alpha, arm, hppa, amd64 and ia64</e>. Więcej
    szczegółów można znaleźć w pliku profiles/arch.list. Jak nietrudno się
    domyślić, zmienną tę ustawiamy zgodnie z architekturą docelowej maszyny.
    Portage nie zezwoli maszynie x86 budować paczek innych niż x86, zgodnie z
    tym, co jest podane w zmiennej <c>KEYWORDS</c>. Paczki, które nie wspierają
    FIXME natywnej architektury są automatycznie maskowane przez Portage. Jeśli
    flaga <c>KEYWORDS</c> posiada przedrostek <e>~</e>, oznacza to, że dany
    ebuild działa, ale powinien zostać przetestowany w kilku środowiskach, zanim
    może zostać uznany za stabilny. Jeśli zaś przed flagą <c>KEYWORDS</c>
    występuje znak <e>-</e>, dana paczka nie będzie działać z tym konkretnym
    oznaczeniem. Paczka jest uznawana za stabilną, jeśli nic nie poprzedza
    zmiennych zawartych w <c>KEYWORDS</c>. Ustawiając odpowiednio zmienną
    <c>ACCEPT_KEYWORDS</c> w pliku <path>make.conf</path> definiujemy jakim
    z powyższych typów paczek zezwalamy na instalację.
  </ti>
</tr>
<tr>
  <ti><c>DESCRIPTION</c></ti>
  <ti>MUST</ti>
  <ti><e>Krótki</e>, mieszczący się w jednej linii opis paczki.</ti>
</tr>
<tr>
  <ti><c>SRC_URI</c></ti>
  <ti>MUST</ti>
  <ti>
    URL-e każdego pliku ze źródłami paczki, rozdzielone białym znakiem. W
    zmiennych SRC_URI i S nie powinno się umieszczać numerów wersji. Powinniśmy
    zawsze stosować zmienne ${PV} lub ${P}, a jeśli numer wersji nie pokrywa się z nazwą
    pliku zawierającego źródła, należy stworzyć zmienną ${MY_P} i użyć jej
    zamiast dwóch poprzednich.
  </ti>
</tr>
<tr>
  <ti><c>HOMEPAGE</c></ti>
  <ti>MUST</ti>
  <ti>
    Strona domowa paczki. Jeśli nie możemy znaleźć oficjalnej strony, można
    podać odnośnik z <uri link="http://freshmeat.net/">freshmeat.net</uri>, lub
    podobnej strony z bazą danych programów. Nigdy nie należy odnosić się do
    innej zmiennej wewnątrz tej; musi ona zawierać tylko czysty tekst.
  </ti>
</tr>
<tr>
  <ti><c>IUSE</c></ti>
  <ti>MUST</ti>
  <ti>
    W zmiennej tej zamieszczamy zmienne <c>USE</c>, z jakich korzysta nasza
    paczka. Należy pamiętać, że nie wolno tutaj umieścić <c>KEYWORDS</c>!
  </ti>
</tr>
<tr>
  <ti><c>DEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do zbudowania paczki. Więcej
    informacji na temat składni znajdziemy w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
<tr>
  <ti><c>RDEPEND</c></ti>
  <ti>OPT</ti>
  <ti>
    Tutaj wymieniamy zależności potrzebne do uruchomienia programu z paczki. Jak
    wspomnnieliśmy wyżej, więcej szczegółów można znaleźć w sekcji <uri
    link="#doc_chap5">Zależności paczki</uri>.
  </ti>
</tr>
</table>

<p><b>Funkcje</b></p>

<p>
W plikach ebuild można zdefiniować wiele różnych funkcji, które kontrolują
proces budowania i instalacji naszej paczki.
</p>

<table>
<tr>
  <th>Funkcja</th>
  <th>Zastosowanie</th>
</tr>
<tr>
  <ti><c>pkg_setup</c></ti>
  <ti>
    Funkcja ta służy do wykonywania wszelkich wstępnych czynności. Może to
    obejmować sprawdzenie czy istnieje już plik konfiguracyjny. Jeśli w tym
    miejscu konieczne jest dodanie użytkowników, należy również sprawdzić to 
    w funkcji <c>pkg_preinst()</c> zanim paczka zostanie zainstalowana.
  </ti>
</tr>
<tr>
  <ti><c>pkg_nofetch</c></ti>
  <ti>
    W tym miejscu informujemy użytkownika o tym, co musi zrobić, jeśli z
    jakiegoś powodu (na przykład licencji) źródła nie mogą zostać automatycznie
    pobrane przez Portage. Jednocześnie należy ustawić zmienną
    <c>RESTRICT=&quot;fetch&quot;</c>. W niniejszej funkcji wolno jedynie
    wyświetlać komunikaty, nie należy wywoływać FIXME polecenia <c>die</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_unpack</c></ti>
  <ti>
    Tej funkcji należy użyć, aby rozpakować źródła naszej paczki, nałożyć
    poprawki i uruchomić zewnętrzne programy, na przykład autotools. Domyślnie
    funkcja ta rozpakuje pliki wymienione w zmiennej <c>A</c>. Początkowy
    katalog roboczy definiuje zmienna <c>WORKDIR</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_compile</c></ti>
  <ti>
    Za pomocą tej funkcji konfigurujemy i budujemy paczkę. Początkowy
    katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_install</c></ti>
  <ti>
    Tej funkcji użyjemy, aby zainstalować paczkę w katalogu określonym przez
    zmienną <c>D</c>. Jesli nasza paczka korzysta z automake, możemy tego łatwo
    dokonać poprzez <c>make DESTDIR=${D} install</c>. <e>Należy upewnić się, że
    paczka wszystkie swoje pliki zainstaluje używając <c>D</c> jako katalogu
    głównego!</e> Początkowy katalog roboczy definiuje zmienna <c>S</c>.
  </ti>
</tr>
<tr>
  <ti><c>src_test</c></ti>
  <ti>
    Funkcja ta jest wykonywana tylko wtedy, gdy zmienna
    <c>FEATURES="maketest"</c> jest ustawiona, a zmienna
    <c>RESTRICT="maketest"</c> nie jest ustawiona. Domyślnie wywołuje 
    dostępną funkcję testującą z plików Makefile, znajdujących się w
    katalogu zdefiniowanym przez zmienną <c>${S}</c>, uruchamiając albo "make
    test" albo "make check", w zależności od tego, co jest dostępne. Funkcję tę
    można nadpisać i zaimplementować własną metodę testowania paczki.
  </ti>
</tr>
<tr>
  <ti><c>pkg_preinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed
    zintegrowaniem</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postinst</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po
    zintegrowaniu</e> obrazu paczki z systemem plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_prerm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>przed 
    odinstalowaniem</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_postrm</c></ti>
  <ti>
    Polecenia zawarte w tej funkcji zostaną wykonane tuż <e>po 
    odinstalowaniu</e> obrazu paczki z systemu plików.
  </ti>
</tr>
<tr>
  <ti><c>pkg_config</c></ti>
  <ti>
    Za pomocą tej funkcji możemy przygotować początkową konfigurację paczki tuż
    po jej instalacji. Wszystkie ścieżki w obrębie tej funkcji powinny być
    poprzedzone zmienną <c>ROOT</c>, wskazującą podany przez użytkownika
    katalog instalacji, który niekoniecznie musi być katalogiem <path>/</path>.
    Funkcja ta wykonywana jest <e>tylko i wyłącznie</e> wtedy, gdy użytkownik
    wyda polecenie: <c>ebuild /var/db/pkg/${CATEGORY}/${PF}/${PF}.ebuild config</c>.
  </ti>
</tr>
</table>

<p><b>Funkcje pomocnicze</b></p>

<p>
You can also use the following helper functions in your ebuilds.
</p>

<table>
<tr>
  <th>Function</th>
  <th>Purpose</th>
</tr>
<tr>
  <ti><c>use</c></ti>
  <ti>
    Check if one or more given USE-flags are defined.  If so, the
    function will echo the flags that exist in <c>USE</c>. This
    behaviour will soon change, with <c>use</c> not creating output,
    but <c>usev</c> would still create output. To check the existence
    of a USE-flag, you can use <c>use foobar</c>.
  </ti>
</tr>
<tr>
  <ti><c>has_version</c></ti>
  <ti>
    Returns 1 if the system has the requested version of a certain package.  
    For instance <c>has_version >=sys-libs/glibc-2.3.0</c>.
  </ti>
</tr>
<tr>
  <ti><c>best_version</c></ti>
  <ti>
    Returns <path>category/package-version</path> of the requested 
    <path>category/package</path>. For instance <c>best_version 
    x11-libs/gtk+extra</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_with</c></ti>
  <ti>
    This function checks if a use-flag has been defined and returns 
    &quot;--with-foobar&quot; or &quot;--without-foobar&quot; accordingly.  If 
    you only use one argument, that argument is both use-flag and 
    with(out)-string.  Otherwise the first argument is the use-flag and the 
    second argument the with(out)-string. For instance <c>use_with truetype 
    freetype</c> will echo &quot;--with-freetype&quot; if truetype is in 
    <c>USE</c>.
  </ti>
</tr>
<tr>
  <ti><c>use_enable</c></ti>
  <ti>
    The same as <c>use_with</c>, but returns &quot;--enable-foobar&quot; or 
    &quot;--disable-foobar&quot; accordingly.
  </ti>
</tr>
<tr>
  <ti><c>check_KV</c></ti>
  <ti>
    Checks if Portage knows kernel version.  If not, display an error and 
    die.  If you need the kernel version in your script, use the <c>KV</c> 
    variable which is automatically defined by Portage.  On a system running 
    gentoo-sources-2.4.20-r6, <c>KV</c> would have the value &quot;2.4.20&quot;.
  </ti>
</tr>
<tr>
  <ti><c>keepdir</c></ti>
  <ti>
    Creates (if necessary) a <path>.keep</path> file in the given directory 
    so that it isn't auto-cleaned.  <e>Never</e> create a <path>.keep</path> 
    file yourself.  If portage changes how <c>keepdir</c> works, then creating 
    the file yourself will break the package.
  </ti>
</tr>
<tr>
  <ti><c>econf</c></ti>
  <ti>
    Issues <c>./configure</c> with the necessary path-changes (prefix, host, 
    mandir, infodir, datadir, sysconfdir, localstatedir). You can optionally 
    pass extra arguments to <c>./configure</c> by specifying them when you 
    call <c>econf</c>, and users can set the environment variable 
    <c>EXTRA_ECONF</c> if they need to. Options passed to configure
    take precedence in the reverse order that they were given. In
    other words, the first argument passed will always be overridden
    by the last.
  </ti>
</tr>
<tr>
  <ti><c>einstall</c></ti>
  <ti>
    Issues <c>make install</c> with the necessary path-changes (prefix, datadir,
    mandir, infodir, datadir, sysconfdir, localstatedir).  Again, you can pass 
    extra arguments to the make command by specifying them when you call 
    <c>einstall</c>.  Please note that the preferred way to install a package is
    via the <c>make install DESTDIR=${D}</c> command and not via 
    <c>einstall</c>. This command is only a fall back to override broken make 
    files.
  </ti>
</tr>
<tr>
  <ti><c>die</c></ti>
  <ti>
    Causes the current process to be aborted.  It will notify the user using 
    the given arguments as a reason.  Do not neglect to pass a message to 
    <c>die</c> if you have more than one call to it in a single function.  It 
    is harder to track down a failure if you're not sure <e>where</e> the 
    package failed.
  </ti>
</tr>
<tr>
  <ti><c>einfo</c></ti>
  <ti>
    Inform the user about something important.  The argument given to 
    <c>einfo</c> is the message that the user will see.  Do not use 
    <c>einfo</c> to display banners such as 
    &quot;*************************************&quot;.  The fact that you're 
    using <c>einfo</c> is enough to get the user's attention.
  </ti>
</tr>
</table>

<p><b>Helper Functions provided by eutils.eclass</b></p>

<p>
You can use the following helper functions that are provided by the
"eutils" eclass in your ebuilds. You must make sure that <c>inherit
eutils</c> is present for these functions to work.
</p>

<table>
<tr>
  <th>Function</th>
  <th>Purpose</th>
</tr>
<tr>
  <ti><c>epatch</c></ti>
  <ti>
    This function acts as a friendlier replacement to
    the <c>patch</c> command and epatch works with .bz2, .gz, .zip
    and plain text patches. You do not need to specify a "-p" option,
    any options that do need to be explicitly specified should be set
    in <c>EPATCH_OPTS</c>. The function expects either a file or a
    directory as an argument - if you specify a directory, all
    patches in the form of "??_${ARCH}_..." will be applied: for a
    patch to be applied, it needs to match the running architecture,
    have "_all_" in the name, or <c>EPATCH_FORCE</c> must be set to
    "yes".
  </ti>
</tr>
<tr>
  <ti><c>gen_usr_ldscript</c></ti>
  <ti>
    This function generates linker scripts in /usr/lib for dynamic
    libraries in /lib. This fixes linking problems when a .so is in
    /lib while a .a is in /usr/lib.
  </ti>
</tr>
<tr>
  <ti><c>have_NPTL</c></ti>
  <ti>
    Returns 0 if the system is using the NPTL PThreads
    implementation.
  </ti>
</tr>
<tr>
  <ti><c>get_number_of_jobs</c></ti>
  <ti>
    This function checks how many CPUs are present and then sets the
    correct -jX option in <c>MAKEOPTS</c>.
  </ti>
</tr>
<tr>
  <ti><c>mymktemp</c></ti>
  <ti>
    This function acts as a wrapper to mktemp when it exists, or acts
    as a replacement when it does not.
  </ti>
</tr>
<tr>
  <ti><c>edos2unix</c></ti>
  <ti>
    This function performs the same action as
    the <c>dos2unix</c> binary.
  </ti>
</tr>
<tr>
  <ti><c>egetent</c></ti>
  <ti>
    egetent acts as a wrapper for <c>getent</c> for Linux
    or <c>nidump</c> for Mac OS X (R).
  </ti>
</tr>
<tr>
  <ti><c>enewuser</c></ti>
  <ti>
    Creates a new user. This function expects a mandatory argument
    with the username, and several optional arguments can be
    specified: <c>$2</c> contains a UID, pass -1 for the next
    available ID; <c>$3</c> contains a shell
    with <path>/bin/false</path> being the default; <c>$4</c>
    contains a home directory with <path>/dev/null</path> being the
    default, <c>$5</c> contains any groups to which the user should
    be added, empty by default and <c>$6</c> contains a comment - the
    default is "added by portage for <c>${PN}</c>".
  </ti>
</tr>
<tr>
  <ti><c>enewgroup</c></ti>
  <ti>
    Adds a new group. This function expects a mandatory argument with
    the group name - an optional second argument makes the group have
    a specific GID.
  </ti>
</tr>
<tr>
  <ti><c>make_desktop_entry</c></ti>
  <ti>
    Makes a desktop entry: the first argument contains the path to the
    binary. Optionally, the second contains a name for the icon - the
    default is <c>${PN}</c>; the third can contain a path to the icon
    relative to <path>/usr/share/pixmaps</path> or a full path - the
    default is <c>${PN}</c>.png; the fourth can contain an
    <uri link="http://standards.freedesktop.org/menu-spec/latest/apa.html">application
    category</uri>, and the fifth argument contains an optional application
    startup path.
  </ti>
</tr>
<tr>
  <ti><c>check_license</c></ti>
  <ti>
    Displays a license for the user to accept, if no arguments are
    specified then the license specified by <c>${LICENSE}</c> is
    used.
  </ti>
</tr>
<tr>
  <ti><c>unpack_pdv</c></ti>
  <ti>
    Unpacks a pdv generated archive, the first argument must contain
    the file to unpack and the second should contain "off_t" which
    has to be manually generated: <c>strace -elseek ${file}</c> and
    for something like "lseek(3, -4, SEEK_END)" you would pass the
    value "4".
  </ti>
</tr>
<tr>
  <ti><c>unpack_makeself</c></ti>
  <ti>
    Unpacks a makeself generated archive, requires a file to unpack
    as the argument.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_get_cds</c></ti>
  <ti>
    Attempts to get a CD, present with files specified by the
    arguments present on the system and mounted at <c>${CDROM_ROOT}</c>.
  </ti>
</tr>
<tr>
  <ti><c>cdrom_load_next_cd</c></ti>
  <ti>
    Loads the next CD once you are done with the first CD. If the
    function returns, <c>${CDROM_ROOT}</c> would point to the next CD.
  </ti>
</tr>
<tr>
  <ti><c>strip-linguas</c></ti>
  <ti>
    This function makes sure that LINGUAS contains only the languages
    that a package can support specified by the arguments to the
    function. If the first argument is -i, then a list of .po files
    in the specified directories is built and the intersection of the
    lists is used. If the first argument is -u, then a list of .po
    files in the specified directories is built and the union of the
    lists is used.
  </ti>
</tr>
</table>

<p><b>Helper Functions provided by flag-o-matic.eclass</b></p>

<p>
You can use the following helper functions that are provided by the
"flag-o-matic" eclass in your ebuilds. You must make sure that <c>inherit
flag-o-matic</c> is present for these functions to work. You should never
modify any compiler settings directly, instead please use flag-o-matic to
perform any actions such as filtering flags that cause trouble.
</p>

<table>
<tr>
  <th>Function</th>
  <th>Purpose</th>
</tr>
<tr>
  <ti><c>filter-flags</c></ti>
  <ti>
    This function removes particular flags from <c>C[XX]FLAGS</c> -
    only complete flags are matched.
  </ti>
</tr>
<tr>
  <ti><c>append-flags</c></ti>
  <ti>
    This function adds extra flags to the existing <c>C[XX]FLAGS</c>
    variables.
  </ti>
</tr>
<tr>
  <ti><c>replace-flags</c></ti>
  <ti>
    This replaces the flag specified by the first argument with the
    one in the second argument in the current <c>C[XX]FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>replace-cpu-flags</c></ti>
  <ti>
    This replaces any -march=... or -mcpu=... flags that contain the
    second argument with the first.
  </ti>
</tr>
<tr>
  <ti><c>replace-sparc64-flags</c></ti>
  <ti>
    This sets -mcpu=... to a v8 SPARC and uses the original value as
    -mtune if one is not already specified.
  </ti>
</tr>
<tr>
  <ti><c>strip-flags</c></ti>
  <ti>
    Strips all flags, except those specified in <c>ALLOWED_FLAGS</c>.
  </ti>
</tr>
<tr>
  <ti><c>strip-unsupported-flags</c></ti>
  <ti>
    Strips <c>C[XX]FLAGS</c> of any flags not supported by the running
    version of GCC.
  </ti>
</tr>
<tr>
  <ti><c>get-flag</c></ti>
  <ti>
    Finds a flag and outputs its value.
  </ti>
</tr>
<tr>
  <ti><c>is-flag</c></ti>
  <ti>
    This returns true if the flag is set in the
    current <c>C[XX]FLAGS</c>; only complete matches are performed.
  </ti>
</tr>
<tr>
  <ti><c>append-ldflags</c></ti>
  <ti>
    This function adds extra flags to the existing <c>LDFLAGS</c>
    variable.
  </ti>
</tr>
<tr>
  <ti><c>filter-ldflags</c></ti>
  <ti>
    Removes the specified flags from <c>LDFLAGS</c>, only complete
    flags are matched.
  </ti>
</tr>
<tr>
  <ti><c>fstack-flags</c></ti>
  <ti>
    Appends -fno-stack-protector which suppresses -fstack-protector
    and -fstack-protector-all.
  </ti>
</tr>
</table>



<p>
You can use the following helper functions that are provided by the
&quot;toolchain-funcs&quot; eclass in your ebuilds. You must make sure that <c>inherit
toolchain-funcs</c> is present for these functions to work. You should never
explicitly specify any compiler or binutils settings directly, instead please use toolchain-funcs to
specify compilers and binutils.
</p>
<p>
The purpose of using the below functions is to support cross-compiling and the
icc compiler. These should be used whenever a package explicitly uses gcc, g++,
ld, ranlib or any of the below tools. In general packages that use autoconfiguration tools
detect cross compiling automaticaly and do not need the following functions.
</p>
  <table>
    <tr>
      <th>Function</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <ti>
        <c>tc-getAR</c>
      </ti>
      <ti>Returns the name of the archiver
  </ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getAS</c>
      </ti>
      <ti>Returns the name of the assembler</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCC</c>
      </ti>
      <ti>Returns the name of the C compiler</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getCXX</c>
      </ti>
      <ti>Returns the name of the C++ compiler</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>Returns the name of the linker</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getNM</c>
      </ti>
      <ti>Returns the name of the symbol/object inspection tool</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getRANLIB</c>
      </ti>
      <ti>Returns the name of the archiver indexer</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getF77</c>
      </ti>
      <ti>Returns the name of the fortran compiler
  </ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getLD</c>
      </ti>
      <ti>Returns the name of the linker</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getGCJ</c>
      </ti>
      <ti>Returns the name of the java compiler</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-getBUILD_CC</c>
      </ti>
      <ti>Returns the name of the C compiler for build</ti>
    </tr>
    <tr>
      <ti>
        <c>tc-is-cross-compiler</c>
      </ti>
      <ti>A simple way to see if we're using a cross-compiler</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-fullversion</c>
      </ti>
      <ti>
   Returns the version as by $($CC -dumpversion)</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-version</c>
      </ti>
      <ti>Returns the version, but only the &lt;major>.&lt;minor></ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-major-version</c>
      </ti>
      <ti>Returns the Major version</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-minor-version</c>
      </ti>
      <ti>Returns the Minor version</ti>
    </tr>
    <tr>
      <ti>
        <c>gcc-micro-version</c>
      </ti>
      <ti>Returns the Micro version</ti>
    </tr>
  </table>


</body>
</subsection>

<subsection>
<title>Rules for writing an ebuild file</title>
<body>

<p>
Since ebuild files are really just shell scripts, you should
use your editor's shell-script mode for editing them.  You should use
proper indentation, using only tab characters -- <e>no spaces</e>.  Make sure
you set up your editor to put tab stops at 4 spaces.  Always make sure
you use braces around your environment variables; e.g. <c>${P}</c>
instead of just <c>$P</c>.
</p>

<p>
Long lines are wrapped with ' \', thus:
</p>

<pre caption="Wrapping lines in ebuilds">
./configure \
--prefix=/usr || die "configure failed"
</pre>

<p>
For further details, refer to <path>skel.ebuild</path> (usually 
residing in <path>/usr/portage</path>).
</p>

<p>
If you use Vim for ebuild/eclass editing, the default Gentoo vimrc
file, <path>/etc/vim/vimrc</path>, already ensures that correct
indentation and filetype settings are used for ebuild and eclass
files. For better results, including special syntax highlighting for
ebuild keywords, emerge app-vim/gentoo-syntax.
</p>

<p>
On non-Gentoo systems, you can obtain similar results by using the
following lines in your vimrc, or better yet by installing the
<uri link="https://developer.berlios.de/projects/gentoo-syntax/">gentoo-syntax
</uri> scripts.
</p>

<pre caption="Configuring vimrc for ebuild-editing">
au BufRead,BufNewFile *.e{build,class} let is_bash=1|setfiletype sh
au BufRead,BufNewFile *.e{build,class} set ts=4 sw=4 noexpandtab
</pre>

<p>
If you're using Emacs, you can put the following snippet at the bottom of 
.emacsrc file (for GNU Emacs) or init.el (for XEmacs) to make sure your using 
the correct settings when editing anything Gentoo-related.
</p>

<pre caption="Configuring emacsrc for ebuild-editing">
(defun ebuild-mode ()
  (shell-script-mode)
  (sh-set-shell "bash")
  (make-local-variable 'tab-width)
  (setq tab-width 4))
(setq auto-mode-alist (cons '("\\.ebuild$" . ebuild-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.eclass$" . ebuild-mode) auto-mode-alist))
</pre>

<p>
If you're using nano, then you're in luck!  Just edit <path>/etc/nanorc</path> 
and uncomment the section referring to ebuild's.
</p>

</body>
</subsection>
<subsection>
<title>USE Variables</title>
<body>

<p>
The purpose of USE variables is to allow you to configure Portage to globally
and automatically enable or disable certain <e>optional build-time</e>
features.  Here's an example.  Let's say you're a GNOME fan, and you'd like any
ebuild that has the option of compiling-in optional GNOME support to do
so.  In this case, you'd add <c>gnome</c> to the <c>USE</c> variable in
<path>/etc/make.conf</path>, and then Portage will automatically add optional
GNOME functionality to packages if it is available.  Likewise, if you don't
want optional GNOME features to be added to your ebuilds if they are available,
simply edit <path>/etc/make.conf</path> and make sure that <c>gnome</c> is
<e>not</e> set in the <c>USE</c> variable.  Gentoo Linux has an almost
overwhelming number of USE options, allowing you to have your system configured
exactly the way you want it.
</p>

<note>
If you unset a USE variable (for example, removing <c>gnome</c> from
<c>USE</c>), this will only instruct Portage to disable <e>optional</e>
build-time support for GNOME.  However, if you <c>emerge</c> an ebuild that
<e>requires</e> GNOME, the package will obviously have GNOME support enabled, 
as you would expect.  This also means that GNOME will be automatically 
installed (as a dependency) if it hasn't been already.  That's why it's always 
a good idea to do an <c>emerge --pretend</c> before doing the &quot;real&quot; 
<c>emerge</c>; that way, you'll always know exactly what you're going to get!
</note>

<p>
In your own ebuilds, you can check whether a USE variable is set by using the 
<c>use &lt;variable&gt;</c> command.  The <c>use</c> command prints out 
<c>&lt;variable&gt;</c> if it is present in the user's <c>USE</c>.  You would 
normally use this command as follows:
</p>

<pre caption="Finding out if a USE-flag is set">
if use X; then
  # Commands specific to X...
fi
</pre>

<p>
USE variables can also be used to set dependencies. For example, you
may only want to require a package if a certain USE variable is set.
This is done by using the syntax <c>flag? ( mycat/mypackage )</c> in
the <c>DEPEND</c> variable for your ebuild.  In this
example, <c>mycat/mypackage</c> will only be required if <c>flag</c>
is present in <c>USE</c>. It is also possible to specify what
dependency should be used if some USE flag <e>is</e> set, and what
dependency to use if it is <e>not</e> set: <c>flag? (
mycat/mypackage)</c> and <c>!flag? ( othercat/otherpackage )</c>.  In
this case, if <c>flag</c> is not set, <c>othercat/otherpackage</c> is
used instead of <c>mycat/mypackage</c>. Make sure that your ebuilds
use this syntax and not Bash IFS.  Bash conditionals interfere with
Portage's dependency caching, and the use of them will break your
ebuild.
</p>

<p>
Here's an important tip about how to use <c>USE</c>. Most of the time,
a package will have a <c>./configure</c> script used to perform configuration
steps. Generally, if your ebuild uses <c>./configure</c>, any optional 
build-time functionality will be enabled or disabled by passing the appropriate
arguments to the <c>./configure</c> command.  Here's the best way to handle 
this:
</p>

<pre caption="Conditionals based on USE-settings">
DEPEND="X? ( &gt;=x11-base/xfree-4.3 )
mysql? ( &gt;=dev-db/mysql-3.23.49 )
apache2? ( &gt;=net-www/apache-2 )
!apache2? ( =net-www/apache-1* )"

src_compile() {
  econf \
    $(use_enable X x11) \
    $(use_enable mysql) \
    || die "Error: econf failed!"
  emake || die "Error: emake failed!"
}
</pre>

<p>
This approach has a very nice result.  We don't have to worry about what the 
default setting is for mysql or X (enable/disabled), we explicitly tell 
<c>econf</c> what we want it to do based upon the <c>USE</c> variable.  Not to 
mention it's quite clean in terms of readability :).
</p>

<p>
To view a continuously updated table of USE variables, please go
<uri link="http://www.gentoo.org/dyn/use-index.xml">here</uri>.
</p>

</body>
</subsection>
</section>
<section>
<title>File system Locations</title>
<subsection>
<title>Introduction to the FHS</title>
<body>

<p>
The file system layout standards used in Gentoo Linux closely follow the FHS,
short for <e>File system Hierarchy Standard</e>.  A simplified
description of the standard is given here; for a complete
specification go to <uri>http://www.pathname.com/fhs/</uri>.
</p>

<note>
The <path>/opt</path> hierarchy is addressed in section 3.12 of the FHS.
Section 4.4 deals with the <path>/usr/X11R6</path> directory.  KDE and GNOME are
not specifically addressed, and are in fact not even mentioned in the current
version of the FHS.
</note>

</body>
</subsection>
<subsection>
<title>How to fit your packages into the file system</title>
<body>

<p>
Usually, if the package uses autoconf and automake, the 
default installation destinations are mostly correct, with a few exceptions:
</p>

<ul>
<li>
If you're installing a program into <path>/bin</path>, <path>/sbin</path>,
<path>/usr/bin</path>, or <path>/usr/sbin</path>, then the program's
corresponding man page should be installed into the <path>/usr/share/man</path>
tree.  This can often be accomplished by specifying a <c>./configure
--mandir=/usr/share/man</c> in the ebuild.
</li>
<li>
GNU info files should always be installed to <path>/usr/share/info</path>,
<e>even if the info files are about X11, GNOME or KDE-specific programs or
tools</e>.  Make a note: <path>/usr/share/info</path> is the <e>only</e>
official location for GNU info files.  Since many <c>./configure</c> scripts
default to installing GNU info files in <c>/usr/info</c>, it's often necessary
to call <c>./configure</c> with the <c>--infodir=/usr/share/info</c> argument.
</li>
<li>
Documentation files are installed in <path>/usr/share/doc</path>, into a
subdirectory reflecting the name, version, and revision of the particular
program.  This applies to all programs: GNOME, KDE, X11 and console alike.  
However, some programs may install additional documentation and support files
into a <path>/usr/share</path> hierarchy for their own purposes.
</li>
<li>
X11-specific programs and libraries should always be installed into 
<path>/usr</path>, not directly into <path>/usr/X11R6</path>.  We reserve the 
<path>/usr/X11R6</path> hierarchy for the X Window System, Version 11 Release 6 
<e>itself</e>.  This is perhaps a more to-the-letter interpretation of the FHS 
than some other distributions have made.
</li>
<li>
GNOME and KDE programs, similarly, should always be installed into 
<path>/usr</path>.
</li>
</ul>

<impo>
Some distributions choose to install GNOME and KDE into <path>/opt</path>. There
exists no standard for these desktop environments in terms of where to actually
install their files. In the interests of simplicity and consistency, we elect to
install all KDE and GNOME packages into the <path>/usr</path> hierarchy.
</impo>

<p>
In general, you should have ebuilds install their files into the 
<path>/usr</path> tree.  <e>Some</e> programs can be compiled and linked with 
or without GNOME, KDE, and X11 libraries, which can cause confusion.  Our 
solution is to install everything into <path>/usr</path> which avoids ambiguity 
and needless complexity for ebuild authors.  The location in which to install 
a program's files should <e>not</e> depend on the presence or absence of 
specific <c>USE</c> variables.  Therefore, the ebuilds in the portage tree 
<e>almost always</e> install into the <path>/usr</path> hierarchy exclusively.
</p>

<note>
The <path>/opt</path> directory is reserved in Gentoo Linux for binary-only 
packages. Examples include mozilla-bin, acroread, netscape and realplayer.  
Packages that get installed here will usually require a 
<path>/etc/env.d/foo</path> stub file.  This is so that paths and additional 
variables can be included into the environment.  For more information on 
<path>/etc/env.d</path>, please visit <uri 
link="/doc/en/handbook/handbook-x86.xml?part=2&amp;chap=5">this</uri>
document.
</note>

</body>
</subsection>
</section>
<section>
<title>The Portage scripts and utilities</title>
<subsection>
<title>Public scripts</title>
<body>

<p>
These are scripts used by the system-administrator to install and remove 
packages, and maintain the package database.
</p>

<p>
<c>ebuild</c> is the main engine of the Portage system; it performs all major 
tasks such as unpacking, compiling, installing, merging, and unmerging 
packages.  It is called using the command: <c>ebuild path/to/package.ebuild
command</c>.  The commands available are:
</p>

<table>
<tr>
  <th>Command</th>
  <th>Description</th>
  <th>Related <c>ebuild</c> Function</th>
</tr>
<tr>
  <ti><c>setup</c>*</ti>
  <ti>
    Performs any miscellaneous commands required before the ebuild can proceed
  </ti>
  <ti><c>pkg_setup</c></ti>
</tr>
<tr>
  <ti><c>depend</c></ti>
  <ti>Displays the dependencies required to build the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>merge</c>*</ti>
  <ti>
    Unpacks, compiles, installs, and merges the package into your file system
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>qmerge</c>*</ti>
  <ti>
    Merges the package into your file system, assuming that the unpack, 
    compile, and install stages have already been executed
  </ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>unpack</c>*</ti>
  <ti>
    Unpacks the source tarballs into the work directory
  </ti>
  <ti><c>src_unpack</c></ti>
</tr>
<tr>
  <ti><c>compile</c>*</ti>
  <ti>Compiles the package</ti>
  <ti><c>src_compile</c></ti>
</tr>
<tr>
  <ti><c>rpm</c></ti>
  <ti>Creates an RPM from the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>package</c></ti>
  <ti>Creates a Gentoo <c>tbz2</c> package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>prerm</c>*</ti>
  <ti>Executes the pre-removal stage of the package</ti>
  <ti><c>pkg_prerm</c></ti>
</tr>
<tr>
  <ti><c>postrm</c>*</ti>
  <ti>Executes the post-removal stage of the package</ti>
  <ti><c>pkg_postrm</c></ti>
</tr>
<tr>
  <ti><c>preinst</c>*</ti>
  <ti>Executes the pre-installation stage of the package</ti>
  <ti><c>pkg_preinst</c></ti>
</tr>
<tr>
  <ti><c>postinst</c>*</ti>
  <ti>Executes the post-installation stage of the package</ti>
  <ti><c>pkg_postinst</c></ti>
</tr>
<tr>
  <ti><c>config</c></ti>
  <ti>Sets up a default configuration once the package is merged</ti>
  <ti><c>pkg_config</c></ti>
</tr>
<tr>
  <ti><c>touch</c>*</ti>
  <ti>Updates the mtimes for each source archive in the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>clean</c>*</ti>
  <ti>Cleans the work directory for the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>fetch</c>*</ti>
  <ti>Fetches the package source tarballs</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>digest</c>*</ti>
  <ti>Creates a digest file for the package</ti>
  <ti>N/A</ti>
</tr>
<tr>
  <ti><c>test</c>*</ti>
  <ti>Runs the self-test routine for the package</ti>
  <ti><c>src_test</c></ti>
</tr>
<tr>
  <ti><c>install</c>*</ti>
  <ti>Installs the package into the image directory</ti>
  <ti><c>src_install</c></ti>
</tr>
<tr>
  <ti><c>unmerge</c></ti>
  <ti>Unmerges the package from your file system</ti>
  <ti>N/A</ti>
</tr>
</table>

<note>
Commands with an asterisk (*) are normally only used by the developer.
</note>

<p>
<c>emerge</c> recursively merges a package and all of its dependencies into 
your file system. This command has many options, try <c>emerge --help</c> for 
a list of them.
</p>

<p>
<c>env-update</c> updates the configuration files (including, but not limited 
to <path>/etc/ld.so.conf</path> and <path>/etc/profile.env</path>) to include 
changes made by installed packages.
</p>

</body>
</subsection>
<subsection>
<title>Private Scripts and Commands</title>
<body>

<p>
These are scripts you can use in your ebuild files to perform common tasks.
</p>

<p>
For you down and dirty people, look at the scripts themselves in 
<path>/usr/lib/portage/bin</path>.
</p>

<table>
<tr>
  <th>Command</th>
  <th>Default Value</th>
  <th>Description</th>
  <th>Example</th>
</tr>
<tr>
  <ti><c>diropts</c></ti>
  <ti>-m0755</ti>
  <ti>Sets the options used when running <c>dodir</c></ti>
  <ti><c>diropts -m0750</c></ti>
</tr>
<tr>
  <ti><c>dobin</c></ti>
  <ti>N/A</ti>
  <ti>Installs the specified binaries into <path>DESTTREE/bin</path></ti>
  <ti><c>dobin wmacpi</c></ti>
</tr>
<tr>
  <ti><c>docinto</c></ti>
  <ti><path>&quot;&quot;</path></ti>
  <ti>
    Sets the relative subdir (<e>DOCDESTTREE</e>) used by <c>dodoc</c> 
  </ti>
  <ti><c>docinto examples</c></ti>
</tr>
<tr>
  <ti><c>dodir</c></ti>
  <ti>N/A</ti>
  <ti>Creates a directory, handling ${D} transparently</ti>
  <ti><c>dodir /usr/lib/newpackage</c></ti>
</tr>
<tr>
  <ti><c>dodoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into the package's documentation directory 
    (<path>/usr/share/doc/${PF}/DOCDESTTREE</path>) (see <c>docinto</c>)
  </ti>
  <ti><c>dodoc README *.txt</c></ti>
</tr>
<tr>
  <ti><c>doexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files with mode <e>EXEOPTIONS</e> (see 
    <c>exeopts</c>) into <path>EXEDESTTREE</path> (see <c>exeinto</c>)
  </ti>
  <ti><c>doexe ${FILESDIR}/quake3</c></ti>
</tr>
<tr>
  <ti><c>dohard</c></ti>
  <ti>N/A</ti>
  <ti>Creates a hard link, handling ${D} transparently</ti>
  <ti><c>dohard ls /bin/dir</c></ti>
</tr>
<tr>
  <ti><c>dohtml</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files and directories into 
    <path>/usr/share/doc/${PF}/html</path> 
  </ti>
  <ti><c>dohtml -r doc/html/*</c></ti>
</tr>
<tr>
  <ti><c>doinfo</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into /usr/share/info, then compresses them 
    with gzip 
  </ti>
  <ti><c>doinfo doc/*.info</c></ti>
</tr>
<tr>
  <ti><c>doins</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files with mode <c>INSOPTIONS</c> (see 
    <c>insopts</c>) into <path>INSDESTTREE</path> (see <c>insinto</c>)
  </ti>
  <ti><c>doins *.png icon.xpm</c></ti>
</tr>
<tr>
  <ti><c>dolib</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0644 
  </ti>
  <ti><c>dolib *.a *.so</c></ti>
</tr>
<tr>
  <ti><c>dolib.a</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0644
  </ti>
  <ti><c>dolib.a *.a</c></ti>
</tr>
<tr>
  <ti><c>dolib.so</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified libraries into <path>DESTTREE/lib</path> with mode 
    0755
  </ti>
  <ti><c>dolib.so *.so</c></ti>
</tr>
<tr>
  <ti><c>doman</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the specified files into <path>/usr/share/man/manX</path>, 
    according to the suffix of the file (file.1 will go into <path>man1</path>)
  </ti>
  <ti><c>doman *.1 *.5</c></ti>
</tr>
<tr>
  <ti><c>dosbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Installs the files into <path>DESTTREE/sbin</path>, making sure they are 
    executable
  </ti>
  <ti><c>dosbin ksymoops</c></ti>
</tr>
<tr>
  <ti><c>dosym</c></ti>
  <ti>N/A</ti>
  <ti>Creates a symlink, handles ${D} transparently</ti>
  <ti><c>dosym gzip /bin/zcat</c></ti>
</tr>
<tr>
  <ti><c>emake</c></ti>
  <ti>N/A</ti>
  <ti>
    Runs make with <c>MAKEOPTS</c>. Some packages cannot be made in
    parallel; use <c>emake -j1</c> instead. If you need to pass any
    extra arguments to make, simply append them onto the emake
    command. Users can set the <c>EXTRA_EMAKE</c> environment variable
    to pass extra flags to emake.
  </ti>
  <ti><c>emake</c></ti>
</tr>
<tr>
  <ti><c>exeinto</c></ti>
  <ti><path>/</path></ti>
  <ti>Sets the root (<e>EXEDESTTREE</e>) for the <c>doexe</c> command</ti>
  <ti><c>exeinto /usr/lib/${PN}</c></ti>
</tr>
<tr>
  <ti><c>exeopts</c></ti>
  <ti>-m0755</ti>
  <ti>Sets the options used when running <c>doexe</c></ti>
  <ti><c>exeopts -m1770</c></ti>
</tr>
<tr>
  <ti><c>fowners</c></ti>
  <ti>N/A</ti>
  <ti>
    Applies the specified ownership to the specified file via the chown 
    command, handles ${D} transparently
  </ti>
  <ti><c>fowners root:root /sbin/functions.sh</c></ti>
</tr>
<tr>
  <ti><c>fperms</c></ti>
  <ti>N/A</ti>
  <ti>
    Applies the specified permissions to the specified file via the chmod 
    command, handles ${D} transparently
  </ti>
  <ti><c>fperms 700 /var/consoles</c></ti>
</tr>
<tr>
  <ti><c>insinto</c></ti>
  <ti><path>/usr</path></ti>
  <ti>Sets the root (<e>INSDESTTREE</e>) for the <c>doins</c> command</ti>
  <ti><c>insinto /usr/include</c></ti>
</tr>
<tr>
  <ti><c>insopts</c></ti>
  <ti>-m0644</ti>
  <ti>Sets the options used when running <c>doins</c></ti>
  <ti><c>insopts -m0444</c></ti>
</tr>
<tr>
  <ti><c>into</c></ti>
  <ti><path>/usr</path></ti>
  <ti>
    Sets the target prefix (<path>DESTTREE</path>) for all the 'do' commands 
    (like <c>dobin</c>, <c>dolib</c>, <c>dolib.a</c>, <c>dolib.so</c>, 
    <c>domo</c>, <c>dosbin</c>)
  </ti>
  <ti><c>into /</c></ti>
</tr>
<tr>
  <ti><c>libopts</c></ti>
  <ti>-m0644</ti>
  <ti>Sets the options used when running <c>dolib</c></ti>
  <ti><c>libopts -m0555</c></ti>
</tr>
<tr>
  <ti><c>newbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dobin</c> which installs the specified binary 
    transparently renaming to the second argument
  </ti>
  <ti><c>newbin ${FILESDIR}/vmware.sh vmware</c></ti>
</tr>
<tr>
  <ti><c>newdoc</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dodoc</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newdoc README README.opengl</c></ti>
</tr>
<tr>
  <ti><c>newexe</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doexe</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newexe ${FILESDIR}/xinetd.rc xinetd</c></ti>
</tr>
<tr>
  <ti><c>newins</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doins</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newins ntp.conf.example ntp.conf</c></ti>
</tr>
<tr>
  <ti><c>newman</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>doman</c> which installs the specified file transparently 
    renaming to the second argument
  </ti>
  <ti><c>newman xboing.man xboing.6</c></ti>
</tr>
<tr>
  <ti><c>newsbin</c></ti>
  <ti>N/A</ti>
  <ti>
    Wrapper around <c>dosbin</c> which installs the specified file transparently
    renaming to the second argument
  </ti>
  <ti><c>newsbin strings strings-static</c></ti>
</tr>
<tr>
  <ti><c>prepall</c></ti>
  <ti>N/A</ti>
  <ti>
    Runs <c>prepallman</c>, <c>prepallinfo</c> and <c>prepallstrip</c>.  Also 
    ensures all libraries in <path>/opt/*/lib</path>, <path>/lib</path>, 
    <path>/usr/lib</path> and <path>/usr/X11R6/lib</path> are executable.  also 
    moves any stray aclocal macros into <path>/usr/share/aclocal</path>
  </ti>
  <ti><c>prepall</c></ti>
</tr>
<tr>
  <ti><c>prepalldocs</c></ti>
  <ti>N/A</ti>
  <ti>
    Recursively gzips all doc files in <path>/usr/share/doc</path>, 
    transparently fixing up any symlink paths
  </ti>
  <ti><c>prepalldocs</c></ti>
</tr>
<tr>
  <ti><c>prepallinfo</c></ti>
  <ti>N/A</ti>
  <ti>Recursively gzips all info files in <path>/usr/share/info</path></ti>
  <ti><c>prepallinfo</c></ti>
</tr>
<tr>
  <ti><c>prepallman</c></ti>
  <ti>N/A</ti>
  <ti>
    Recursively gzips all man pages in <path>/opt/*/man/*</path>, 
    <path>/usr/share/man/*</path>, <path>/usr/local/man/*</path>, 
    <path>/usr/X11R6/share/man/*</path> and transparently fixes up any symlink 
    paths
  </ti>
  <ti><c>prepallman</c></ti>
</tr>
</table>

</body>
</subsection>
</section>
<section>
<title>Zależności paczki</title>
<subsection>
<title>Why dependencies are important</title>
<body>

<p>
Portage is more than just a convenience script that gives you a unified
way to build any one project (program, library) from source.  It will also
fetch and install any necessary dependencies if you take care to specify
these in your ebuild.
</p>

<p>
In the official ebuilds, all dependencies have already been specified,
so when you issue <c>emerge net-www/mozilla/mozilla-1.0</c>, Portage will
insure that all libraries necessary for Mozilla to build and run are
properly installed before Mozilla itself is built.
</p>

<p>
Portage even distinguishes between build-time dependencies and run-time
dependencies. (Caveat: Currently, Portage installs all build-time and run-time
dependencies and leaves it at that. At a later stage, it will be possible to
trim your installation so that only the run-time dependencies are left 
installed).
</p>

</body>
</subsection>
<subsection>
<title>How to Specify Dependencies in Your ebuild Files (a.k.a. DEPEND Atoms)</title>
<body>

<p>
The <c>DEPEND</c> variable inside your <path>foo-x.y.z.ebuild</path> tells 
Portage about which packages are needed to build <path>foo</path>.  The 
<c>RDEPEND</c> variable specifies which packages are needed for <path>foo</path>
to run. You only need to explicitly specify <c>RDEPEND</c>
if the ebuild's runtime dependencies are different than what you specified in
<c>DEPEND</c>; if not specified, <c>RDEPEND</c> will default to your <c>DEPEND</c>
settings. <b>Never</b> set <c>RDEPEND</c> to <c>DEPEND</c> yourself in an ebuild.
</p>

<pre caption="Depend example">
DEPEND="virtual/libc
        sys-libs/zlib"
RDEPEND="virtual/libc"
</pre>

<p>
This tells Portage that to build <path>foo-x.y.z</path>, the packages
<path>virtual/libc</path> (more on  virtuals in a bit) and 
<path>sys-libs/zlib</path> are needed.  It does not say anything about which 
version of glibc or zlib that are needed, which means "anything goes".
</p>

<p>
The "anything goes" is of course a bit scary, and will not work in the general 
case. But for central libraries like glibc, which strives very hard to be 100% 
binary compatible all the time, it actually works. For other libraries, we can 
of course specify version dependencies.
</p>

<pre caption="Version example">
&gt;=sys-apps/bar-1.2
=sys-apps/baz-1.0
</pre>

<p>
&gt;= and = do what you would expect; sys-apps/bar version 1.2 or newer is okay
(this means that sys-apps/bar-2.0 is okay), while sys-apps/baz version 1.0 is 
the only version that is accepted. For more information on the version schema of
packages, see the section above on <uri link="#doc_chap2_sect2">Naming ebuild 
Files</uri>. 
</p>

<p>
Other methods of specifying version dependencies are as follows:
</p>

<pre caption="Specifying version dependencies">
~sys-apps/qux-1.0
=sys-apps/foo-1.2*
!sys-libs/gdbm
</pre>

<p>
~sys-apps/qux-1.0 will select the newest portage revision of qux-1.0.
</p>

<p>
=sys-apps/foo-1.2* will select the newest member of the 1.2 series, but will 
ignore 1.3 and later/earlier series.  That is, foo-1.2.3 and foo-1.2.0 are both
valid, while foo-1.3.3, foo-1.3.0, and foo-1.1.0 are not.
</p>

<p>
!sys-libs/gdbm will prevent this package from being emerged while gdbm is 
already emerged.
</p>

</body>
</subsection>

<subsection>
<title>Important Notes</title>
<body>

<p>
There are many things that go wrong with the DEPEND and RDEPEND
variables. Here are some important points to follow when you write the
dependencies.
</p>

<ul>
  <li>
    <e>Always include the CATEGORY.</e><br />
    For example, use <c>&gt;=x11-libs/gtk+-2</c> and not <c>&gt;=gtk+-2</c>.
  </li>
  <li>
    <e>Do not put an asterisk (*) for &gt;= dependencies.</e><br />
    For example, it should be <c>&gt;=x11-libs/gtk+-2</c> rather than
    <c>&gt;=x11-libs/gtk+-2*</c>.
  </li>
  <li>
    <e>Never depend on a meta-package.</e><br />
    So don't depend on gnome-base/gnome, always depend on the specific
    libraries like libgnome.
  </li>
  <li>
    <e>One dependency per line.</e><br />
    Don't put multiple dependencies on the same line. It makes it ugly to read
    and hard to follow.
  </li>
  <li><e>GTK: Always use =x11-libs/gtk+-1.2* for GTK+1 apps.</e></li>
</ul>

<p>
Additionally, it is important to ensure that all the dependencies are
complete for your package:
</p>

<ul>
  <li>
    <e>Look in configure.in or configure.ac</e><br />
    Look for checks for packages in here. Things to look out for are pkg-config
    checks or AM_* functions that check for a specific version.
  </li>
  <li>
    <e>Look at included .spec files</e><br />
    A good indication of dependencies is to look at the included .spec files
    for relevant deps. However, do not trust them to be the definitive complete
    list of dependencies.
  </li>
  <li>
    <e>Look at the application/library website</e><br />
    Check the application website for possible dependencies that they suggest
    are needed.
  </li>
  <li>
    <e>Read the README and INSTALL for the package</e><br />
    They usually also contain useful information about building and installing
    packages.
  </li>
  <li>
    <e>Remember non-binary dependencies such as pkg-config, doc generation
    programs, etc.</e><br />
    Usually the build process requires some dependencies such as intltool,
    libtool, pkg-config, doxygen, scrollkeeper, gtk-doc, etc. Make sure those
    are clearly stated.
  </li>
</ul>

<p>
For all the latest details about these DEPEND Atoms, please see the section 5 
manpage on ebuilds: <c>man 5 ebuild</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Testing and deploying</title>
<subsection>
<title>ChangeLog</title>
<body>

<p>
Whenever you update (or write a new) an ebuild, you must also update its (or
create a new) ChangeLog.  The <path>skel.ChangeLog</path> contains a sample
ChangeLog that you can use as a basis.
</p>

<p>
The purpose of the ChangeLog is to document <e>what</e> is being done, 
<e>why</e> it is being done, and by <e>whom</e>.  This allows both 
developers and users to trace the changes made in an easy way.
</p>

<p>
The ChangeLog is primarily targeted at users, so be sure to keep your
writing short, to the point, and avoid getting verbose about the internal
technical details.
</p>

</body>
</subsection>

<subsection>
<title>Storing your own ebuilds locally</title>
<body>

<p>
In order to be able to test your ebuilds and let Portage know about them, you 
must place those in a known directory.  Portage will use the 
<c>PORTDIR_OVERLAY</c> variable which you can define in 
<path>/etc/make.conf</path>.  You should set this variable to your directory 
(e.g. <path>/usr/local/portage</path>).
</p>

<p>
In that directory, you must use the same structure (and categories) as in 
<path>/usr/portage</path>. 
</p>

<p>
Using this <c>PORTDIR_OVERLAY</c>, your ebuilds remain on your system, even
after an <c>emerge sync</c>, and they are still known to Portage.
</p>

</body>
</subsection>

<subsection>
<title>Testing the package</title>
<body>

<p>
Have a think about how you will test whether this package
works. Sometimes the developers have already included a <c>make test</c> or
<c>make check</c> routine that will test the basic functionality of the
package. If so, then running <c>env FEATURES=maketest ebuild <path>foo-x.y.z.ebuild</path>
test</c> will execute it. If it is broken try to fix it so that it works
(and submit the patch to the upstream developers).
</p>

<p>
If this is not the case consider adding a <c>src_test</c> routine to
your ebuild. This is executed before the <c>src_install</c> routine
and can be very helpful for testing the program works across various
architectures. The architecture developers will appreciate if you add
a routine here so that they do not require knowledge of the package's
functionality.
</p>

<p>
Please keep in mind the general requirements of an ebuild here. The
<c>src_test</c> routine must not be interactive. If the test routine
depends on other packages use the <c>maketest</c> USE flag to specify the
optional compile time <c>DEPEND</c>ancies. Also, please note that <c>src_test</c>
routines are not recommended for graphical X applications as the
user running portage often cannot run them successfully.
</p>

</body>
</subsection>

<subsection>
<title>Useful testing tools</title>
<body>

<p>
We have a few useful tools to help you with writing and maintaining your 
ebuilds.
</p>

<table>
<tr>
  <th>Tool</th>
  <th>Package</th>
  <th>Description</th>
</tr>
<tr>
  <ti><c>repoman</c></ti>
  <ti>sys-apps/portage</ti>
  <ti>
    Developer-only tool to assist with the CVS checkin procedure.  It does a 
    lot of common QA and tries to make sure that files added to cvs will not 
    break the portage tree.
  </ti>
</tr>
<tr>
  <ti><c>ccache</c></ti>
  <ti>dev-util/ccache</ti>
  <ti>
    Tool that keeps pre-processed files so that recompilation gets done 
    <e>much</e> faster.  Be sure to add <c>ccache</c> to the <c>FEATURES</c> 
    variable in <path>/etc/make.conf</path>!
  </ti>
</tr>
<tr>
  <ti><c>sandboxshell</c></ti>
  <ti>app-shells/sandboxshell</ti>
  <ti>
    Launch a shell that creates a sandbox environment.  Useful for entering the
    same environment that portage builds packages inside of and debugging 
    things by hand.
  </ti>
</tr>
<tr>
  <ti><c>echangelog</c></ti>
  <ti>app-portage/gentoolkit-dev</ti>
  <ti>Can create a new ChangeLog or add an entry to an existing one.</ti>
</tr>
</table>

</body>
</subsection>
</section>
</sections>
