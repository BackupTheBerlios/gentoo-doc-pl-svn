<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/hb-selinux-howto.xml,v 1.2 2004/11/16 03:33:08 pebenito Exp $ -->

<sections>
<section><title>Załadowanie polityki do działającego jądra SELinux</title>
<subsection><body>
<p>
  Należy posiadać rolę <c>sysadm_r</c>, aby tego dokonać.
</p>
<pre>
# <i>cd /etc/security/selinux/src/policy</i>
# <i>make load</i>
</pre>
</body></subsection>
</section>

<section><title>Zmiana ról</title>
<subsection><body>
<p>
To wymaga aby dany użytkownik posiadał dostęp do docelowej roli. Poniższy
przykład pokazuje jak zmienić bieżącą rolę do <c>sysadm_r</c>.
</p>
<pre>
# <i>newrole -r sysadm_r</i>
</pre>
</body></subsection>
</section>

<section><title>Wyznaczanie dostępnych ról dla użytkownika</title>
<subsection><body>
<p>
Dostępne role dla danego użytkownika są określane za pomocą tożsamości SELinux.
Można zmienić dostępne role w pliku /etc/security/selinux/src/policy/users. Dla
przykładu, aby udostępnić użytkownikowi <c>pebenito</c> możliwość posiadania ról
<c>staff_r</c> oraz <c>sysadm_r</c>, należy dodać do powyższego pliku:
</p>
<pre>user pebenito roles { staff_r sysadm_r };</pre>
<p>
Potem <uri link="#doc_chap1">załadować</uri> politykę. W Przeglądzie SELinux
można znaleźć więcej informacji na temat dostępnych tożsamości SELinuxa.
</p>
</body></subsection>
</section>

<section><title>Znakowanie plików</title>
<subsection><body>
<p>
To działanie wymaga, aby posiadać rolę <c>sysadm_r</c>.
</p>
<pre>
# <i>cd /etc/security/selinux/src/policy</i>
# <i>make relabel</i>
</pre>
</body></subsection>
</section>

<section><title>Znakowanie pojedyńczej paczki</title>
<subsection><body>
<p>
Oprócz znakowania całego systemu plików, poszczególne paczki portage mogą być
znakowane osobno. To działanie wymaga, aby posiadać rolę <c>sysadm_r</c>.
</p>
<pre caption="przykład użycia rlpkg">
# <i>rlpkg pam-login sash</i>
</pre>
<p>
Skrypt rlpkg jest używany, zaś dowolna liczba pakietów może być wypisana w linii
poleceń.
</p>
</body></subsection>
</section>

<section><title>Uruchomienie demonów w odpowiedniej domenie</title>
<subsection><body>
<p>
Kontrola nad demonami które posiadają skrypty inicjujące w /etc/init.d różni się
nieco w SELinux. Musi zostać użyte polecenie <c>run_init</c> aby uruchomić
skrypty, aby być pewnym że są one uruchamiane w odpowiedniej domenie. Polecenie
może zostać uruchomione normalnie, jednakże jest on poprzedzony przez
<c>run_init</c>. To działanie wymaga, aby posiadać rolę <c>sysadm_r</c>.
</p>
<pre caption="run_init examples">
# <i>run_init /etc/init.d/ntpd start</i>
# <i>run_init /etc/init.d/apache2 restart</i>
# <i>run_init /etc/init.d/named stop</i>
</pre>
</body></subsection>
<subsection><title>Integracja run_init w Gentoo</title><body>
<p>
  <c>run_init</c> zostało zintegrowane z systemem skryptów inicjujących w
  Gentoo. Mając zaisntalowanego SELinuxa, usługi mogą być uruchamiane i
  zatrzymywane tak jak zwykle, jednakże będą wymagały autoryzacji użytkownika
  przy pomocy hasła.
</p>
<pre caption="Przykład użycia zintegrowanego run_init">
# <i>/etc/init.d/sshd restart</i>
Authenticating root.
Password:
 * Stopping sshd...                       [ ok ]
 * Starting sshd...                       [ ok ]
</pre>
</body></subsection>
</section>

<section><title>Przełączanie pomiędzy trybami wymuszonym (enforcing) i
pobłażliwym (permissive)</title>
<subsection><body>
<p>
Przełączanie pomiędzy trybami w SELinux jest bardzo proste. Wystarczy zapisać 1
dla trybu wymuszonego oraz 0 dla pobłażliwego w pliku /selinux/enforce aby
ustawić odpowiedni tryb. Obecny tryb może być sprawdzony poprzez odczytanie
/selinux/enforce; 0 oznacza pobłażliwy, zaś 1 oznacza wymuszony. Jeśli opcja
"NSA SELinux Development Support" w jądrze jest wyłączona, system zawsze będzie
w trybie wymuszonym i nie będzie można przełączyć się do trybu pobłażliwego.
</p>
<pre>
<comment>Sprawdzenie bieżącego trybu</comment>
# <i>cat /selinux/enforce</i>
<comment>Zmiana do trybu wymuszonego</comment>
# <i>echo 1 > /selinux/enforce</i>
<comment>Zmiana do trybu pobłażliwego</comment>
# <i>echo 0 > /selinux/enforce</i>
</pre>
<p>
Stary API SELinuxa posiadał polecenia <c>avc_enforcing</c> oraz
<c>avc_toggle</c> aby sprawdzić obecny tryb i odpowiednio przełączać się
pomiędzy trybami. <c>avc_toggle</c> wyświetli obecny tryb do którego system się
przełącza (nie bieżący tryb). Dla zachowania kompatybilności, skrypty które
powielają te czynności są instalowane razem z policycoreutils.
</p>
<p>
System z włączonym trybem deweloperskim może zostać uruchomiony w trybie
wymuszonym poprzez dodanie <c>enforcing=1</c> do linii poleceń jądra w programie
rozruchowym (GRUB, lilo, etc).
</p>
</body></subsection>
</section>

<section><title>Rozumienie wyników polecenia sestatus</title>
<subsection><body>
<p>
Narzędzie <c>sestatus</c> może być używane aby określić szczegółowe, związane z
SELinux informacje o systemie. Opcja <c>-v</c> pozwala otrzymać więcej
szczegółów o obecnym kontekście procesów lub plików. Wynik będzie podzielony na
cztery sekcje. Sestatus udostępnia te informacje tylko użytkownikowi
zalogowanemu jako root (lub poprzez su/sudo) posiadającemu rolę <c>sysadm_r</c>.
</p>
<pre caption="Przykład statusu">
SELinux status:         enabled
SELinuxfs mount:        /selinux
Current mode:           enforcing
Policy version:         18
</pre>
<p>
Główne informacje na temat systemu znajdują się w pierwszej sekcji. Pierwsza
linijka pokazuje czy funkcje SELinux są w jądrze i czy są włączone. Jeśli status
jest wyłączony, oznacza to że albo jądro nie posiada wsparcia dla SELinux, lub
polityka nie jest załadowana. Druga linijka pokazuje miejsce zamontowania dla
systemu plików SELinux. Podczas normalnego używania, powinno to być w domyślnej
lokalizacji, czyli <c>/selinux</c>. Trzecia linijka pokazuje bieżący tryb
SELinuxa, który może być albo wymuszony (enforcing) albo pobłażliwy
(permissive). Czwarta linijka pokazuje wersję polityki którą udostępnia bieżące
jądro.
</p>
<pre caption="Przykład włączonych zmiennych">
Policy booleans:
secure_mode             inactive
ssh_sysadm_login        inactive
user_ping               inactive
</pre>
<p>
Druga sekcja udostępnia informacje na temat włączonych zmiennych polityki. Lewa
kolumna przedstawia zmienną. Prawa kolumna pokazuje status danej zmeinnej -
albo aktywna (active), albo nieaktywna (inactive). Ta sekcja nie będzie pokazana
w wersji 15 polityki, jako że nie wspiera ona polityki zmiennych.
</p>
<pre caption="Przykład kontekstów procesów">
Process contexts:
Current context:        pebenito:sysadm_r:sysadm_t
Init context:           system_u:system_r:init_t
/sbin/agetty            system_u:system_r:getty_t
/usr/sbin/sshd          system_u:system_r:sshd_t
</pre>
<p>
Trzecia sekcja pokazuje kontekst danego procesu oraz wielu ważnych procesów.
Jeśli proces będzie uruchomiony w złym kontekście, nie będzie prawidłowo
działał.
</p>
<pre caption="Przykład kontekstów plików">
File contexts:
Controlling term:       pebenito:object_r:sysadm_devpts_t
/sbin/init              system_u:object_r:init_exec_t
/sbin/agetty            system_u:object_r:getty_exec_t
/bin/login              system_u:object_r:login_exec_t
/sbin/rc                system_u:object_r:initrc_exec_t
/sbin/runscript.sh      system_u:object_r:initrc_exec_t
/usr/sbin/sshd          system_u:object_r:sshd_exec_t
/sbin/unix_chkpwd       system_u:object_r:chkpwd_exec_t
/etc/passwd             system_u:object_r:etc_t
/etc/shadow             system_u:object_r:shadow_t
/bin/sh                 system_u:object_r:bin_t -> system_u:object_r:shell_exec_t
/bin/bash               system_u:object_r:shell_exec_t
/bin/sash               system_u:object_r:shell_exec_t
/usr/bin/newrole        system_u:object_r:newrole_exec_t
/lib/libc.so.6          system_u:object_r:lib_t -> system_u:object_r:shlib_t
/lib/ld-linux.so.2      system_u:object_r:lib_t -> system_u:object_r:shlib_t
</pre>
<p>
Czwarta sekcja przedstawia konteksty terminala bieżącego procesu oraz wielu
ważnych plików. Dla powiązań symbolicznych, pokazany jest kontekst powiązania, a
potem kontekst docelowego pliku. Jeśli plik posiada niewłaściwy kontekst, może
on być niedostępny lub może spowodować iż proces zostanie uruchomiony w
niewłaściwym kontekście.
</p>
</body></subsection>
</section>
</sections>
