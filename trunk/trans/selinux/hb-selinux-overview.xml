<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/proj/en/hardened/selinux/hb-selinux-overview.xml,v 1.3 2004/12/11 22:49:20 pebenito Exp $ -->

<sections>
<!--
<section>
<title>Mandatory Access Control</title>
<subsection>
<body>

<p>
Security Enhanced Linux is an implementation of mandatory access control
(MAC) using type enforcement.  In Linux, the regular security permissions
are a discretionary access control system (DAC).  In DAC, the permissions
for a particular object, such as a file, are set at the discrection of the
owner and can be changed at any time by the owner.  In MAC, the access a
process or user has to an object is defined by the operating system
security policy, and cannot be bypassed.
!!! still need to update other links in the handbook
</p>

</body>
</subsection>
</section>
-->

<section>
<title>Typy SELinux</title>
<subsection>
<body>

<p>
<e>Typ</e> jest atrybutem bezpieczeństwa, przekazywanym obiektom takim jak
pliki, porty internetowe itp. Typ procesu odwołuje się zazwyczaj do jego
domeny. Polityka SELinux jast w głównej mierze zbudowana z reguł wymuszających
sprawdzanie typów, które opisują, jak domeny mogą współdziałać z obiektami oraz
z innymi domenami. Typ jest zazwyczaj zakończony przyrostkiem &#39;_t&#39;, jak
na przykład <c>sysadm_t</c>. Jest to najważniejszy atrybut procesu czy też
obiektu, ponieważ większość reguł polityki bezpieczeństwa opiera się na typach
obiektów wywołujących zdarzenia i tych, które są wywoływane.
</p>

</body>
</subsection>
</section>

<section>
<title>Statusy SELinux</title>
<subsection>
<body>

<p>
SELinux opiera się w głównej mierze na wymuszaniu typów, więc statusy są tutaj
traktowane inaczej niż w systemach kontroli dostępu opartych wyłącznie na
statusach. Uprawnienia nie są przyznawane poszczególnym statusom. Status opisuje
zbiór typów, jakich użytkownik, posiadający ten status, może
używać. Przykładowo, administrator, który wykorzystuje system do standardowych
czynności użytkowych, powinien posiadać status <c>staff_r</c>. Jeśli zajdzie
potrzeba wykonania czynności administracyjnych status powinien zostać zmieniony
na <c>sysadm_r</c>. W SELinux domeny, w których może znajdować się użytkownik,
są determinowane posiadanym przez niego statusem. Jeśli dany status nie pozwala
na posiadanie pewnej domeny, to przejście do niej nie będzie możliwe, nawet
jeśli zasady wymuszania typów na to pozwalają. Generalnie rzecz biorąc statusy
posiadają przyrostek &#39;_r&#39;, jak np. <c>portage_r</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>Tożsamości SELinux</title>
<subsection>
<title>Czym są rożsamości SELinux?</title><body>

<p>
Tożsamość SELinux jest podobna do linuksowej nazwy użytkownika. Zmiany
tożsamości powinny być ograniczone do minimum, ponieważ system kontroli dostępu
oparty na statusach jest zależny od tożsamości SELinux. Dlatego, ogólnie rzecz
ujmując, tożsamość użytkownika nie zmienia się w czasie trwania sesji. ID
użytkownika w Linuksie może zostać zmienione poleceniem set(e)uid, czyniąc je
tym samym niewłaściwym z punktu widzenia tożsamości SELinux. Jeśli użytkownik
otrzymuje tożsamość SELinux, musi ona być zgodna z jego linuksową nazwą
użytkownika. Każda tożsamość SELinux może korzystać z określonej grupy statusów.
</p>

</body>
</subsection>

<subsection>
<title>Konfigurowanie tożsamości SELinux</title>
<body>

<p>
Tożsamości utrzymywane są w pliku użytkowników w katalogu z polityką
SELinux. Składnia pliku jest prosta. Przykładowo, aby zezwolić użytkownikowi
<c>pebenito</c> na korzystanie ze statusów <c>staff_r</c> i <c>sysadm_r</c>,
należy dodać na końcu tego pliku poniższą linię:
</p>

<pre caption="Konfigurowanie tożsamości SELinux">
user pebenito roles { staff_r sysadm_r };
</pre>

<p>
Następnie należy załadować politykę. Aby zmiany odniosły skutek musi istnieć
konto, którego linuksowa nazwa użytkownika to  <c>pebenito</c>. Jeśli użytkownik
nie posiada linii <c>user</c> w opisywanym pliku, to jego tożsamością będzie
<c>user_u</c>, a jedyny status, do jakiego będzie miał dostęp, to <c>user_r</c>.
</p>

<impo>
Zwykli użytkownicy, którzy posiadają tożsamości, powinni posiadać dostęp do
statusu <c>user_r</c>, ale nie do <c>staff_r</c>. Administratorzy powinni mieć
dostęp do statusów <c>staff_r</c> i <c>sysadm_r</c>. Każdy użytkownik musi
posiadać dostęp do statusu <c>user_r</c> lub <c>staff_r</c>. W innym przypadku
użytkownik ten nie będzie mógł zalogować się zdalnie.
</impo>

<p>
Gdy nadajemy użytkownikowi tożsamość, jego katalog domowy (oraz zawartość tego
katalogu) powinien zostać prawidłowo oznakowany. Znakowanie zostanie wykonane na
podstawie pierwszego statusu jaki podano dla danego konta w pliku
użytkowników. Przykładowo, katalog domowy, zaprezentowanego wyżej użytkownika
pebenito, zostanie oznakowany jako <c>staff_home_dir_t</c>.
</p>

</body>
</subsection>
</section>

<section>
<title>KontekstySELinux</title>
<subsection>
<body>

<p>
Opisane powyżej trzy modele bezpieczeństwa razem nazywane są kontekstami
SELinux. Kontekst posiada składnię:
<c>tożsamość</c>:<c>status</c>:<c>typ</c>. Kontekst jest najważniejszą wartością
podczas determinowania dostępu.
</p>

</body>
</subsection>

<subsection>
<title>Konteksty obiektów</title>
<body>

<p>
Typowy wynik polecenia <c>ls -Z</c> może być podobny do poniższego:
</p>

<pre caption="Przykładowy wynik polecenia ls -Z">
drwxr-xr-x  root  root     system_u:object_r:bin_t          bin
drwxr-xr-x  root  root     system_u:object_r:boot_t         boot
drwxr-xr-x  root  root     system_u:object_r:device_t       dev
drwxr-xr-x  root  root     system_u:object_r:etc_t          etc
</pre>

<p>
Pierwsze trzy kolumny wyniku to standardowe w Linuksie informacje o prawach
dostępu, właścicielach i grupach katalogów. Czwarta kolumna to kontekst
katalogu. Obiekty posiadają standardowy status <c>object_r</c>. Z pozostałych
pól kontekstu można odczytać, że katalogi posiadają tożsamość <c>system_u</c>, a
każdy z nich posiada inny typ - odpowiednio: <c>bin_t</c>, <c>boot_t</c>,
<c>device_t</c> i <c>etc_t</c>.
</p>

</body>
</subsection>

<subsection>
<title>Konteksty procesów</title>
<body>

<p>
Przykładowy wynik polecenia <c>ps ax -Z</c> może wyglądać następująco:
</p>

<pre caption="Przykładowy wynik polecenia ps ax -Z">
  PID CONTEXT                               COMMAND
 1 system_u:system_r:init_t                 [init]
 2 system_u:system_r:kernel_t               [keventd]
 3 system_u:system_r:kernel_t               [ksoftirqd_CPU0]
 4 system_u:system_r:kernel_t               [kswapd]
 5 system_u:system_r:kernel_t               [bdflush]
 6 system_u:system_r:kernel_t               [kupdated]
  706 system_u:system_r:syslogd_t           [syslog-ng]
  712 system_u:system_r:httpd_t             [apache]
  791 system_u:system_r:sshd_t              [sshd]
  814 system_u:system_r:crond_t             [cron]
  826 system_u:system_r:getty_t             [agetty]
  827 system_u:system_r:getty_t             [agetty]
  828 system_u:system_r:getty_t             [agetty]
  829 system_u:system_r:getty_t             [agetty]
  830 system_u:system_r:getty_t             [agetty]
  831 system_u:system_r:httpd_t             [apache]
  832 system_u:system_r:httpd_t             [apache]
  833 system_u:system_r:httpd_t             [apache]
23093 system_u:system_r:sshd_t              [sshd]
23095 user_u:user_r:user_t                  [bash]
23124 system_u:system_r:sshd_t              [sshd]
23126 user_u:user_r:user_t                  [bash]
23198 system_u:system_r:sshd_t              [sshd]
23204 user_u:user_r:user_t                  [bash]
23274 system_u:system_r:sshd_t              [sshd]
23275 pebenito:staff_r:staff_t              [bash]
23290 pebenito:staff_r:staff_t              ps ax -Z
</pre>

<p>
W powyższym przykładzie pokazane są typowe informacje o procesie, uzupełnione o
konteksty procesów. Przyjrzenie się tym wynikom pozwala stwierdzić, że wszystkie
procesy jądra systemu oraz wszystkie demony posiadają tożsamość <c>system_u</c>
i status <c>system_r</c>. Poszczególne domeny zależą od programów. Kilku
użytkowników jest zalogowanych przez ssh ze standardową tożsamością
<c>user_c</c>. Jest także użytkownik z tożsamością <c>pebenito</c> zalogowany ze
statusem <c>staff_r</c>, pracujący w domenie <c>staff_t</c>. 
</p>

</body>
</subsection>

</section>

<section>
<title>Pliki polityki SELinux</title>
<subsection>
<body>

<p>
Polityka SELinux zazwyczaj rezyduje w katalogu
<c>/etc/security/selinux/src/policy</c>. Składa się ona z kilku plików i
katalogów potrzebnych do wygenerowania polityki. Dla ułatwienia tworzenia
polityki, wykorzystane zostały makra edytora tekstu m4 to wielokrotnego
wykorzystywania powszechnie wykorzystywanych zasad. Pliki polityki zostają
przetworzone przez m4, a następnie kompilator polityk - <c>checkpolicy</c> -
weryfikuje ich poprawność składniową i tworzy binarny plik polityki, który może
zostać załadowany do działającego jądra SELinux.
</p>

</body>
</subsection>

<subsection>
<title>Pliki Make</title>
<body>

<p>
Plik Make polityki odpowiedzialny jest za jej kompilację i instalację w
systemie. Posiada on jedną konfigurowalną opcję, przeznaczoną do kontrolowania
<uri link="#doc_chap6">wersji polityki</uri> oraz cztery formuły, powodujące
różne działania:
</p>

<table>
<tr>
  <th>Komenda</th>
  <th>Opis</th>
</tr>
<tr>
  <ti>make policy</ti>
  <ti>Kompiluje obecną politykę do binarnego pliku.</ti>
</tr>
<tr>
  <ti>make install</ti>
   <ti>Kompiluje i instaluje obecną politykę do katalogu
  <path>/security/selinux/src</path>.</ti>
</tr>
<tr>
  <ti>make load</ti>
  <ti>Kompiluje, instaluje i ładuje obecną politykę do działającego jądra
  SELinux.</ti>
</tr>
<tr>
  <ti>make relabel</ti>
  <ti>Dokonuje oznaczenia systemu plików przy użyciu kontekstów plików z
  polityki.</ti>
</tr>
</table>

</body>
</subsection>

<subsection>
<title>Plik assert.te</title>
<body>

<p>
Asercje z pliku <path>assert.te</path> zostaną sprawdzone podczas końcowego
etapu kompilacji polityki. Jeśli któreś z uprawnień zapewnianych przez politykę
będzie zgodne z asercjami z tego pliku, to kompilator odrzuci politykę. Może to
pomóc w zapewnieniu, że określone uprawnienia nigdy nie zostaną dopuszczone.
</p>

</body>
</subsection>

<subsection>
<title>Plik attrib.te</title>
<body>

<p>
A type attribute can be used to identify a set of types with a similar
property.  Each type can have any number of attributes, and each
attribute can be associated with any number of types.  Attributes are
explicitly declared in this file, and can then be associated with particular
types in type declarations.  Attribute names can then be used throughout
the configuration to express the set of types that are associated with
the attribute.
</p>

</body>
</subsection>

<subsection><title>constraints</title><body>
<p>
This file defines additional constraints on permissions
in the form of expressions that must be satisfied in order
for specified permissions to be granted.  These constraints
are used to further refine the type enforcement tables and
the role allow rules.  Typically, these constraints are used
to restrict changes in user identity or role to certain domains.
</p>
</body></subsection>

<subsection><title>domains/</title><body>
<p>
This directory contains the type enforcement rules.  This directory contains
the files <c>admin.te</c>, <c>staff.te</c>, and <c>user.te</c>, which
contain the access vectors for the <c>sysadm_r</c>, <c>staff_r</c>, and 
<c>user_r</c> roles.  The <c>program/</c> directory consists of all of the
active policies for various programs and daemons.  The <c>misc/</c> directory
contains all other policy files.
</p>
</body></subsection>

<subsection><title>file_contexts/</title><body>
<p>
This directory contains the files that describe the security contexts
for all files on persistent filesystems.  It contains the file <c>types.fc</c>
which has all of the security contexts for the general system.  The
directory <c>program/</c> contains the security contexts for the daemons
in the <c>domains/program/</c> directory.  These are one-to-one mapped;
for example, the domains/program/syslogd.te policy file corresponds to the
file_contexts/program/syslogd.fc security contexts file.
</p>
</body></subsection>

<subsection><title>flask/</title><body>
<p>
This directory contains contains configuration files independent of the
policy.  These files contain definitions corresponding to definitions
in the kernel headers.  These files <e>should not</e> be modified.
</p>
</body></subsection>

<subsection><title>fs_use</title><body>
<p>
This file describes the labelling behavior for files on various filesystem
types.  For example, ext3 uses persistent labelling, while tmpfs uses
transitional security IDs.  In general, this file should <e>not</e>
need to be modified.
</p>
</body></subsection>

<subsection><title>genfs_contexts</title><body>
<p>
This file contains the security contexts for files in a filesystem that
do not support persistent file labels, such as <c>/proc</c>.
</p>
</body></subsection>

<subsection><title>initial_sid_contexts</title><body>
<p>
This file contains the initial context for each security ID.  In general,
this file should <e>not</e> need to be modified.
</p>
</body></subsection>

<subsection><title>macros/</title><body>
<p>
This directory contains the m4 macros used to ease creation and maintenance
of the policy.  It contains the macro file <c>admin_macros.te</c> for
describing administration domains, such as <c>sysadm_t</c>.  The
<c>user_macros.te</c> contains macros used in user domains such as <c>user_t</c>
and <c>staff_t</c>.  The <c>global_macros.te</c> contains macros used throughout
the entire policy.
</p>
</body></subsection>

<subsection><title>mls</title><body>
<p>
This file contains the configuration for SELinux multi-level security.
Multi-level Security is experimental, and is not supported by Gentoo.
</p>
</body></subsection>

<subsection><title>net_contexts</title><body>
<p>
This file defines the security contexts of network objects such as ports,
interfaces, and nodes.  This will need to be modified if daemons run on
nonstandard ports.
</p>
</body></subsection>

<subsection><title>rbac</title><body>
<p>
The name of the file is misleading, as SELinux does not have
role-based access control.  This file contains role transition
rules for the base system.  Additional transitions are allowed
in the type enforcement files, especially <c>user.te</c> and
<c>staff.te</c>.
</p>
</body></subsection>

<subsection><title>tmp/</title><body>
<p>
This directory is used for holding intermediate files when compiling the
policy.  It can be safely removed, if needed.
</p>
</body></subsection>

<subsection><title>tunable.te</title><body>
<p>
This is the main configuration file of the policy.
</p>
</body></subsection>

<subsection><title>types/</title><body>
<p>
This directory contains files for declaring general types of the system
which do not appear in the individual program policies.
</p>
</body></subsection>

<subsection><title>users</title><body>
<p>
This file describes the SELinux identities, and the roles they can enter.
</p>
</body></subsection>
</section>

<section>
<title>Policy Database Versions</title>
<subsection><body>
<p>
When compiling the policy, the resultant binary policy is versioned.  The
first version that was merged into 2.6, and also is in the 2.4 backports is
version 15.  The version number is only incremented generally when new
features are added that require changes to the structure of the compiled
policy.  For example, in 2.6.5, conditional policy extensions were added.
This required the policy version to be incremented to version 16.
</p>
</body></subsection>
<subsection><title>What Policy Version Does My Kernel Use?</title>
<body>
<p>
There are several ways to determine the kernel's policy version.  A change
to the kernel eclass has been made that will display the policy version that
the kernel expects:
</p>
<pre>
 * The SELinux policy version of this kernel is 16.
</pre>
<p>
The policy version of a running kernel can be determined by executing
<c>sestatus</c> or <c>policyvers</c>.  Current kernels can load
the previous version policy for compatibility.  For example a version 17
kernel can also load a version 16 policy.  However, this compatibility
code may be removed in the future.
</p>
</body></subsection>
<subsection><title>Compiling the Right Version Policy</title>
<body>
<p>
The only adjustment needed is in the policy Makefile.  There is a line
near the top that looks like this:
</p>
<pre>
POLICYCOMPAT = -c 15
</pre>
<p>
Normally, checkpolicy will create a policy for the current version.  The
policy versions that checkpolicy can create can be determined by running
<c>checkpolicy -V</c>.  With the above option uncommented, a compatibility
policy can be created.  The above statement will create a version 15 policy;
it can be changed to 16.
</p>
</body></subsection>
<subsection><title>Policy Versions</title>
<body>
<p>
The following table contains the policy versions in vanilla 2.6
kernels and in SELinux-patched 2.4 kernels.  Other 2.6 kernels,
such as arch kernels (ppc-dev-sources) and gentoo-dev-sources,
will have the SELinux version of the vanilla kernel version
it is based on.
</p>
<table>
<tr><th>Version</th>
 <th>Description</th>
 <th>Vanilla Kernel Versions</th>
 <th>SELinux-sources</th>
 <th>Hardened-sources</th>
 <th>Hardened-dev-sources</th></tr>
<tr><ti>12</ti>
 <ti>"Old API" SELinux (deprecated).</ti></tr>
<tr><ti>15</ti>
 <ti>"New API" SELinux merged into 2.6.</ti>
 <ti>2.6.0 - 2.6.4</ti>
 <ti>All 2.4</ti>
 <ti>All 2.4</ti>
 <ti>2.6.0 - 2.6.3</ti></tr>
<tr><ti>16</ti>
 <ti>Conditional policy extensions added.</ti>
 <ti>2.6.5</ti>
 <ti></ti>
 <ti></ti>
 <ti>2.6.4 - 2.6.5-r2</ti></tr>
<tr><ti>17</ti>
 <ti>IPV6 support added.</ti>
 <ti>2.6.6 - 2.6.7</ti>
 <ti></ti>
 <ti></ti>
 <ti>2.6.5-r3 - current</ti></tr>
<tr><ti>18</ti>
 <ti>Fine-grained netlink socket support added.</ti>
 <ti>2.6.8 - current</ti>
 <ti></ti>
 <ti></ti>
 <ti></ti></tr>
</table>
</body></subsection>
</section>

<section>
<title>Conditional Policy Extensions</title>
<subsection><body>
<p>
  The conditional policy extensions allow the enabling and disabling of policy
  rules at runtime, without loading a modified policy.  Using policy booleans
  and expressions, policy rules can be conditionally applied.
</p>
</body></subsection>

<subsection><title>Determine Boolean Values</title>
<body>
<p>
  The status of policy booleans in the current running policy can be determined
  two ways.  The first is by using <c>sestatus</c>.
</p>
<pre>
# sestatus
SELinux status:      enabled
SELinuxfs mount:     /selinux
Current mode:        enforcing
Policy version:      17
 
Policy booleans:
user_ping            inactive
</pre>
<p>
  The second is <c>getsebool</c> which is a simple tool that displays
  the status of policy booleans, and if a value change is pending.
</p>
<pre>
# getsebool -a
user_ping --> active: 0 pending: 0
</pre>
</body></subsection>

<subsection><title>Changing Boolean Values</title>
<body>
<p>
  The value of a boolean can be toggled by using the <c>togglesebool</c>
  command.  Multiple booleans can be specified on the command line.  The
  new value of the boolean will be displayed.
</p>
<pre>
# togglesebool user_ping
user_ping: active
</pre>
<p>
  The value of a boolean can be set specifically by using the <c>setsebool</c>
  command.
</p>
<pre>
# setsebool user_ping 0
</pre>
</body></subsection>
</section>

<section>
<title>Policy Kernel Messages</title>
<subsection><body>
<p>
While a system is running, a program or user may attempt to do something
that violates the security policy.  If the system is enforcing the policy,
the access will be denied, and there will be a message in the kernel log.
If the system is not enforcing (permissive mode), the access will be allowed,
but there will still be a kernel message.
</p>
</body></subsection>

<subsection><title>AVC Messages</title><body>
<p>
Most kernel messages from SELinux come from the access vector cache (AVC).
Understanding denials is important to understand if an attack is happening,
or if the program is requiring unexpected accesses.  An example denial
may look like this:
</p>

<pre caption="Example AVC Message">
avc:  denied  { read write } for  pid=3392 exe=/bin/mount dev=03:03 ino=65554
scontext=pebenito:sysadm_r:mount_t tcontext=system_u:object_r:tmp_t tclass=file
</pre>

<p>
While most AVC messages are denials, occasionally there might be an audit
message for an access that was granted:
</p>
<pre caption="Example AVC Message 2">
avc:  granted  { load_policy } for  pid=3385 exe=/usr/sbin/load_policy
scontext=pebenito:sysadm_r:load_policy_t tcontext=system_u:object_r:security_t tclass=security
</pre>
<p>
In this case, the ability to load the policy was granted.  This is a critical
security event, and thus is always audited.  Another event that is always
audited is switching between enforcing and permissive modes.
</p>

<p>
SELinux will supress logging of denials if many are received in a short
amount of time.  However, This does not always imply there is an attack
in progress.  A program may be doing something that could cause
many denials in a short time, such as doing a stat() on device nodes in
/dev.  To protect from filling up the system logs, SELinux has rate limiting
for its messages:
</p>

<pre caption="Example AVC Message 3">
AVC: 12 messages suppressed.
</pre>

<p>
The policy would have to be modified to not audit these accesses if they
are normal program behavior, but still need to be denied.
</p>

</body></subsection>
</section>

<section><title>Dissecting a Denial</title>
<subsection><body>
<p>
Denials contain varying amounts of information, depending on the access type.
</p>

<pre caption="Example Denials">
avc:  denied  { lock } for  pid=28341 exe=/sbin/agetty path=/var/log/wtmp dev=03:03 ino=475406
scontext=system_u:system_r:getty_t tcontext=system_u:object_r:var_log_t tclass=file

avc:  denied  { create } for  pid=20909 exe=/bin/ls scontext=pebenito:sysadm_r:mkinitrd_t
tcontext=pebenito:sysadm_r:mkinitrd_t tclass=unix_stream_socket

avc:  denied  { setuid } for  pid=3170 exe=/usr/bin/ntpd capability=7
scontext=system_u:system_r:ntpd_t tcontext=system_u:system_r:ntpd_t tclass=capability

</pre>

<p>
The most common denial relates to access of files.  For better understanding,
the first denial message will be broken down:
</p>
<table>
<tr><th>Component</th><th>Description</th></tr>
<tr><ti>avc:  denied</ti>
 <ti>SELinux has denied this access.</ti></tr>
<tr><ti>{ lock }</ti>
 <ti>The attempted access is a lock.</ti></tr>
<tr><ti>pid=28341</ti>
 <ti>The process ID performing this access is 28341.</ti></tr>
<tr><ti>exec=/sbin/agetty</ti>
 <ti>The full path and name of the process&#39;s executable is /sbin/agetty.</ti></tr>
<tr><ti>path=/var/log/wtmp</ti>
 <ti>The path and name of the target object is /var/log/wtmp.  Note: a complete
     path is not always available.</ti></tr>
<tr><ti>dev=03:03</ti>
 <ti>The target object resides on device 03:03 (major:minor number).
     On 2.6 kernels this may resolve to a name, hda3 in this example.</ti></tr>
<tr><ti>ino=475406</ti>
 <ti>The inode number of the target object is 475406.</ti></tr>
<tr><ti>scontext=system_u:system_r:getty_t</ti>
 <ti>The context of the program is system_u:system_r:getty_t.</ti></tr>
<tr><ti>tcontext=system_u:object_r:var_log_t</ti>
 <ti>The context of the target object is system_u:object_r:var_log_t.</ti></tr>
<tr><ti>tclass=file</ti>
 <ti>The target object is a normal file.</ti></tr>
</table>

<p>
Not all AVC messages will have all of these fields, as shown in the other
two denials.  The fields vary depending on the target object&#39;s class.
However, the most important fields: access type, source and target contexts,
and the target object&#39;s class will always be in an AVC message.
</p>
</body></subsection>

<subsection><title>Understanding the Denial</title><body>
<p>
Denials can be very confusing since they can be triggered for several reasons.
The key to understanding what is happening is to know the behavior of the
program, and to correctly interpret the denial message.  The target is not
limited to files; it could also be related to network sockets,
interprocess communications, or others.
</p>
<p>
In the above example, the agetty is denied locking of a file.  The file&#39;s type
is var_log_t, therefore it is implied that the target file is in /var/log.
With the extra information from the path= field in the denial message, it is
confirmed to be the file /var/log/wtmp.  If path information was unavailable,
this could be further confirmed by searching for the inode.  Wtmp is a file that has
information about users currently logged in, and agetty handles logins on
ttys.  It can be concluded that this is an expected access of agetty, for
updating wtmp.  However, why is this access being denied?  Is there a flaw
in the policy by not allowing agetty to update wtmp?  It turns out that wtmp
has the incorrect context.  It should be system_u:object_r:wtmp_t, rather
than system_u:object_r:var_log_t.
</p>
<p>
If this access was not understood, an administrator might mistakenly allow getty_t
read/write access to var_log_t files, which would be incorrect, since agetty
only needs to modify /var/log/wtmp.  This underscores how critical keeping
file contexts consistent is.
</p>
</body></subsection>
</section>

<section><title>References</title>
<subsection><body>
<p>
<uri link="http://www.nsa.gov/selinux">U.S. National Security Agency</uri>,
SELinux Policy README
</p>
</body></subsection>
</section>
</sections>
