<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/postgres-howto.xml,v 1.2 2006/03/16 21:25:36 neysx Exp $ -->

<guide link="/doc/pl/postgres-howto.xml" lang="pl">
<title>Poradnik PostgreSQL</title>

<author title="Author">
<mail link="chriswhite@gentoo.org">Chris White</mail>
</author>
<author title="Editor">
<mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Tłumacz">
<mail link="moloh@gentoo.org">Michał Kurgan</mail>
</author>

<abstract>
W poradniku tym znajduje się opis podstawowej konfiguracji PostgreSQL. Powinien
być on wystarczający dla prostych aplikacji webowych oraz innego oprogramowania
wspierającego PostgreSQL.
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>1.0</version>
<date>2006-03-14</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<title>Wprowadzenie do PostgreSQL</title>
<body>

<p>
Większość deweloperów zapytana o różne rozwiązania bazodanowe najprawdopodobniej
wymieni dwa najpopularniejsze i najbardziej efektywne. Będą to <c>MySQL</c> oraz
<c>PostgreSQL</c>, dokładniej opisany w tym dokumencie. Różnice i zalety obu
systemów bazodanowych mogą zamienić się w długą debatę, jednak należy zwrócić
uwagę że PostgreSQL jest bardziej związany z relacyjnym modelem przechowywania i
dostępu do danych. Wydawało by się że standardowa funkcjonalność jak <b>FOREIGN
KEY</b> powinna być zapewniona w każdym systemie SQL, i tak jest ale MySQL
doczekał się go dopiero w wersji 5.0. Niezależnie od zapewnianej funkcjonalności
i zalet obu rozwiązań dokument ten zawiera jedynie porady dotyczące PostgreSQL i
z pewnością będzie cennym źródłem informacji dla każdego posługującego się tym
systemem bazodanowym. Pierwszym krokiem jest oczywiście instalacja, w przypadku
Gentoo sprowadza się to do wykonania polecenia <c>emerge</c>. W kolejnych
rozdziałach zostanie opisany proces instalacji oraz podstawowej konfiguracji.
</p>

</body>
</section>
<section>
<title>Instalacja PostgreSQL</title>
<body>

<p>
Pierwszym krokiem jaki należy wykonać to instalacja pakietu PostgreSQL, należy
wykonać następujące polecenie, by przekonać się że wszystkie opcje są właściwie
ustawione:
</p>

<pre caption="Sprawdzenie dostępnych flag USE w pakiecie PostgreSQL">
# <i>emerge -pv postgresql</i>

These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] dev-db/postgresql-8.0.4  -doc -kerberos +libg++ +nls +pam +perl
-pg-hier -pg-intdatetime +python +readline (-selinux) +ssl -tcltk +xml2 +zlib 0 kB
</pre>

<p>
Poniżej znajduje się lista opcji wraz z krótkimi opisami:
</p>

<table>
<tr>
  <th>flaga USE</th>
  <th>Znaczenie</th>
</tr>
<tr>
  <ti>doc</ti>
  <ti>
    Włącza lub wyłącza instalacje dokumentacji z wyłączenie stron podręcznika
    man. Jedynym powodem aby nie używać tej flagi USE jest tylko mała ilość
    wolnej przestrzeni dyskowej lub alternatywna metoda dostępu do dokumentacji
    PostgreSQL (np. strona www).
  </ti>
</tr>
<tr>
  <ti>kerberos</ti>
  <ti>
    W czasie nawiązywania połączenia z bazą danych, w przypadku gdy ta opcji
    jest używana, administrator może skorzystać z metody autoryzacji
    <c>kerberos</c> by zweryfikować użytkowników lub usługi, które chcą uzyskać
    dostęp.
  </ti>
</tr>
<tr>
  <ti>libg++</ti>
  <ti>
    Włączenie tej flagi USE powoduje zbudowanie wiązań C++. Zostanie stworzona
    biblioteka libpg++ umożliwiająca dostęp do funkcjonalności PostgreSQL z
    poziomu języka C++.
  </ti>
</tr>
<tr>
  <ti>nls</ti>
  <ti>
    W przypadku używania tej opcji, PostgreSQL będzie używał tłumaczeń
    komunikatów co może być pomocne dla użytkowników nie posługujących się
    językiem angielskim.
  </ti>
</tr>
<tr>
  <ti>pam</ti>
  <ti>
    Odpowiednia konfiguracja serwera PostgreSQL oraz aktywacja tej flagi USE
    umożliwia administratorowi na użycie <c>PAM</c> (Pluggable Authentication
    Module) jako sposobu autoryzacji w czasie nawiązywania połączeń przez
    użytkowników z bazą danych.
  </ti>
</tr>
<tr>
  <ti>perl</ti>
  <ti>
    Włączenie tej opcji spowoduje zbudowanie wiązań PostgreSQL dla języka
    <c>perl</c>.
  </ti>
</tr>
<tr>
  <ti>pg-hier</ti>
  <ti>
    W przypadku włączenia tej opcji zostanie użyta poprawką umożliwiająca użycie
    hierarchicznych zapytań, takich jak polecenie <c>CONNECT</c> w przypadku
    serwerów bazodanowych <c>Oracle</c>. Więcej informacji na temat tego typu
    zapytań można znaleźć w <uri
    link="http://www.lc.leidenuniv.nl/awcourse/oracle/server.920/a96540/
    queries4a.htm">dokumentacji Oracle</uri>.
  </ti>
</tr>
<tr>
  <ti>pg-intdatetime</ti>
  <ti>
    Wsparcie w PostgreSQL dla 64-bitowych typów reprezentujących datę.
  </ti>
</tr>
<tr>
  <ti>python</ti>
  <ti>
    Włączenie tej opcji spowoduje zbudowanie wiązań PostgreSQL dla języka
    <c>python</c>.
  </ti>
</tr>
<tr>
  <ti>readline</ti>
  <ti>
    Opcja odpowiedzialna za wsparcie w PostgreSQL dla biblioteki
    <c>readline</c>. Ułatwia posługiwanie się terminalem, dodaje historię oraz
    opcję szukaj.
  </ti>
</tr>
<tr>
  <ti>selinux</ti>
  <ti>
    Włączenie tej opcji spowoduje instalację polis <c>selinux</c> dla
    PostgreSQL.
  </ti>
</tr>
<tr>
  <ti>ssl</ti>
  <ti>
    Załączenie tej flagi USE umożliwi wykorzystanie przez PostgreSQL biblioteki
    <c>OpenSSL</c> służącej do szyfrowania połączeń pomiędzy serwerami
    PostgreSQL i ich klientami.
  </ti>
</tr>
<tr>
  <ti>tcltk</ti>
  <ti>
    Włączenie tej opcji spowoduje zbudowanie wiązań PostgreSQL dla języka
    <c>tcl/tk</c>.
  </ti>
</tr>
<tr>
  <ti>xml2</ti>
  <ti>
    Włączenie tej opcji zapewni wsparcie dla <c>XPATH</c> w xmls. Więcej
    informacji na temat języka xml w PostgreSQL można znaleźć w dokumencie <uri
    link="http://www.throwingbeans.org/tech/postgresql_and_xml.html"> PostgreSQL
    and XML</uri> (język angielski).
  </ti>
</tr>
<tr>
  <ti>zlib</ti>
  <ti>
    Opcja ta nie jest używana przez sam PostgreSQL, ale przez <c>pg_dump</c>.
    Umożliwia kompresję tworzonych obrazów danych.
  </ti>
</tr>
</table>

<note>
Autor poprawki <c>pg-hier</c> przestał nad nią pracować. Zostanie ona
najprawdopodobniej usunięta w kolejnych wersjach.
</note>

<p>
Po włączeniu odpowiednich flag, tak by odpowiednio dostosować instalację bazy
danych, czas na kolejny krok - instalację:
</p>

<pre caption="Instalacja PostgreSQL">
# <i>emerge postgresql</i>
<comment>(Komunikaty zostały skrócone)</comment>
>>> /usr/lib/libecpg.so.5 -> libecpg.so.5.0
>>> /usr/bin/postmaster -> postgres
 * Make sure the postgres user in /etc/passwd has an account setup with /bin/bash as the shell
 *
 * Execute the following command
 * emerge --config =postgresql-8.0.4
 * to setup the initial database environment.
 *
>>> Regenerating /etc/ld.so.cache...
>>> dev-db/postgresql-8.0.4 merged.
</pre>

<p>
Jak pokazano na wydruku, po poprawnej kompilacji i instalacji PostgreSQL należy
jeszcze wykonać dodatkowe czynności przygotowujące bazę danych do pracy. W
kolejnym rozdziale zostanie opisany proces konfiguracji.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Konfiguracja PostgreSQL</title>
<section>
<title>Stworzenie bazowego środowiska dla bazy danych</title>
<body>

<p>
Po zakończonej sukcesem instalacji ebuild informuje nas o potrzebie stworzenia
środowiska bazowego, tak by móc uruchomić usługę. Jednak przed wykonaniem
podanego polecenia należy jeszcze zająć się jedną sprawą.  W przeciwieństwie do
MySQL, w przypadku PostgreSQL hasło administratora jest takie samo jak
użytkownika w systemie. Jest on tworzony przez ebuild, ale jego hasło <e>nie</e>
zostaje ustawione. Tak więc przed by móc rozpocząć właściwą konfigurację musimy
ustawić hasło dla użytkownika postgres:
</p>

<pre caption="Ustawienie hasła">
# <i>passwd postgres</i>
New UNIX password:
Retype new UNIX password:
passwd: password updated successfully
</pre>

<p>
Po ustawieniu odpowiedniego hasła można przystąpić do stworzenia podstawowego
środowiska PostgreSQL:
</p>

<pre caption="Konfiguracja środowiska bazodanowego poleceniem emerge --config">
# <i>emerge --config =postgresql-8.0.4</i>


Configuring pkg...

 * Creating the data directory ...
 * Initializing the database ...
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale C.

fixing permissions on existing directory /var/lib/postgresql/data ... ok
creating directory /var/lib/postgresql/data/global ... ok
creating directory /var/lib/postgresql/data/pg_xlog ... ok
creating directory /var/lib/postgresql/data/pg_xlog/archive_status ... ok
creating directory /var/lib/postgresql/data/pg_clog ... ok
creating directory /var/lib/postgresql/data/pg_subtrans ... ok
creating directory /var/lib/postgresql/data/base ... ok
creating directory /var/lib/postgresql/data/base/1 ... ok
creating directory /var/lib/postgresql/data/pg_tblspc ... ok
selecting default max_connections ... 100
selecting default shared_buffers ... 1000
creating configuration files ... ok
creating template1 database in /var/lib/postgresql/data/base/1 ... ok
initializing pg_shadow ... ok
enabling unlimited row size for system tables ... ok
initializing pg_depend ... ok
creating system views ... ok
loading pg_description ... ok
creating conversions ... ok
setting privileges on built-in objects ... ok
creating information schema ... ok
vacuuming database template1 ... ok
copying template1 to template0 ... ok

WARNING: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the -A option the
next time you run initdb.

Success. You can now start the database server using:

    /usr/bin/postmaster -D /var/lib/postgresql/data
or
    /usr/bin/pg_ctl -D /var/lib/postgresql/data -l logfile start

 *
 * You can use /etc/init.d/postgresql script to run PostgreSQL instead of pg_ctl.
 *
</pre>

<p>
Po wykonaniu polecenia, podstawowe środowisko, tabele i pliki konfiguracyjne
zostały utworzone. W kolejnej sekcji dowiemy się w jak sprawdzić poprawność
instalacji oraz poznamy sposoby kontroli dostęp do bazy danych przez
użytkowników.
</p>

</body>
</section>
<section>
<title>Konfiguracja PostgreSQL</title>
<body>

<p>
Po stworzeniu bazowego środowiska dobrze byłoby sprawdzić, czy wszystkie
czynności zostały prawidłowo wykonanie. Sprawdźmy więc czy usługa poprawnie
wystartuje:
</p>

<pre caption="Uruchomienie usługi PostgreSQL">
# <i>/etc/init.d/postgresql start</i>
* Starting PostgreSQL ...                                          [ ok ]
</pre>

<p>
Po poprawnym starcie dobrym pomysłem jest dodanie usługi do domyślnego poziomu
startowego, co spowoduje uruchomienie bazy danych w czasie startu systemu:
</p>

<pre caption="Dodanie demona PostgreSQL do domyślnego poziomu startowego">
# <i>rc-update add postgresql default</i>
* postgresql added to runlevel default
</pre>

<p>
Kolejnym krokiem po uruchomieniu demona PostgreSQL jest przetestowanie samej
bazy danych. Na początek skorzystamy z polecenia <c>createdb</c>, by utworzyć
testową bazę. Użyjemy opcji <c>-U</c> tak by ustawić użytkownika (domyślnie jest
to ten aktualnie zalogowany) oraz <c>-W</c> by wymusić interaktywne podanie
stworzonego wcześniej hasła. Ostatnim parametrem jest nazwa bazy danych, którą
chcemy utworzyć:
</p>

<pre caption="Stworzenie bazy danych poleceniem createdb">
$ <i>createdb -U postgres -W test</i>
Password:
CREATE DATABASE
</pre>

<p>
Testowa baza danych została utworzona, można teraz zadać kilka podstawowych
zapytań. Kolejnym krokiem weryfikującym poprawność instalacji, będzie jej
usunięcie, używamy polecenia <c>dropdb</c>. Nową, właściwą bazę danych utworzymy
później:
</p>

<pre caption="Usunięcie bazy danych poleceniem dropdb">
$ <i>dropdb -U postgres -W test</i>
Password:
DROP DATABASE
</pre>

<p>
Obecna, po wykonaniu wszystkich powyższych czynności, konfiguracja zezwala
jedynie użytkownikowi postgres na wydawanie poleceń. Nie jest to jednak zbyt
wygodne, szczególnie w środowisku wieloużytkowym. W kolejnej sekcji zajmiemy się
stworzeniem oraz ustawieniami kont użytkowników.
</p>

</body>
</section>
<section>
<title>Setting up database user accounts</title>
<body>

<p>
As mentioned earlier, having to login as the postgres user is somewhat
undesirable in a mult-user environment. In most cases there will be various
users and services accessing the server, and each have different permission
requirements. So, to handle this, the <c>createuser</c> command can be used.
This command is an alternative to running a few SQL queries, and is a lot more
flexible from an admin standpoint. We'll go ahead and create two users, a
'superuser' that can add other users and administer the db, and a standard user:
</p>

<pre caption="Setting up the superuser">
<comment>(replace chris with the username you'd like to use)</comment>
$ <i>createuser -a -d -P -E -U postgres -W chris</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
There, we've created the superuser. The command line option <c>-a</c> specifies
that this user can add other users. <c>-d</c> means that this user can create
databases. <c>-P</c> let's you enter a password for the user and <c>-E</c> will
encrypt it for security purposes. Now then, we'll test this new user's
permissions out by setting up our standard user:
</p>

<pre caption="Setting up the standard user">
<comment>(replace chris with the username you've just created)</comment>
$ <i>createuser -A -D -P -E -U chris -W testuser</i>
Enter password for new user:
Enter it again:
Password:
CREATE USER
</pre>

<p>
Success! Our new user was created using the previously created superuser. The
<c>-A</c> and <c>-D</c> options do the opposite of <c>-a</c> and <c>-d</c>, and
instead deny the user the ability to create other users and databases. Now that
there are users to work with, and a new database created, the next chapter will
look at using the new database.
</p>

</body>
</section>
</chapter>
<chapter>
<title>Using PostgreSQL</title>
<section>
<title>Setting up permissions</title>
<body>

<p>
With the new database created, there is a user that can create databases and
add other users, and the main postgres user that can do anything. The user
created earlier can currently login to the server, and that's about it. In
general, users need to be able to insert data and retrieve data, and sometimes
any other number of tasks. So, for this new user to be able to do anything,
they must be setup with the proper permissions. This can easily be done by
passing the <c>-O</c> parameter to <c>createdb</c>. We'll start by making a
new database, <b>MyDB</b> with our superuser that will be owned by the previous
testuser:
</p>

<pre caption="Creating the MyDB database">
$ <i>createdb -O testuser -U chris -W MyDB</i>
Password:
CREATE DATABASE
</pre>

<p>
Alright, now we have a new MyDB database, and a testuser that can access it.
To test this out, we'll login as the testuser to the new MyDB database. We'll
do this with the <c>psql</c> program. This program is what's used to connect to
the PostgreSQL database from command line. So connect to the new database like
so:
</p>

<pre caption="Logging into the MyDB database as the testuser">
$ <i>psql -U testuser -W MyDB</i>
Password:
Welcome to psql 8.0.4, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

MyDB=&gt;
</pre>

<p>
So, the testuser is now logged into the database, and can begin to initiate
some commands. To get a feel for using PostgreSQL, the next section will take a
look at some of the basic commands in navigating the <c>psql</c> client.
</p>

</body>
</section>
<section>
<title>Basic PostgreSQL commands and creating a table</title>
<body>

<p>
For those who are used to MySQL, this is somewhat of a definite read. This is
where PostgreSQL may get somewhat unique with regards to running commands. To
start, here is a list of some commands that will be discussed:
</p>

<table>
<tr>
  <th>Command</th>
  <th>Usage</th>
  <th>MySQL Equivalent</th>
</tr>
<tr>
  <ti>\c[onnect] [DBNAME|- [USER]]</ti>
  <ti>Connects to another database</ti>
  <ti>USE DATABASE</ti>
</tr>
<tr>
  <ti>\q</ti>
  <ti>Quit the <c>psql</c> client</ti>
  <ti>quit</ti>
</tr>
<tr>
  <ti>\i FILE</ti>
  <ti>Run commands from <c>FILE</c></ti>
  <ti>source FILE</ti>
</tr>
<tr>
  <ti>\o [FILE]</ti>
  <ti>Send query results to <c>FILE</c></ti>
  <ti>INTO OUTFILE, but outputs everything (not just SELECTS)</ti>
</tr>
<tr>
  <ti>\d [NAME]</ti>
  <ti>Describe a database or table (as well as other items)</ti>
  <ti>DESC(RIBE)</ti>
</tr>
<tr>
  <ti>\db [PATTERN]</ti>
  <ti>
    List available tables that match <c>PATTERN</c> (all if no pattern
    is given)
  </ti>
  <ti>SHOW TABLES</ti>
</tr>
</table>

<p>
With the exception of <c>\c[onnect]</c>, all the commands shown will be used
later on in the section. So right now the database is empty. That said, we need
to insert some data. The first step to inserting data, however, is to put it in
a table. Right now there are no tables in the database, so we need to create
one. This is done with the <c>CREATE TABLE</c> command.  We'll make a table of
items. They will contain a Product ID, Description, and price:
</p>

<pre caption="Creating the products table">
MyDB=> CREATE TABLE products (
MyDB(&gt;   product_id SERIAL,
MyDB(&gt;   description TEXT,
MyDB(&gt;   price DECIMAL
MyDB(&gt; );
NOTICE:  CREATE TABLE will create implicit sequence "products_product_id_seq"
for serial column "products.product_id"
CREATE TABLE
</pre>

<p>
You can ignore the NOTICE, it's perfectly harmless. Looking at the last line of
the function, <c>CREATE TABLE</c> seems to indicate that the command has
succeeded. However, let's go ahead and verify that the table was indeed
successfully created with the <c>\d</c> command:
</p>

<pre caption="Looking at the newly created table">
MyDB=&gt; <i>\d products</i>
                                 Table "public.products"
   Column    |  Type   |                            Modifiers
-------------+---------+------------------------------------------------------------------
 product_id  | integer | not null default nextval('public.products_product_id_seq'::text)
 description | text    |
 price       | numeric |
</pre>

<p>
Indeed the table was successfully created. Now that the table is created, it
needs to be populated with data. The next section will look at populating the
database with data.
</p>

</body>
</section>
<section>
<title>Inserting data into the database</title>
<body>

<p>
This section will look at the two ways of populating the newly created table
with data. First let's look at the most basic command, <c>INSERT</c>:
</p>

<pre caption="INSERT syntax">
INSERT INTO [tablename] (column1,column2,column3) VALUES(value1,value2,value3)
</pre>

<p>
<c>tablename</c> contains the name of the table to insert the data into.
(column1,column2,column3) lets you specify the specific columns to insert the
values into. VALUES(value1,value2,value3) is the listing of values. The values
are inserted into the same order as the columns (column1 gets value1, column2
gets value2, column3 gets value3). These counts <e>must</e> be the same. So
let's go ahead and insert an item into the table:
</p>

<impo>
From working with databases for a long time, I personally recommend specifying
<c>INSERT</c> statements exactly as above. Developers often make the mistake of
using <c>INSERT INTO</c> without specifying columns. This is unproductive, as
if a new column gets added to the database, it will cause in error if the value
to column count is not the same. You should <e>always</e> specify the columns
unless you're 300% sure you'll never add a column.
</impo>

<pre caption="Inserting data into the table">
MyDB=&gt; <i>INSERT INTO products (description,price) VALUES('A test product', 12.00);</i>
INSERT 17273 1
</pre>

<p>
The last line needs a bit of explaining. The return of an insert command is an
OID (Object Identifier) and the number of rows inserted. OID's are a bit beyond
the scope of this guide, and the <uri
link="http://www.postgresql.org/docs/8.1/static/datatype-oid.html">PostgreSQL
manual</uri> has some good information on it. Now, for a situation where you
have 20,000 products, these insert statements can be a little tedious. However,
not all is lost. The <c>COPY</c> command can be used to insert data into a
table from a file or stdin. In this example, let's assume that you have a csv
(comma separated values) file, which contains the product id, description, and
price. The file looks like this:
</p>

<pre caption="products.csv">
2,meat,6.79
3,soup,0.69
4,soda,1.79
</pre>

<p>
Now we'll use the <c>COPY</c> command to populate our data:
</p>

<impo>
The <c>COPY FROM STDIN</c> command is used because only the postgres user can
insert data from a file (for obvious security reasons).
</impo>

<pre caption="Using COPY to populate the products table">
MyDB=&gt; <i>COPY products FROM STDIN WITH DELIMITER AS ',';</i>
Enter data to be copied followed by a newline.
End with a backslash and a period on a line by itself.
>> <i>2,meat,6.79</i>
>> <i>3,soup,0.69</i>
>> <i>4,soda,1.79</i>
>> <i>\.</i>
</pre>

<p>
Unfortunately, this line doesn't return the same status information as the
<c>INSERT INTO</c> statement. How do we know the data was inserted? The next
section will look at running queries to check our data.
</p>

</body>
</section>
<section>
<title>Using PostgreSQL queries</title>
<body>

<p>
This section will look at using the <c>SELECT</c> statement to view data in our
tables. The basic <c>SELECT</c> format looks like this:
</p>

<pre caption="SELECT syntax">
SELECT (column1,column2|*) FROM (table) [WHERE (conditionals)]
</pre>

<p>
There are two ways to select columns. The first is using <c>*</c> to select all
columns, and the second is to specify a list of specific columns you wish to
see. The second is quite handy when you want to find a specific column in a
rather large list of them. Let's start out with using <c>SELECT</c> with
<c>*</c> to specify all columns:
</p>

<pre caption="Viewing the products table">
MyDB=&gt; <i>SELECT * FROM products;</i>
 product_id |  description   | price
------------+----------------+-------
          1 | A test product | 12.00
          2 | meat           |  6.79
          3 | soup           |  0.69
          4 | soda           |  1.79
(4 rows)
</pre>

<p>
As shown here, all the data we inserted earlier is indeed in the table. Now
let's say we only want to see the description and the price, and don't care
about the product id. In this case we'll use the column specific SELECT form:
</p>

<pre caption="Viewing specific columns from the products table">
MyDB=&gt; <i>SELECT description,price FROM products;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
 soup           |  0.69
 soda           |  1.79
(4 rows)
</pre>

<p>
Now only the product and price is shown, letting us focus on only the important
data. Now let's say that we want to see only the items that are greater than
$2.00. Here's where the <c>WHERE</c> clause comes in handy:
</p>

<pre caption="Viewing specific rows from the products table">
MyDB=&gt; <i>SELECT description,price FROM products WHERE price > 2.00;</i>
  description   | price
----------------+-------
 A test product | 12.00
 meat           |  6.79
(2 rows)
</pre>

<p>
Now a listing of products over $2.00 is displayed, focusing the data even more.
These forms of querying for information are very powerful, and can help create
extremely useful reports.
</p>

</body>
</section>
<section>
<title>Conclusion</title>
<body>

<p>
This concludes the PostgreSQL Guide. A big thanks goes to Masatomo Nakano, the
Gentoo PostgreSQL maintainer for his help in answering my questions. Any
suggestions on this guide should be sent to <mail>chriswhite@gentoo.org</mail>.
For more extensive documentation, see the <uri
link="http://www.postgresql.org">PostgreSQL website</uri>.
</p>

</body>
</section>
</chapter>
</guide>
