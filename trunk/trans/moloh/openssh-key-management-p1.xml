<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/articles/openssh-key-management-p1.xml,v 1.3 2005/10/09 17:13:23 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/articles/openssh-key-management-p1.xml" disclaimer="articles">
<title>OpenSSH key management, Part 1</title>
<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Tłumacz">
  <mail link="moloh@moloh.net">Michał Kurgan</mail>
</author>

<!-- xmlified by Max Lorenz (anarchyisgoodforthee@gmail.com) -->

<abstract>
W tej serii artykułów, będzie można się dowiedzieć ciekawych informacji na temat
zasad funkcjonowania RSA i DSA m.in. jak w prawidłowy sposób skonfigurować
autentykację bez hasła. W pierwszym artykule, Daniel Robbins wprowadza w arkana
protokołów uwierzytelniania, RSA i DSA i pokazuje co należy zrobić aby można
było ich używać poprzez sieć.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This document
is an updated version of the original article, and contains various improvements
made by the Gentoo Linux Documentation team -->

<version>1.1</version>
<date>2005-10-09</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<body>

<p>
Wielu użytkowników używa doskonałego OpenSSH (zobacz punkt <uri
link="#materiały">Materiały</uri> na końcu artykułu) jako bezpiecznego i
kodowanego odpowiednika szacownego polecenia <c>telnet</c> i <c>rsh<c>. Jedną z
ciekawszych funkcjonalności OpenSSH jest możliwość dokonania autoryzacji przy
użyciu protokołów RSA i DSA, które bazują na parze uzupełniających się kluczy.
Jedną z ich głównych zalet jest możliwość nawiązania połączenia <e>bez podawania
hasła</e>. Sama możliwość jest niezwykle interesująca, niestety początkujący
użytkownicy OpenSSH konfigurują RSA/DSA w szybki i niezbyt udany sposób, co
oczywiście umożliwia dokonanie logowania bez podawania hasła, ale niestety
tworzy też lukę, która może zostać wykorzystania do dokonania włamania.
</p>

</body>
</section>
<section>
<title>Co to jest uwierzytelnianie RSA/DSA?</title>
<body>

<p>
SSH, szczególnie OpenSSH (wolna implementacja SSH), jest niebywałym narzędziem.
Podobnie jak <c>telnet</c>, czy <c>rsh</c>, klient ssh może zostać użyty by
zalogować się na zdalnym komputerze. Jedynym wymaganiem jest by na niej był
uruchomiony demon <c>sshd</c>, będący serwerem <c>ssh</c>. Jednak w odróżnieniu
od <c>telnetu</c>, protokół ssh jest bezpieczny. Używa on specjalnych
algorytmów, by zakodować strumień danych, zapewnić jego spójność, a także
dokonać uwierzytelniania w bezpieczny i wygodny dla użytkownika sposób.
</p>

<p>
Jednak, pomimo tego że <c>ssh</c> jest naprawdę bardzo użyteczne, duża część
jego funkcjonalności nie jest zazwyczaj używana, lub, co gorsze, używana w
nieodpowiedni sposób. Najczęściej błędy zdarzają się w module autentykacji z
użyciem klucza RSA/DSA, który domyślnie nie jest używany. Wykorzystywane jest
natomiast uwierzytelnianie z użyciem hasła.
</p>

<p>
Protokół autentykacji RSA/DSA używany w OpenSSH bazuje na parze specjalnie
wygenerowanych kluczy, <e>kluczu prywatnym</e> i <e>kluczu publicznym</e>.
Zaletą tej metody jest możliwość nawiązania bezpiecznego połączenia bez
ręcznego wpisywania hasła.
</p>

<p>
Protokoły autentykacji bazujące na wymianie kluczy są relatywnie bezpieczne,
problemem niestety stają się nawyki stosujących je użytkowników, którzy nie w
pełni zdają sobie sprawę z grożącego im niebezpieczeństwa. W pierwszym artykule
przedstawione zostaną metody właściwego postępowania, tak by nie narażać się na
zbędne ryzyko.  W drugim znajdzie się opis skryptu <c>ssh-agent</c> buforującego
odkodowane klucze prywatne, oraz prezentacja programu <c>keychain</c>, będącego
nakładką na <c>ssh-agent</c>, która oferuje znacznie większą funkcjonalność, co
ważne zachowując odpowiedni poziom bezpieczeństwa. Każdy zainteresowany
zaawansowaną funkcjonalnością OpenSSH z pewnością powinien kontynuować lekturę,
wszystkich innych gorąco do tego zachęcamy.
</p>

</body>
</section>
<section>
<title>Jak działają klucze RSA/DSA</title>
<body>

<p>
W rozdziale znajduje się krótki opis przedstawiający ideę działania kluczy
RSA/DSA. Zacznijmy od opisania hipotetycznej sytuacji w której chcemy użyć
uwierzytelniania RSA by umożliwić lokalnej stacji roboczej, pracującej pod
kontrolą systemu Linux (nazwijmy ją <e>lokalna</e>), nawiązanie zdalnego
połączenia i otwarcia powłoki na zdalnym komputerze (tą z kolei nazwijmy
<e>zdalna</e>). W chwili obecnej gdy będziemy próbowali nawiązać takie
połączenie, używając klienta <c>ssh</c> zostaniemy powitani następującym
komunikatem:
</p>

<pre caption="Połączenie ze zdalną">
$ <i>ssh drobbins@zdalna</i>
drobbins@zdalna's password:
</pre>

<p>
Na przedstawionym przykładzie widzimy <e>domyślną</e> dla <c>ssh</c> metodę
autentykacji. Zostaliśmy poproszeni o podanie hasła dla użytkownika
<e>drobbins</e> na komputerze <e>zdalna</e>. Teraz jeśli postąpimy zgodnie z
instrukcjami <c>ssh</c>, używając swojego bezpiecznego protokołu
uwierzytelniania, prześle podane hasło przez sieć do <e>zdalnej</e> by dokonać
odpowiedniej weryfikacji. Jednak w przeciwieństwie do <c>telnetu</c>, dane
przesyłane są w formie zakodowanej, więc hasło nie może zostać w łatwy sposób
przechwycone przez kogoś podsłuchującego nasze połączenie. Po porównaniu
przesłanego hasła z zawartością bazy znajdującej się na <e>zdalnej</e>,
połączenie zostaje zestawione, w przypadku gdy hasła są takie same, lub zerwane
w przeciwnym przypadku. Domyślna metoda weryfikacji stosowana przez <c>ssh</c>
jest całkiem bezpieczna, jednak wykorzystanie RSA i DSA daje nam wiele nowych i
interesujących możliwości.
</p>

<p>
Jednak w przeciwieństwie do uwierzytelniania z użyciem hasła, autentykacja RSA
wymaga dokonania pewnych zmian w konfiguracji. Na szczęście zmiany te musimy
wykonać tylko jeden raz, a po ich dokonaniu nawiązanie bezpiecznego połączenia z
<e>lokalnej</e> na <e>zdalną</e> będzie bardzo proste. Pierwszą czynnością jaką
musimy wykonać, jest stworzenie pary kluczy, jednego prywatnego i jednego
publicznego. Taka para kluczy posiada bardzo interesujące właściwości, klucz
publiczny może służyć tylko do <e>szyfrowania</e> wiadomości, którą odczytać
będzie mógł tylko właściciel klucza prywatnego, jako że tylko on może z
powodzeniem zostać użyty do <e>deszyfracji</e> wcześniej zakodowanej informacji.
Protokół uwierzytelniania RSA (i DSA) używa tej specjalnej właściwości pary
kluczy, by nawiązać bezpieczne połączenie, nie ma potrzeby wysyłania przez sieć
żadnych tajnych informacji.
</p>

<p>
By móc skorzystać z dobrodziejstw uwierzytelniania RSA i DSA musimy
przeprowadzić prostą i krótką procedurę konfiguracji, kopiujemy <e>klucz
publiczny</e> na <e>zdalną<e/>. Klucz ten nie jest nazywany "publicznym" bez
powodu. Jako, że może on zostać użyty jedynie do <e>szyfrowania</e> wiadomości
przeznaczonych dla nas (właściciela klucza prywatnego), nie musimy się
przejmować jeśli wpadnie w niepowołane ręce. Gdy zostanie on przekopiowany na
<e>zdalną</e> i zapisany w specjalnym pliku
(<path>~/.ssh/authorized_keys</path>), demon <c>sshd</c> uruchomiony na
<e>zdalnej<e/> będzie mógł go znaleźć, będziemy wtedy gotowi do nawiązania
połączenia z użyciem uwierzytelniania RSA.
</p>

<p>
Wystarczy już tylko wpisać <c>ssh drobbins@zdalna</c>, będąc zalogowanym na
<e>lokalnej</e>. Do tej pory postępowanie jest podobne, jednak od tego momentu
procedura nawiązywania połączenia wygląda już inaczej. Klient <c>ssh</c>
informuje demona <c>sshd</c>, uruchomionego na <e>zdalnej</e>, że chce użyć
protokołu RSA, by dokonać uwierzytelniania. W odpowiedzi wysyłana jest na nasz
lokalny komputer, zaszyfrowana kluczem publicznym, losowa liczba, która zostaje
odszyfrowana dzięki użyciu klucza publicznego i wysłana na <e>zdalną<e>, jakby
mówiąc "Widzisz, ja naprawdę <e>posiadam<e> pasujący klucz prywatny; Udało mi
się poprawnie odczytać zakodowaną wiadomość!" Ostatnim etapem jest weryfikacja,
czy zwrócona liczba odpowiada wysłanej i w przypadku pozytywnej odpowiedzi demon
<c>sshd</c> doje nam dostęp do <e>zdalnej</e>. Należy zauważyć, że cała
procedura odbywa się w sposób automatyczny i nie wymaga żadnej ingerencji
użytkownika.
</p>

</body>
</section>
<section>
<title>Dwa wnioski</title>
<body>

<p>


There are two important observations about the RSA and DSA authentication. The
first is that we really only need to generate one pair of keys. We can then
copy our public key to the remote machines that we'd like to access and they
will all happily authenticate against our single private key. In other words,
we don't need a key pair for <e>every</e> system we'd like to access. Just one
pair will suffice.
</p>

<p>
The other observation is that our <e>private key should not fall into the wrong
hands</e>. The private key is the one thing that grants us access to our remote
systems, and anyone that possesses our private key is granted exactly the same
privileges that we are. Just as we wouldn't want strangers to have keys to our
house, we should protect our private key from unauthorized use. In the world of
bits and bytes, this means that no one should be able to read or copy our
private key.
</p>

<p>
Oczywiście deweloperzy <c>ssh</c> doskonale zdają sobie sprawę z tego jak ważne
są klucze prywatne i dlatego wbudowali kilka dodatkowych zabezpieczeń w
<c>ssh</c> i <c>ssh-keygen</c> tak, by nie można w łatwy sposób przechwycić
kluczy. Po pierwsze, w przypadku gdy klucz będzie w stanie odczytać ktokolwiek
za wyjątkiem jego właściciela to zostaniemy o tym poinformowani. Dzięki czemu
będziemy wiedzieć, że z uprawnienia do pliku przechowującego klucze prywatne
powinny zostać poprawione. Po drugie, gdy tworzymy parę kluczy,
<c>ssh-keygen</c> prosi o podanie hasła. Jeżeli je podamy to klucz prywatny
zostanie zaszyfrowany z jego użyciem, więc nawet gdy ktoś niepowołany uzyska
dostęp do pliku przechowującego klucze, to bez znajomości hasła nie będzie mógł
go wykorzystać. Po poznaniu najważniejszych elementów związanych z generacją
kluczy czas na opis konfiguracji <c>ssh</c> tak, by używał protokołów
uwierzytelniania RSA i DSA.
</p>

</body>
</section>
<section>
<title>Generacja kluczy z bliska</title>
<body>

<p>
Pierwszym krokiem w czasie konfiguracji uwierzytelniania RSA jest stworzenie
pary kluczy, prywatnego i publicznego. Protokół autentykacji RSA, będący
podstawią metod uwierzytelniania używanych przez <c>ssh</c>, wszystko będzie
działało poprawnie w przypadku każdej wersji OpenSSH, ale pomimo tego najlepiej
jest posiadać najnowszą dostępną wersję, w czasie pisania tego artykułu była to
openssh-2.9_p2 {{ FIXME - przy tłumaczeniu to 4.2_p1 }}. By wygenerować parę
kluczy RSA należy postępować następująco:
</p>

<pre caption="Narzędzie ssh-keygen">
$ <i>ssh-keygen</i>
Generating public/private rsa1 key pair.
Enter file in which to save the key (/home/drobbins/.ssh/identity): <comment>(naciśnij enter)</comment>
Enter passphrase (empty for no passphrase): <comment>(wpisz hasło)</comment>
Enter same passphrase again: <comment>(wpisz ponownie hasło)</comment>
Your identification has been saved in /home/drobbins/.ssh/identity.
Your public key has been saved in /home/drobbins/.ssh/identity.pub.
The key fingerprint is:
a4:e7:f2:39:a7:eb:fd:f8:39:f1:f1:7b:fe:48:a1:09 drobbins@lokalna
</pre>

<p>
Gdy <c>ssh-keygen</c> pyta nas o lokalizację kluczy, wciskamy enter by
zatwierdzić domyślną wartość (<path>/home/drobbins/.ssh/identity</path>).
Wygenerowane klucze prywatne będą przechowywane w powyższej lokalizacji,
podobnie jak klucz <e>publiczny</e>, który będzie znajdował się w pliku
identity.pub.
</p>

<p>
Należy zauważyć, że <c>ssh-keygen</c> zapytał nas o hasło. Najlepiej gdy będzie
ono odpowiednio skomplikowane i długie (siedem lub więcej ciężkich do
przewidzenia znaków). Klucz prywatny zostanie z zaszyfrowany
(<path>~/.ssh/identity</path>) właśnie przy jego użyciu, wtedy nawet gdy ktoś
pozna nasz klucz prywatny, będzie on dla niego bezwartościowy gdy nie będzie
także znał podanego hasła.
</p>

</body>
</section>
<section>
<title>The quick compromise</title>
<body>

<p>
When we specify a passphrase, it allows <c>ssh-keygen</c> to secure our private
key against misuse, but it also creates a minor inconvenience. Now, every time
we try to connect to our <e>drobbins@remotebox</e> account using <c>ssh</c>,
<c>ssh</c> will prompt us to enter the passphrase so that it can decrypt our
private key and use it for RSA authentication. Again, we won't be typing in our
password for the <e>drobbins</e> account on <e>remotebox</e>, we'll be typing
in the passphrase needed to locally decrypt our private key.  Once our private
key is decrypted, our <c>ssh</c> client will take care of the rest. While the
mechanics of using our remote password and the RSA passphrase are completely
different, in practice we're still prompted to type a "secret phrase" into
<c>ssh</c>.
</p>

<pre caption="Logging in with passphrase">
$ <i>ssh drobbins@remotebox</i>
Enter passphrase for key '/home/drobbins/.ssh/identity': <comment>(enter passphrase)</comment>
Last login: Thu Jun 28 20:28:47 2001 from localbox.gentoo.org 

Welcome to remotebox!

$
</pre>

<p>
However, while this is convenient, you shouldn't use this approach without
fully understanding its security impact. With an unencrypted private key, if
anyone ever hacks into <e>localbox</e>, they'll also get automatic access to
<e>remotebox</e> and any other systems that have been configured with the
public key.
</p>

<p>
I know what you're thinking. Passwordless authentication, despite being a bit
risky does seem really appealing. I totally agree. But <e>there is a better
way!</e> Stick with me, and I'll show you how to gain the benefits of
passwordless authentication without compromising your private key security.
I'll show you how to masterfully use <c>ssh-agent</c> (the thing that makes
<e>secure</e> passwordless authentication possible in the first place) in my
next article. Now, let's get ready to use <c>ssh-agent</c> by setting up RSA
and DSA authentication. Here step-by-step directions.
</p>

</body>
</section>
<section>
<title>RSA key pair generation</title>
<body>

<p>
To set up RSA authentication, we'll need to perform the one-time step of
generating a public/private key pair. We do this by typing:
</p>

<pre caption="Generating keys...">
$ <i>ssh-keygen</i>
</pre>

<p>
Accept the default key location when prompted (typically
<path>~/.ssh/identity</path> and <path>~/.ssh/identity.pub</path> for the
public key), and provide <c>ssh-keygen</c> with a secure passphrase. Once
<c>ssh-keygen</c> completes, you'll have a public key as well as a
passphrase-encrypted private key.
</p>

</body>
</section>
<section>
<title>RSA public key install</title>
<body>

<p>
Next, we'll need to configure remote systems running <c>sshd</c> to use our
<e>public</e> RSA key for authentication. Typically, this is done by copying
the public key to the remote system as follows:
</p>

<pre caption="Copying the public key">
$ <i>scp ~/.ssh/identity.pub drobbins@remotebox:</i>
</pre>

<p>
Since RSA authentication isn't fully set up yet, we'll be prompted to enter our
password on <e>remotebox</e>. Do so. Then, log in to <e>remotebox</e> and
append the public key to the <path>~/.ssh/authorized_keys</path> file like so:
</p>

<pre caption="Installing the public key">
$ <i>ssh drobbins@remotebox</i>
drobbins@remotebox's password: <comment>(enter password)</comment>
Last login: Thu Jun 28 20:28:47 2001 from localbox.gentoo.org 

Welcome to remotebox!

$ <i>cat identity.pub >> ~/.ssh/authorized_keys</i>
$ <i>exit</i>
</pre>

<p>
Now, with RSA authentication configured, we should be prompted to enter our RSA
<e>passphrase</e> (rather than our <e>password</e>) when we try to connect to 
<e>remotebox</e> using <c>ssh</c>.
</p>

<pre caption="Logging in with pubkey authentication">
$ <i>ssh drobbins@remotebox</i>
Enter passphrase for key '/home/drobbins/.ssh/identity': 
</pre>

<p>
Hurray, RSA authentication configuration complete! If you weren't prompted for
a passphrase, here are a few things to try. First, try logging in by typing
<c>ssh -1 drobbins@remotebox</c>. This will tell ssh to only use version 1 of
the ssh protocol, and may be required if for some reason the remote system is
defaulting to DSA authentication. If that doesn't work, make sure that you
don't have a line that reads <c>RSAAuthentication no</c> in your
<path>/etc/ssh/ssh_config</path>. If you do, comment it out by pre-pending it
with a "#". Otherwise, try contacting the <e>remotebox</e> system administrator
and verifying that they have enabled RSA authentication on their end and have
the appropriate settings in <path>/etc/ssh/sshd_config</path>.
</p>

</body>
</section>
<section>
<title>DSA key generation</title>
<body>

<p>
While RSA keys are used by version 1 of the <c>ssh</c> protocol, DSA keys are
used for protocol level 2, an updated version of the <c>ssh</c> protocol. Any
modern version of OpenSSH should be able to use both RSA and DSA keys.
Generating DSA keys using OpenSSH's <c>ssh-keygen</c> can be done similarly to
RSA in the following manner:
</p>

<pre caption="Generating a DSA key pair">
$ <i>ssh-keygen -t dsa</i>
</pre>

<p>
Again, we'll be prompted for a passphrase. Enter a secure one. We'll also be
prompted for a location to save our DSA keys. The default, normally
<path>~/.ssh/id_dsa</path> and <path>~/.ssh/id_dsa.pub</path>, should be fine.
After our one-time DSA key generation is complete, it's time to install our DSA
public key to remote systems.
</p>

</body>
</section>
<section>
<title>DSA public key install</title>
<body>

<p>
Again, DSA public key installation is almost identical to RSA. For DSA, we'll
want to copy our <path>~/.ssh/id_dsa.pub</path> file to <e>remotebox</e>, and
then append it to the <path>~/.ssh/authorized_keys2</path> on <e>remotebox</e>.
Note that this file has a different name than the RSA
<path>authorized_keys</path> file. Once configured, we should be able to log in
to <e>remotebox</e> by typing in our DSA private key passphrase rather than
typing in our actual <e>remotebox</e> password.
</p>

<note>
Nowadays you should only use version 2 of the ssh protocol, as version 1 has
weaknesses.
</note>

</body>
</section>
<section>
<title>Next time</title>
<body>

<p>
Right now, you should have RSA or DSA authentication working, but you still
need to type in your passphrase for every new connection. In my next article,
we'll see how to use <c>ssh-agent</c>, a really nice system that allows us to
establish connections <e>without</e> supplying a password, but also allows us
to keep our private keys encrypted on disk. I'll also introduce
<c>keychain</c>, a very handy <c>ssh-agent</c> front-end that makes
<c>ssh-agent</c> even more secure, convenient, and fun to use. Until then,
check out the handy resources below to keep yourself on track.
</p>

</body>
</section>
</chapter>
<chapter id="resources">
<title>Resources</title>
<section>
<body>

<ul>
  <li>
    Read Daniel's other two articles in this series, <uri
    link="/doc/en/articles/openssh-key-management-p2.xml">OpenSSH key 
    management, Part 2</uri> and <uri 
    link="/doc/en/articles/openssh-key-management-p3.xml">OpenSSH key 
    management, Part 3</uri>
  </li>
  <li>
    Be sure to visit the home of <uri
    link="http://www.openssh.com">OpenSSH</uri> development.
  </li>
  <li>
    Check out the <uri link="http://www.openssh.com/faq.html">OpenSSH
    FAQ</uri>.
  </li>
  <li>
    <uri link="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</uri>
    is an excellent <c>ssh</c> client for Windows machines.
  </li>
  <li>
    You may find O'Reilly's <e>SSH, The Secure Shell: The Definitive Guide</e>
    to be helpful. The <uri link="http://www.snailbook.com/">authors'
    site</uri> contains information about the book, a FAQ, news, and updates.
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
