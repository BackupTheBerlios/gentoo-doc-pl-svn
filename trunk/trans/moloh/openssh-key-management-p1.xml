<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/articles/openssh-key-management-p1.xml,v 1.3 2005/10/09 17:13:23 rane Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/pl/articles/openssh-key-management-p1.xml" disclaimer="articles">
<title>Zarządzanie kluczami OpenSSH, Część 1</title>
<author title="Autor">
  <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Tłumacz">
  <mail link="moloh@gentoo.org">Michał Kurgan</mail>
</author>

<!-- xmlified by Max Lorenz (anarchyisgoodforthee@gmail.com) -->

<abstract>
W tej serii artykułów, będzie można się dowiedzieć ciekawych informacji na temat
zasad funkcjonowania RSA i DSA m.in. jak w prawidłowy sposób skonfigurować
autentykację bez hasła. W pierwszym artykule, Daniel Robbins wprowadza w arkana
protokołów uwierzytelniania RSA i DSA i pokazuje co należy zrobić aby można
było ich używać poprzez sieć.
</abstract>

<!-- The original version of this article was first published on IBM
developerWorks, and is property of Westtech Information Services. This document
is an updated version of the original article, and contains various improvements
made by the Gentoo Linux Documentation team -->

<version>1.1</version>
<date>2005-10-09</date>

<chapter>
<title>Wprowadzenie</title>
<section>
<body>

<p>
Wielu użytkowników używa doskonałego OpenSSH (zobacz punkt <uri
link="#materiały">Materiały</uri> na końcu artykułu) jako bezpiecznego i
szyfrowanego odpowiednika szacownego polecenia <c>telnet</c> i <c>rsh</c>. Jedną
z ciekawszych funkcjonalności OpenSSH jest możliwość dokonania autoryzacji przy
użyciu protokołów RSA i DSA, które bazują na parze uzupełniających się kluczy.
Jedną z ich głównych zalet jest możliwość nawiązania połączenia <e>bez podawania
hasła</e>. Sama możliwość jest niezwykle interesująca, niestety początkujący
użytkownicy OpenSSH konfigurują RSA/DSA w szybki i niezbyt udany sposób, co
oczywiście umożliwia dokonanie logowania bez podawania hasła, ale niestety
tworzy też lukę, która może zostać wykorzystania do dokonania włamania.
</p>

</body>
</section>
<section>
<title>Co to jest uwierzytelnianie RSA/DSA?</title>
<body>

<p>
SSH, szczególnie OpenSSH (wolna implementacja SSH), jest niebywałym narzędziem.
Podobnie jak <c>telnet</c>, czy <c>rsh</c>, klient ssh może zostać użyty by
zalogować się na zdalnym komputerze. Jedynym wymaganiem jest by na niej był
uruchomiony demon <c>sshd</c>, będący serwerem <c>ssh</c>. Jednak w odróżnieniu
od <c>telnetu</c>, protokół ssh jest bezpieczny. Używa on specjalnych
algorytmów, by zakodować strumień danych, zapewnić jego spójność, a także
dokonać uwierzytelniania w bezpieczny i wygodny dla użytkownika sposób.
</p>

<p>
Jednak, pomimo tego że <c>ssh</c> jest naprawdę bardzo użyteczne, duża część
jego funkcjonalności nie jest zazwyczaj używana, lub, co gorsze, używana w
nieodpowiedni sposób. Najczęstsze błędy zdarzają się w module uwierzytelniania
RSA/DSA, który domyślnie nie jest jednak używany, domyślną metodą autentykacji
jest weryfikacja hasła użytkownika.
</p>

<p>
Protokół autentykacji RSA/DSA używany w OpenSSH bazuje na parze specjalnie
wygenerowanych kluczy, <e>kluczu prywatnym</e> i <e>kluczu publicznym</e>.
Zaletą metody jest możliwość nawiązania bezpiecznego połączenia bez ręcznego
wpisywania hasła.
</p>

<p>
Protokoły autentykacji bazujące na wymianie kluczy są relatywnie bezpieczne,
problemem niestety stają się nawyki stosujących je użytkowników, którzy nie w
pełni zdają sobie sprawę z grożącego im niebezpieczeństwa. W pierwszym artykule
przedstawione zostaną metody właściwego postępowania, tak by nie narażać się na
zbędne ryzyko.  W drugim będzie można znaleźć się opis skryptu <c>ssh-agent</c>
buforującego odkodowane klucze prywatne, oraz prezentacja programu
<c>keychain</c>, będącego nakładką na <c>ssh-agent</c>, która oferuje znacznie
większą funkcjonalność, co ważne zachowując odpowiedni poziom bezpieczeństwa.
Każdy zainteresowany zaawansowaną funkcjonalnością OpenSSH z pewnością powinien
kontynuować lekturę, wszystkich innych gorąco do tego zachęcamy.
</p>

</body>
</section>
<section>
<title>Jak działają klucze RSA/DSA</title>
<body>

<p>
W rozdziale znajduje się krótki opis przedstawiający ideę działania kluczy
RSA/DSA. Zacznijmy od opisania hipotetycznej sytuacji w której chcemy użyć
uwierzytelniania RSA by umożliwić lokalnej stacji roboczej, pracującej pod
kontrolą systemu Linux (nazwijmy ją <e>lokalbox</e>), nawiązanie zdalnego
połączenia i otwarcia powłoki na zdalnym komputerze (tą z kolei nazwijmy
<e>remotebox</e>). W chwili obecnej gdy będziemy próbowali nawiązać takie
połączenie, używając klienta <c>ssh</c> zostaniemy przywitani następującym
komunikatem:
</p>

<pre caption="Połączenie z remotebox">
$ <i>ssh drobbins@remotebox</i>
drobbins@remotebox's password:
</pre>

<p>
Na przedstawionym listingu widzimy <e>domyślną</e> dla <c>ssh</c> metodę
autentykacji. Zostaliśmy poproszeni o podanie hasła dla użytkownika
<e>drobbins</e> na komputerze <e>remotebox</e>. Teraz jeśli postąpimy zgodnie z
instrukcjami <c>ssh</c>, używając swojego bezpiecznego protokołu
uwierzytelniania, prześle podane hasło przez sieć do <e>remotebox</e> by dokonać
odpowiedniej weryfikacji. Jednak w przeciwieństwie do <c>telnetu</c>, dane
przesyłane są w formie zakodowanej, więc hasło nie może zostać w łatwy sposób
przechwycone przez kogoś podsłuchującego nasze połączenie. Po porównaniu
przesłanego hasła z zawartością bazy znajdującej się na <e>remotebox</e>,
połączenie zostaje zestawione, w przypadku gdy hasła są takie same, lub zerwane
w przeciwnym przypadku. Domyślna metoda weryfikacji stosowana przez <c>ssh</c>
jest całkiem bezpieczna, jednak wykorzystanie RSA i DSA daje nam wiele nowych i
interesujących możliwości.
</p>

<p>
Jednak w przeciwieństwie do uwierzytelniania z użyciem hasła, autentykacja RSA
wymaga dokonania pewnych zmian w konfiguracji. Na szczęście musimy je wykonać
tylko jeden raz, a po ich dokonaniu nawiązanie bezpiecznego połączenia z
<e>localbox</e> na <e>remotebox</e> będzie bardzo proste. Pierwszą czynnością
jaką musimy wykonać jest stworzenie pary kluczy, jednego prywatnego i jednego
publicznego. Posiada ona bardzo interesujące właściwości, klucz publiczny może
służyć tylko do <e>szyfrowania</e> wiadomości, którą odczytać będzie mógł tylko
właściciel klucza prywatnego, jako że tylko on może z powodzeniem zostać użyty
do <e>deszyfracji</e> wcześniej zakodowanej informacji.  Protokół
uwierzytelniania RSA (i DSA) używa tej specjalnej właściwości pary kluczy, by
nawiązać bezpieczne połączenie, nie ma wtedy potrzeby wysyłania przez sieć
żadnych tajnych informacji.
</p>

<p>
By móc skorzystać z dobrodziejstw uwierzytelniania RSA i DSA musimy
przeprowadzić prostą i krótką procedurę konfiguracji, kopiujemy <e>klucz
publiczny</e> na <e>remotebox</e>. Klucz ten nie jest nazywany "publicznym" bez
powodu. Jako, że może on zostać użyty jedynie do <e>szyfrowania</e> wiadomości
przeznaczonych dla nas (właściciela klucza prywatnego), nie musimy się
przejmować jeśli wpadnie w niepowołane ręce. Gdy zostanie on przekopiowany na
<e>remotebox</e> i zapisany w specjalnym pliku
(<path>~/.ssh/authorized_keys</path>), demon <c>sshd</c> uruchomiony na
<e>remotebox</e> będzie mógł go znaleźć. Będziemy wtedy gotowi do nawiązania
połączenia z użyciem uwierzytelniania RSA.
</p>

<p>
Wystarczy już tylko wpisać <c>ssh drobbins@remotebox</c>, będąc zalogowanym na
<e>localbox</e>. Do tej pory postępowanie jest podobne, jednak od tego momentu
procedura nawiązywania połączenia wygląda już inaczej. Klient <c>ssh</c>
informuje demona <c>sshd</c>, uruchomionego na <e>remotebox</e>, że chce użyć
protokołu uwierzytelniania RSA. W odpowiedzi, na nasz lokalny komputer, wysyłana
jest losowa liczba, zaszyfrowana kluczem publicznym.  Następnie zostaje ona
poddana procedurze deszyfracji, w tym momencie jest używany nasz klucz prywatny
i z powrotem wysłana na <e>remotebox</e>, jakby mówiąc "Widzisz, ja naprawdę
<e>posiadam</e> pasujący klucz prywatny; Udało mi się poprawnie odczytać
zakodowaną wiadomość!" Ostatnim etapem jest weryfikacja, czy zwrócona liczba
odpowiada wysłanej i jeśli tak właśnie jest demon <c>sshd</c> doje nam dostęp do
<e>remotebox</e>. Należy zauważyć, że cała procedura odbywa się w sposób
automatyczny i nie wymaga żadnej ingerencji użytkownika.
</p>

</body>
</section>
<section>
<title>Dwa wnioski</title>
<body>

<p>
Zanim przejdziemy do omawiania szczegółów związanych z uwierzytelnianiem RSA i
DSA należy zwrócić uwagę na dwa istotne wnioski. Po pierwsze, tak naprawdę
musimy stworzyć tylko jedną parę kluczy. Możemy następnie skopiować klucz
publiczny na dowolną ilość zdalnych maszyn, do których chcemy mieć dostęp.
Wszystkie, by dokonać odpowiedniej weryfikacji, będą używać jednego klucza
prywatnego znajdującego się na lokalnym komputerze. Nie ma więc potrzeby
generować pary kluczy dla <e>każdego</e> komputera, na który chcemy mieć
możliwość zdalnego logowania.
</p>

<p>
Drugą istotną sprawą jest bardzo ważny fakt, <e>klucz prywatny nie powinien
wpaść w niepowołane ręce</e>. Jest on elementem gwarantującym dostęp do zdalnych
kont ssh i jeśli ktokolwiek go uzyska będzie mógł uzyskać do nich wszystkich
dostęp. Więc podobnie jak w przypadku kluczy do domu powinniśmy go strzec jak
"oka w głowie". W świecie bitów i bajtów oznacza to, że nikt niepowołany nie
powinien mieć uprawnień by odczytać lub przekopiować plików je zawierających.
</p>

<p>
Oczywiście deweloperzy <c>ssh</c> doskonale zdają sobie sprawę z tego jak ważne
są klucze prywatne i dlatego wbudowali kilka dodatkowych zabezpieczeń w
<c>ssh</c> i <c>ssh-keygen</c> tak, by nie można w łatwy sposób przechwycić
kluczy. Po pierwsze, w przypadku gdy klucz będzie w stanie odczytać ktokolwiek
za wyjątkiem jego właściciela to zostaniemy o tym poinformowani. Dzięki czemu
będziemy wiedzieć, że uprawnienia do pliku przechowującego klucze prywatne
powinny zostać zmienione. Po drugie, gdy tworzymy parę kluczy, <c>ssh-keygen</c>
prosi o podanie hasła. Jeżeli je podamy to zostanie ono użyte bo zaszyfrować
klucz prywatny, więc nawet gdy ktoś niepowołany uzyska dostęp do pliku
przechowującego klucze, to bez znajomości hasła nie będzie mógł go wykorzystać.
Po poznaniu najważniejszych elementów związanych z generacją kluczy czas na opis
konfiguracji <c>ssh</c> tak, by używał protokołów uwierzytelniania RSA i DSA.
</p>

</body>
</section>
<section>
<title>Generacja kluczy z bliska</title>
<body>

<p>
Pierwszym krokiem w czasie konfiguracji uwierzytelniania RSA jest stworzenie
pary kluczy, prywatnego i publicznego. Protokół autentykacji RSA, będący
podstawią metod uwierzytelniania używanych przez pierwsze wersje <c>ssh</c>,
powinien poprawnie działać w przypadku każdej wersji OpenSSH, ale pomimo tego
najlepiej jest posiadać najnowszą dostępną wersję, w czasie pisania tego
artykułu była to openssh-2.9_p2 {{ FIXME - przy tłumaczeniu to 4.2_p1 }}. By
wygenerować parę kluczy RSA należy postępować następująco:
</p>

<pre caption="Narzędzie ssh-keygen">
$ <i>ssh-keygen</i>
Generating public/private rsa1 key pair.
Enter file in which to save the key (/home/drobbins/.ssh/identity): <comment>(naciśnij enter)</comment>
Enter passphrase (empty for no passphrase): <comment>(wpisz hasło)</comment>
Enter same passphrase again: <comment>(ponownie wpisz hasło)</comment>
Your identification has been saved in /home/drobbins/.ssh/identity.
Your public key has been saved in /home/drobbins/.ssh/identity.pub.
The key fingerprint is:
a4:e7:f2:39:a7:eb:fd:f8:39:f1:f1:7b:fe:48:a1:09 drobbins@localbox
</pre>

<p>
Gdy <c>ssh-keygen</c> pyta nas o lokalizację kluczy, wciskamy enter by
zatwierdzić domyślną wartość (<path>/home/drobbins/.ssh/identity</path>).
Wygenerowane klucze prywatne będą przechowywane w powyższej lokalizacji,
podobnie jak klucz <e>publiczny</e>, który będzie znajdował się w pliku
identity.pub.
</p>

<p>
Należy zauważyć, że <c>ssh-keygen</c> zapytał nas o hasło. Najlepiej gdy będzie
ono odpowiednio skomplikowane i długie (siedem lub więcej ciężkich do
przewidzenia znaków). Klucz prywatny zostanie zaszyfrowany
(<path>~/.ssh/identity</path>) właśnie przy jego użyciu, więc nawet gdy ktoś
pozna nasz klucz prywatny, będzie on dla niego bezwartościowy gdy nie będzie
znał podanego hasła i nie będzie w stanie go poznać.
</p>

</body>
</section>
<section>
<title>Kompromis</title>
<body>

<p>
Gdy, w czasie generacji kluczy, podamy hasło, <c>ssh-keygen</c> zabezpieczy
klucz prywatny i uniemożliwi jego odczyt przez osoby trzecie, przechowywane będą
tylko zakodowane dane. Jednak wiąże się to również z pewnymi niedogodnościami,
za każdym razem gdy będziemy chcieli zalogować się na konto
<e>drobbins@remotebox</e>, będziemy musieli podać hasło zabezpieczające nasze
klucze. Po jego podaniu <c>ssh</c> będzie mógł dokonać poprawnej weryfikacji i
umożliwi nam dostęp. Sam mechanizm działania jest zupełnie inny, niż w przypadku
domyślnej metody uwierzytelniania używanej przez <c>ssh</c>, ale w dalszym ciągu
jesteśmy zmuszeni do wpisywanie pewnej "tajnej frazy".
</p>

<pre caption="Logowanie z użyciem hasła do klucza prywatnego">
$ <i>ssh drobbins@remotebox</i>
Enter passphrase for key '/home/drobbins/.ssh/identity': <comment>(wpisz hasło
do klucza prywatnego)</comment>
Last login: Thu Jun 28 20:28:47 2001 from localbox.gentoo.org 

Welcome to remotebox!

$
</pre>

<p>
Mimo, że konfiguracja, gdy logowanie z użyciem uwierzytelniania RSA i DSA nie
wymaga wprowadzenia hasła, wydaje się kusząca, nie należy jej stosować bez
pełnej świadomości o jej wpływie na bezpieczeństwo. Przechowywanie na komputerze
niezakodowanego klucza prywatnego powoduje, że każdy kto może go odczytać, może
to być zarówno włamywacz lub w przypadku błędnej konfiguracji różnych elementów
systemu operacyjnego (np. praw dostępu do pliku) także inny użytkownik, uzyska
dostęp wszędzie tam gdzie używamy tego rodzaju autentykacji.
</p>

<p>
Pomimo tego ryzyka, cała idea w dalszym ciągu jest interesująca i mimo
związanych z nią niebezpieczeństw można się pokusić o skorzystanie z niej. Ale
na szczęście <e>istnieje znacznie lepsze rozwiązanie!</e>, możliwe jest
logowanie bez użycia hasła i nie musimy w tym celu poświęcać bezpieczeństwa.
Zaawansowane zagadnienia związane z narzędziem mającym właśnie takie możliwości
można znaleźć drugim artykule w tej serii.  Najpierw jednak poznajmy pewnie
podstawy działania skryptu <c>ssh-agent</c> i skonfigurujmy odpowiednio
uwierzytelnianie RSA i DSA. Oto dokładne wskazówki:
</p>

</body>
</section>
<section>
<title>Generacja pary kluczy RSA</title>
<body>

<p>
Aby skonfigurować uwierzytelnianie RSA, należy przeprowadzić następującą
procedurę generacji kluczy publicznego i prywatnego, wystarczy ją wykonać jeden
raz:
</p>

<pre caption="Generowanie kluczy...">
$ <i>ssh-keygen</i>
</pre>

<p>
Należy wprowadzić domyślną lokalizację, gdzie mają być przechowywane
wygenerowane klucze (najczęściej będzie to <path>~/.ssh/identity</path> i
<path>~/.ssh/identity.pub</path> dla klucza publicznego), a następnie podać
hasło. Po zakończeniu działania <c>ssh-keygen</c>, wygenerowany zostanie klucz
publiczny, oraz klucz prywatny który zostanie zakodowany z użyciem podanego
hasła.
</p>

</body>
</section>
<section>
<title>Instalacja klucza publicznego RSA</title>
<body>

<p>
Kolejnym krokiem jest konfiguracja systemu na którym uruchomiony jest
<c>sshd</c>, gdzie chcemy zastosować uwierzytelnianie z użyciem
<e>publicznego</e> klucza RSA. W tym celu wystarczy skopiować wygenerowany
wcześniej klucz publiczny na zdalny system:
</p>

<pre caption="Kopiowanie klucza publicznego">
$ <i>scp ~/.ssh/identity.pub drobbins@remotebox:</i>
</pre>

<p>
Uwierzytelnianie z użyciem RSA nie jest jeszcze włączone więc musimy podać nasze
hasło dostępu do konta na <e>remotebox</e>. Następnie musimy jeszcze zalogować
się na zdalny komputer i dodać odpowiedni wpis, zawierający nasz klucz
publiczny, do pliku <path>~/.ssh/authorized_keys</path>:
</p>

<pre caption="Instalacja klucza publicznego">
$ <i>ssh drobbins@remotebox</i>
drobbins@remotebox's password: <comment>(wpisz hasło)</comment>
Last login: Thu Jun 28 20:28:47 2001 from localbox.gentoo.org 

Welcome to remotebox!

$ <i>cat identity.pub >> ~/.ssh/authorized_keys</i>
$ <i>exit</i>
</pre>

<p>
Po wykonaniu powyższych czynności udało nam się skonfigurować uwierzytelnianie
RSA, teraz by zalogować się na <e>remotebox</e> musimy podać hasło
zabezpieczające nasz klucz prywatny, a nie hasło dostępu do zdalnego konta,
oczywiście jeśli będziemy używać <c>ssh</c>.
</p>

<pre caption="Logowanie z użyciem klucza prywatnego">
$ <i>ssh drobbins@remotebox</i>
Enter passphrase for key '/home/drobbins/.ssh/identity': 
</pre>

<p>
Właśnie skonfigurowaliśmy dostęp do komputera <e>remotebox</e> z użyciem
uwierzytelniania RSA! Jeśli pomimo wykonania wszystkich powyższych wskazówek w
czasie logowania występują jakieś problemy spróbuj użyć komendy <path>ssh -1
drobbins@remotebox</path>. Jej użycie wymusi na ssh zastosowanie odpowiedniej
wersji protokołu autentykacji, taka sytuacja może mieć miejsce w przypadku, gdy
zdalny system został skonfigurowany by domyślnie używać uwierzytelniania DSA.
Jeśli pomimo tego mamy problemy, należy upewnić się, że plik konfiguracyjny
<path>/etc/ssh/ssh_config</path> nie zawiera wpisu <c>RSAAuthentication no</c>,
jeżeli w naszym przypadku go znajdziemy to najlepiej dodać znak komentarza ("#")
na początku linii. Gdy, pomimo przeprowadzenia tych operacji, dalej mamy
problemy, należy skontaktować się z administratorem zdalnego komputera
<e>remotebox</e>, by sprawdził on czy konfiguracja serwera <c>sshd</c> umożliwia
użycie uwierzytelniania RSA.
</p>

</body>
</section>
<section>
<title>Generacja pary kluczy DSA</title>
<body>

<p>
Klucze RSA są wymagane jeśli używamy pierwszej wersji protokołu <c>ssh</c>, w
przypadku wersji 2 używane są klucze DSA, oba typy są wspierane przez każdą nowa
wersja OpenSSH. W przypadku konfiguracji uwierzytelniania DSA cała procedura
jest bardzo podobna, różni się tylko w kilku szczegółach.
</p>

<pre caption="Generowanie kluczy DSA">
$ <i>ssh-keygen -t dsa</i>
</pre>

<p>
Zostaniemy poproszeni o podanie hasła, które także w tym przypadku zostanie
użyte do zakodowania klucza prywatnego, wskazane jest więc użycie odpowiednio
bezpiecznego i trudnego do odgadnięcia. Podobnie będziemy mogli podać
lokalizację, gdzie <c>ssh-keygen</c> zapisze wygenerowane klucze prywatny i
publiczny (domyślnie jest to <path>~/.ssh/id_dsa</path> i
<path>~/.ssh/id_dsa.pub</path> co możemy bez obaw zatwierdzić). Gdy generacja
zostanie zakończona sukcesem należy następnie zainstalować klucz publiczny na
zdalne komputery, gdzie chcemy mieć dostęp.
</p>

</body>
</section>
<section>
<title>Instalacja klucza publicznego DSA</title>
<body>

<p>
Instalacja klucza publicznego DSA przebiega niemal w identyczny sposób jak miało
to miejsce w poprzednim przypadku, wystarczy skopiować plik
<path>~/.ssh/id_dsa.pub</path> na <e>remotebox</e>, a następnie po zalogowaniu
na zdalny komputer nadpisać <path>~/.ssh/authorized_keys2</path>, dodając do
niego zawartość przekopiowanego wcześniej pliku. Należy zauważyć, że w tym
przypadku modyfikujemy zawartość innego pliku, nie <path>authorized_keys</path>
jak miało to miejsce w czasie konfiguracji uwierzytelniania RSA. Po wykonaniu
powyższych czynności, gdy będziemy chcieli zalogować się z <e>localbox</e> na
<e>remotebox</e> będziemy musieli podać hasło zabezpieczające nasz klucz
prywatny, a nie hasło dostępu do konta.
</p>

<note>
Zalecane jest stosowanie wersji 2 protokołu ssh, ze względu na słabości związane
z jego starszą, pierwszą odmianą.
</note>

</body>
</section>
<section>
<title>W kolejnej części</title>
<body>

<p>
Z pewnością teraz konfiguracja uwierzytelniania RSA lub DSA nie stanowi już
problemu.  Ciągle jednak każde logowanie na zdalny komputer wymaga od nas
wprowadzenia hasła. W kolejnym artykule w serii przedstawione zostaną
zagadnienia związane z <c>ssh-agent</c>, interesującym systemem, który umożliwi
nam ominąć tą niedogodność i nawiązać połączenie <e>bez</e> wpisywania hasła i
co równie ważne zachować odpowiedni poziom bezpieczeństwa (klucze prywatne są
zabezpieczone hasłem). Będzie w nim można znaleźć także opis <c>keychain</c>,
przydatnej, ułatwiającej prace i poprawiającej bezpieczeństwo, nakładki na
<c>ssh-agent</c>.  Poniżej można znaleźć materiały umożliwiające przeprowadzenie
"badań" we własnym zakresie.
</p>

</body>
</section>
</chapter>
<chapter id="resources">
<title>Materiały</title>
<section>
<body>

<ul>
  <li>
    Pozostałe artykuły Daniela Robbinsa z serii, <uri
    link="/doc/en/articles/openssh-key-management-p2.xml">Zarządzanie
    kluczami OpenSSH, Część 2</uri> i <uri
    link="/doc/en/articles/openssh-key-management-p3.xml">Zarządzanie
    kluczami OpenSSH, Część 3</uri>.
  </li>
  <li>
    Strona domowa projektu <uri link="http://www.openssh.com">OpenSSH</uri>.
  </li>
  <li>
    <uri link="http://www.openssh.com/faq.html">OpenSSH FAQ</uri>.
  </li>
  <li>
    <uri link="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</uri>
    - doskonały klient <c>ssh</c> dla systemów rodziny Windows.
  </li>
  <li>
    <e>SSH, The Secure Shell: The Definitive Guide</e> - doskonałe źródło
    informacji dotyczące ssh. Strona <uri
    link="http://www.snailbook.com/">autorów</uri> zawiera dodatkowe
    informacje o książce, FAQ, nowości i poprawki.
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
