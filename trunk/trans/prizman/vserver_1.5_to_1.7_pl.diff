--- vserver_old.xml	2006-04-29 10:04:00.000000000 +0200
+++ vserver_new.xml	2006-04-29 18:03:21.000000000 +0200
@@ -16,7 +16,7 @@
 </author>
 
 <abstract>
-W poradniku nauczymy się konfigurować podstawowy wirtualny serwer, wykorzystując
+W poradniku tym nauczymy się konfigurować podstawowy wirtualny serwer, wykorzystując
 do tego technologię Linux-VServer.
 </abstract>
 
@@ -24,8 +24,8 @@
 <!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
 <license/>
 
-<version>1.3</version>
-<date>2005-12-19</date>
+<version>1.5</version>
+<date>2006-03-17</date>
 
 <chapter>
 <title>Wprowadzenie</title>
@@ -98,8 +98,7 @@
 
 Linux VServer ---&gt;
   [ ] Enable Legacy Kernel API
-<comment>(Nie ustawiamy!)</comment>
-  [ ] Disable Legacy Networking Kernel API
+  [*] Disable Legacy Networking Kernel API
 <comment>(Zalecane)</comment>
   [*] Enable Proc Security
   [*] Enable Hard CPU Limits
@@ -109,8 +108,10 @@
 </pre>
 
 <note>
-Jeśli korzysta się z reiserf, należy w jądrze uaktywnić opcję "extended
-attributes for reiserfs" - rozszerzone funkcje reiserfs.
+Jeśli korzysta się z reiserfs jako systemu plików, na którym będą przetrzymywane
+obrazy, należy w jądrze uaktywnić opcję "extended attributes for reiserfs" -
+rozszerzone funkcje reiserfs, oraz dodać opcję <c>attrs</c> do pliku
+<path>/etc/fstab</path>.
 </note>
 
 <pre caption="Dodawanie funkcji dla reiserfs">
@@ -119,11 +120,6 @@
   [*]   ReiserFS extended attributes
 </pre>
 
-<p>
-Konieczne będzie także dodanie opcji <c>attrs</c> w pliku
-<path>/etc/fstab</path> dla partycji wirtualnego serwera.
-</p>
-
 <pre caption="Przykładowa linia z fstab z dodatkowymi atrybutami">
 /dev/hdb /vserver reiserfs noatime,attrs 0 0
 </pre>
@@ -138,7 +134,7 @@
 # <i>make</i>
 <comment>(Instalacja)</comment>
 # <i>make modules_install</i>
-# <i>cp arch/i386/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
+# <i>cp arch/&lt;arch&gt;/boot/bzImage /boot/kernel-&lt;KERNELVERSION&gt;-vserver-&lt;VSERVERVERSION&gt;</i>
 <comment>(Jeśli to potrzebne, to edytujemy plik konfiguracyjny bootloadera i uruchamiamy ponownie system)</comment>
 # <i>reboot</i>
 </pre>
@@ -151,13 +147,16 @@
 
 <p>
 Do zarządzania serwerami wirtualnymi potrzebujemy pakietu util-vserver, który
-zawiera wszystkie potrzebne do tego programy.
+zawiera wszystkie potrzebne do tego programy. Należy jednak pamiętać, że
+istnieje również pakiet <c>vserver-utils</c>, który jest nową implementacją
+'VServer kernel API'. Na razie nie jest on jednak dostatczenie dopracowany, aby
+można go było normalnie używać.
 </p>
 
 <note>
-Narzędzia z jakich korzystamy na potrzeby tego przewodnika muszą być co
-najmniej w wersji <c>&gt;=sys-apps/util-vserver-0.30.208-r3</c>. Czasami trzeba
-je odmaskować.
+Ta wersja podręcznika wymaga funkcji dostępnych tylko w wersji
+<c>&gt;=sys-apps/util-vserver-0.30.208-r3</c>. Może zatem zajść potrzeba
+odmaskowania tego pakietu.
 </note>
 
 <pre caption="Instalacja pakietu util-vserver">
@@ -165,20 +164,25 @@
 </pre>
 
 <p>
-W celu zapewnienia odpowiednich praw dostępu do systemu plików /proc, po każdym
-ponownym uruchomieniu komputera trzeba będzie wykonać polecenie
-<c>vprocunhide</c>.
+W celu zapewnienia odpowiednich praw dostępu do systemu plików
+<path>/proc</path>, po każdym ponownym uruchomieniu komputera trzeba będzie
+wykonać polecenie <c>vprocunhide</c>. Aby to nieco zautomatyzować można dodać
+vservers do domyślnego poziomu uruchamiania:
 </p>
 
-<pre caption="Skrypt startowy vprocunhide">
-# <i>rc-update add vprocunhide default</i>
-# <i>/etc/init.d/vprocunhide start</i>
+<pre caption="Skrypt startowy vservers">
+# <i>rc-update add vservers default</i>
+# <i>/etc/init.d/vservers start</i>
 </pre>
 
+<note>
+Powyższy skrypt dodatkowo uruchomi domyślne vservery. Poniżej znajduje się
+więcej informacji na ten temat.
+</note>
+
 <p>
-Skrypt vshelper używany jest do prawidłowego zatrzymywania i ponownego
-uruchamiania wirtualnych serwerów. Musimy wskazać kernelowi lokalizację, w
-której znajduje się ów skrypt:
+Skrypt vshelper używany jest do prawidłowego ponownego uruchamiania wirtualnych
+serwerów. Musimy wskazać kernelowi lokalizację, w której znajduje się ów skrypt:
 </p>
 
 <pre caption="Konfiguracja vshelper">
@@ -207,7 +211,7 @@
 Dla naszego vservera musimy wybrać identyfikator kontekstowy
 (odradzamy używania dynamicznych identyfikatorów), a także
 ustawić potrzebne parametry urządzenia sieciowego (w tym przykładzie jest to
-interfejs eth0, skonfigurowany dla 192.168.1.254/24 oraz identyfikator
+interfejs eth0, skonfigurowany dla 192.168.1.253/24 oraz identyfikator
 kontekstowy, który powstał z dwóch ostatnich części adresu IP wirtualnego serwera).
 </p>
 
@@ -216,7 +220,7 @@
   <i>--hostname gentoo \</i>
   <i>--context 1253 \</i>
   <i>--interface eth0:192.168.1.253/24 \</i>
-  <i>stage3 /ścieżka/do/stage3-tarball.tar.bz2</i>
+  <i>stage3 /ścieżka/do/stage3-&lt;arch&gt;-&lt;data&gt;.tar.bz2 &lt;arch&gt;</i>
 </pre>
 
 <note>
@@ -244,7 +248,7 @@
 
 <pre caption="Tworzenie tarballa szablonu">
 # <i>cd /vservers/gentoo-template</i>
-# <i>tar cjvpf ../gentoo-template.tar.bz2 ./</i>
+# <i>tar cjvpf ../gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 ./</i>
 </pre>
 
 <p>
@@ -258,7 +262,7 @@
   <i>--hostname myguest \</i>
   <i>--context 1252 \</i>
   <i>--interface eth0:192.168.1.252/24 \</i>
-  <i>template ./gentoo-template.tar.bz2</i>
+  <i>template ./gentoo-template-&lt;arch&gt;-&lt;date&gt;.tar.bz2 &lt;arch&gt;</i>
 </pre>
 
 <note>
@@ -303,12 +307,142 @@
 
 </body>
 </section>
+</chapter>
+
+<chapter>
+<title>Łatwe zarządzanie vserverem</title>
+<section>
+<title>Uruchamianie gości razem z systemem</title>
+<body>
+
+<p>
+Jeżeli chcemy, aby niektórzy goście uruchamiali się automatycznie w momencie
+startu systemu, możemy oznaczyć je "MARKiem", a następnie w konfiguracji
+gości ustawić, aby skrypt startowy uruchamiał wszystkie "MARKi".
+</p>
+
+<pre caption="Konfigurowanie 'MARKow' dla każdego gościa">
+<comment>(Poniższe czynności należy wykonać dla każdego gościa, którego chcemy
+uruchamiać automatycznie)</comment>
+# <i>mkdir -p /etc/vservers/myguest/apps/init</i>
+# <i>echo "default" > /etc/vservers/myguest/apps/init/mark</i>
+</pre>
+
+<note>
+Dopóki wszystcy goście oznaczeni jako "default" są automatycznie uruchamiani,
+nie musimy robić nic więcej. Jeżeli mamy różne oznaczenia powinniśmy również
+uaktualnić <path>/etc/conf.d/vservers</path>.
+</note>
+
+</body>
+</section>
+<section>
+<title>Udogodnienia w gentoo</title>
+<body>
+
+<p>
+Ebuild do util-vserver instaluje w Gentoo pewne udogodnienia. Wiemy już z
+poprzedniego rozdziału o <c>vserver-new</c>. W tym rozdziale, dowiemy się jak
+używać <c>vesync</c>, <c>vemerge</c> oraz <c>vupdateworld</c> w celu utrzymania
+aktualności portage, a także <c>vdispatch-conf</c> do aktualizowania gości.
+</p>
+
+</body>
+</section>
+<section>
+<title>Utrzymanie aktualności portage</title>
+<body>
+
+<p>
+Skrypt <c>vesync</c> może nam pomóc w utrzymaniu aktualności cache metadata oraz
+"overlayów". <c>vemerge</c> jest prostą nakładką na <c>emerge</c>.
+</p>
+
+<pre caption="Przykłady">
+<comment>(Aktualizacja metadata dla 'myguest')</comment>
+# <i>vesync myguest</i>
+<comment>(Aktualizacja metadata dla wszystkich gości)</comment>
+# <i>vesync -a</i>
+<comment>(Aktualizacja metadata dla wszystkich gości poza 'myguest')</comment>
+# <i>vesync -a -e myguest</i>
+<comment>(Aktualizacja 'moj_overlay' dla wszystkich gości)</comment>
+# <i>vesync -a \</i>
+  <i>-overlay /usr/local/overlays/moj_overlay \</i>
+  <i>-overlay-host rsync://rsync.mojhost.com/moj_overlay \</i>
+  <i>-overlay-only</i>
+<comment>(emerge app-editors/vim w 'myguest')</comment>
+# <i>vemerge myguest app-editors/vim -va</i>
+</pre>
+
+<note>
+Skrypt ten wymaga podzielonego drzewa portage.
+</note>
+
+</body>
+</section>
+<section>
+<title>Aktualizacja "guestów"</title>
+<body>
+
+<p>
+Goście w Gentoo mogą dzielić się pakietami w celu zaoszczędzenia czasu
+kompilacji. W celu utworzenia ,,dzielonych pakietów'' należy utworzyć głowny
+folder dla pakietów na hoście. Użyjemy do tego celu
+<path>/var/cache/vpackages</path> na hoście i podmontujemy go do
+<path>/usr/portage/packages</path> dla każdego gościa.
+</p>
+
+<pre caption="Dodawanie 'bind mount' do konfiguracji gościa">
+# <i> mkdir -p /var/cache/vpackages</i>
+# <i>$EDITOR /etc/vservers/myguest/fstab</i>
+<comment>(Tę linię dodajemy na końcu)</comment>
+/var/cache/vpackages /usr/portage/packages none bind, rw 0 0
+</pre>
+
+<p>
+Teraz możemy użyć <c>vupdateworld</c> aby zaktualizować każdego gościa.
+Polecenie to jest odpowiednikiem <c>emerge --deep --update --newuse world</c>
+zależnie od opcji za jakimi zostanie uruchomine.
+</p>
+
+<pre caption="Przykłady vupdateworld">
+<comment>(Udawanie aktualizacji dla 'myguest')</comment>
+# <i>vupdateworld -p myguest</i>
+<comment>(Aktualizacja 'myguest' przy użyciu binarnych pakietów)</comment>
+# <i>vupdateworld -k myguest</i>
+<comment>(Aktualizacja wszystkich gości przy uzyciu binarnych pakietow)</comment>
+# <i>vupdateworld -ka</i>
+</pre>
+
+<note>
+W celu otrzymania binarnych pakietół możemy użyć PORTAGE_BINHOST (więcej
+informacji w <c>man make.conf</c>) lub FEATURES="buildpkg" w jednym bądź
+większej ilości gości.
+</note>
+
+<p>
+Po pomyślnym zakończeniu aktualizacji możemy łatwo zaktualizować wszystkie pliki
+konfiguracyjne przy użyciu <c>vdispatch-conf</c>. Jest to prosta nakładka na
+<c>dispatch-conf</c> i jej działanie jest dokładnie takie samo.
+</p>
+
+<pre caption="Przykłady zastosowania vdispatch-conf">
+<comment>(Aktualizacja plików koncifuracyjnych dla "myguest")</comment>
+# <i>vdispatch-conf myguest</i>
+<comment>(Aktualizacja plików konfiguracyjnych dla wszystkich gości)</comment>
+# <i>vdispatch-conf -a</i>
+</pre>
+
+</body>
+</section>
+
 <section>
 <title>Kontakt</title>
 <body>
 
 <p>
-W przypadku problemów można kontaktować się z autorem tekstu lub zgłosić
+W przypadku problemów można kontaktować się z <mail
+link="hollow@gentoo.org">autorem tekstu</mail> lub zgłosić
 problem do <uri link="http://bugs.gentoo.org">Bugzilli</uri>.
 </p>
 
